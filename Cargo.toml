[package]
name = "snaprag"
version = "0.1.0"
edition = "2021"
description = "A Farcaster data synchronization and RAG (Retrieval-Augmented Generation) library"
license = "MIT"
repository = "https://github.com/your-org/snaprag"
keywords = ["farcaster", "rag", "synchronization", "database", "vector-search"]
categories = ["database", "web-programming", "data-structures"]

# Library configuration
[lib]
name = "snaprag"
path = "src/lib.rs"

# Binary configuration
[[bin]]
name = "snaprag"
path = "src/main.rs"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "chrono", "uuid", "json"] }
pgvector = { version = "0.3", features = ["sqlx", "serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
dashmap = "6.0"
anyhow = "1.0"
thiserror = "1.0"
toml = "0.8"
config = "0.14"
url = "2.4"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
tracing-appender = "0.2"
protobuf = "2.28"
http = "1.0"
sha2 = "0.10"
base64 = "0.21"
hex = "0.4"
reqwest = { version = "0.11", features = ["json"] }
tempfile = "3.0"
clap = { version = "4.0", features = ["derive"] }
tonic = "0.10"
prost = "0.12"
libc = "0.2"
futures = "0.3"
rust_decimal = { version = "1.0", features = ["serde"] }
ethers = { version = "2.0", features = ["abigen", "ws"] }
# Web server dependencies
axum = { version = "0.7", features = ["json", "macros"] }
tower = { version = "0.4", features = ["timeout", "limit"] }
tower-http = { version = "0.5", features = ["cors", "trace", "compression-gzip"] }
hyper = { version = "1.0", features = ["full"] }
tokio-util = "0.7"

# x402 payment protocol (local development)
# NOTE: Switch to crate or git dependency for production
# rust-x402 = "0.1"  # Production
# rust-x402 = { git = "https://github.com/RyanKung/x402_rs" }  # Git
rust-x402 = { path = "../rust-x402", features = ["axum"], optional = true }

[features]
default = []
payment = ["rust-x402"]

[build-dependencies]
protobuf-codegen-pure = "2.28"
tonic-build = "0.10"

[lints.rust]
# Ignore warnings from generated protobuf code
unused_lifetimes = "allow"
elided-lifetimes-in-paths = "allow"
unused_imports = "allow"
unused_variables = "allow"
dead_code = "allow"

# Strict settings for tests
[profile.test]
# Enable debug info for better test debugging
debug = true
# Enable overflow checks for tests
overflow-checks = true

# Strict clippy configuration for tests
[lints.clippy]
# Allow warnings in generated code but be strict in our code
all = { level = "warn", priority = -1 }
pedantic = { level = "warn", priority = -1 }
nursery = { level = "warn", priority = -1 }
cargo = { level = "warn", priority = -1 }

# Allow some specific warnings that are common in test code
unused_io_amount = "allow"
unused_self = "allow"


# Allow specific pedantic lints after careful review
# These are intentional design decisions:

# Type conversions: Farcaster protocol uses u64/u32, PostgreSQL uses i64/i32
# All conversions are within safe ranges for Farcaster data
cast_precision_loss = "allow"  # u64 → f64 for statistics/calculations (values < 2^53)
cast_possible_wrap = "allow"   # u64 → i64, u32 → i32 (Farcaster IDs are < i64::MAX)
cast_sign_loss = "allow"       # i64 → u64 for protocol interop (values always positive)
cast_possible_truncation = "allow"  # Controlled truncation for enum types

# Code organization: Some const definitions are intentionally local to functions
items_after_statements = "allow"  # Module-level consts already extracted for key ones

# Documentation: Internal implementation details don't need exhaustive docs
missing_errors_doc = "allow"   # Public APIs have docs; internal functions are self-documenting
missing_panics_doc = "allow"   # Panics are intentional (unreachable, expect)

# Performance: format! is more readable in some contexts vs write! micro-optimization
format_push_string = "allow"   # Hot paths already use write!; readability > micro-opt elsewhere

# Style: These are style preferences, not correctness issues
too_many_lines = "allow"       # Some complex functions need length (with good comments)
option_if_let_else = "allow"   # if let is often clearer than map_or_else
type_complexity = "allow"      # Complex tuples documented and will be refactored later
significant_drop_tightening = "allow"  # Drop order is intentional
empty_line_after_doc_comments = "allow"  # Formatting preference
needless_continue = "allow"    # continue in retry loops is clearer than complex nesting
similar_names = "allow"        # age_a_days, age_b_days are clear in context
unreadable_literal = "allow"   # Timestamps/constants don't need separators
doc_markdown = "allow"         # Documentation uses technical terms correctly
use_self = "allow"             # Explicit type names aid readability
must_use_candidate = "allow"   # Reviewed, intentional for internal functions
missing_const_for_fn = "allow" # Most functions don't need const
too_many_arguments = "allow"   # Some functions need many params for clarity
match_same_arms = "allow"      # Explicit arms aid readability
manual_let_else = "allow"      # if let is clearer in many cases
wildcard_imports = "allow"     # Prelude imports are intentional
used_underscore_binding = "allow"  # _var naming is intentional
used_underscore_items = "allow"  # Generated protobuf code uses _Inner pattern
default_trait_access = "allow" # Default::default() is clearer
or_fun_call = "allow"          # Micro-optimization not worth complexity
field_reassign_with_default = "allow"  # Explicit field setting is clearer
should_implement_trait = "allow"  # Trait implementations are intentional
redundant_pattern_matching = "allow"  # Explicit patterns aid readability
needless_collect = "allow"     # Intermediate collections aid readability
match_wildcard_for_single_variants = "allow"  # Explicit matching is clearer
if_same_then_else = "allow"    # Code duplication is intentional for clarity
collection_is_never_read = "allow"  # Collections used for side effects
branches_sharing_code = "allow"  # Shared code in branches is intentional
assigning_clones = "allow"     # clone() is clearer than clone_from() in some cases
unnecessary_wraps = "allow"    # Result for trait/interface consistency

# External dependencies
multiple_crate_versions = "allow"  # Transitive dependencies, not under our control

