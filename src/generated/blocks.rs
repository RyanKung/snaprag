#![allow(clippy::all)]
#![allow(clippy::pedantic)]
#![allow(clippy::nursery)]
#![allow(unused_lifetimes)]
#![allow(elided_lifetimes_in_paths)]
#![allow(unused_parens)]
#![allow(unknown_lints)]
#![allow(renamed_and_removed_lints)]
#![allow(warnings)]

// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `blocks.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Validator {
    // message fields
    pub fid: u64,
    pub signer: ::std::vec::Vec<u8>,
    pub rpc_address: ::std::string::String,
    pub shard_index: u32,
    pub current_height: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // bytes signer = 2;


    pub fn get_signer(&self) -> &[u8] {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::vec::Vec<u8>) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signer, ::std::vec::Vec::new())
    }

    // string rpc_address = 3;


    pub fn get_rpc_address(&self) -> &str {
        &self.rpc_address
    }
    pub fn clear_rpc_address(&mut self) {
        self.rpc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_rpc_address(&mut self, v: ::std::string::String) {
        self.rpc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rpc_address(&mut self) -> &mut ::std::string::String {
        &mut self.rpc_address
    }

    // Take field
    pub fn take_rpc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rpc_address, ::std::string::String::new())
    }

    // uint32 shard_index = 4;


    pub fn get_shard_index(&self) -> u32 {
        self.shard_index
    }
    pub fn clear_shard_index(&mut self) {
        self.shard_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_index(&mut self, v: u32) {
        self.shard_index = v;
    }

    // uint64 current_height = 5;


    pub fn get_current_height(&self) -> u64 {
        self.current_height
    }
    pub fn clear_current_height(&mut self) {
        self.current_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_height(&mut self, v: u64) {
        self.current_height = v;
    }
}

impl ::protobuf::Message for Validator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rpc_address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_index = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signer);
        }
        if !self.rpc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.rpc_address);
        }
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.shard_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.current_height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.current_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.signer.is_empty() {
            os.write_bytes(2, &self.signer)?;
        }
        if !self.rpc_address.is_empty() {
            os.write_string(3, &self.rpc_address)?;
        }
        if self.shard_index != 0 {
            os.write_uint32(4, self.shard_index)?;
        }
        if self.current_height != 0 {
            os.write_uint64(5, self.current_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &Validator| { &m.fid },
                |m: &mut Validator| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signer",
                |m: &Validator| { &m.signer },
                |m: &mut Validator| { &mut m.signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rpc_address",
                |m: &Validator| { &m.rpc_address },
                |m: &mut Validator| { &mut m.rpc_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_index",
                |m: &Validator| { &m.shard_index },
                |m: &mut Validator| { &mut m.shard_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "current_height",
                |m: &Validator| { &m.current_height },
                |m: &mut Validator| { &mut m.current_height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Validator>(
                "Validator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Validator {
        static instance: ::protobuf::rt::LazyV2<Validator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Validator::new)
    }
}

impl ::protobuf::Clear for Validator {
    fn clear(&mut self) {
        self.fid = 0;
        self.signer.clear();
        self.rpc_address.clear();
        self.shard_index = 0;
        self.current_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidatorSet {
    // message fields
    pub validators: ::protobuf::RepeatedField<Validator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorSet {
    fn default() -> &'a ValidatorSet {
        <ValidatorSet as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorSet {
    pub fn new() -> ValidatorSet {
        ::std::default::Default::default()
    }

    // repeated .Validator validators = 1;


    pub fn get_validators(&self) -> &[Validator] {
        &self.validators
    }
    pub fn clear_validators(&mut self) {
        self.validators.clear();
    }

    // Param is passed by value, moved
    pub fn set_validators(&mut self, v: ::protobuf::RepeatedField<Validator>) {
        self.validators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validators(&mut self) -> &mut ::protobuf::RepeatedField<Validator> {
        &mut self.validators
    }

    // Take field
    pub fn take_validators(&mut self) -> ::protobuf::RepeatedField<Validator> {
        ::std::mem::replace(&mut self.validators, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ValidatorSet {
    fn is_initialized(&self) -> bool {
        for v in &self.validators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.validators)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.validators {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorSet {
        ValidatorSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Validator>>(
                "validators",
                |m: &ValidatorSet| { &m.validators },
                |m: &mut ValidatorSet| { &mut m.validators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidatorSet>(
                "ValidatorSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidatorSet {
        static instance: ::protobuf::rt::LazyV2<ValidatorSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorSet::new)
    }
}

impl ::protobuf::Clear for ValidatorSet {
    fn clear(&mut self) {
        self.validators.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidatorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Height {
    // message fields
    pub shard_index: u32,
    pub block_number: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Height {
    fn default() -> &'a Height {
        <Height as ::protobuf::Message>::default_instance()
    }
}

impl Height {
    pub fn new() -> Height {
        ::std::default::Default::default()
    }

    // uint32 shard_index = 1;


    pub fn get_shard_index(&self) -> u32 {
        self.shard_index
    }
    pub fn clear_shard_index(&mut self) {
        self.shard_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_index(&mut self, v: u32) {
        self.shard_index = v;
    }

    // uint64 block_number = 2;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }
}

impl ::protobuf::Message for Height {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shard_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.shard_index != 0 {
            os.write_uint32(1, self.shard_index)?;
        }
        if self.block_number != 0 {
            os.write_uint64(2, self.block_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Height {
        Height::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_index",
                |m: &Height| { &m.shard_index },
                |m: &mut Height| { &mut m.shard_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_number",
                |m: &Height| { &m.block_number },
                |m: &mut Height| { &mut m.block_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Height>(
                "Height",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Height {
        static instance: ::protobuf::rt::LazyV2<Height> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Height::new)
    }
}

impl ::protobuf::Clear for Height {
    fn clear(&mut self) {
        self.shard_index = 0;
        self.block_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Height {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Height {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardHash {
    // message fields
    pub shard_index: u32,
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardHash {
    fn default() -> &'a ShardHash {
        <ShardHash as ::protobuf::Message>::default_instance()
    }
}

impl ShardHash {
    pub fn new() -> ShardHash {
        ::std::default::Default::default()
    }

    // uint32 shard_index = 1;


    pub fn get_shard_index(&self) -> u32 {
        self.shard_index
    }
    pub fn clear_shard_index(&mut self) {
        self.shard_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_index(&mut self, v: u32) {
        self.shard_index = v;
    }

    // bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ShardHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_index = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shard_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.shard_index != 0 {
            os.write_uint32(1, self.shard_index)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardHash {
        ShardHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_index",
                |m: &ShardHash| { &m.shard_index },
                |m: &mut ShardHash| { &mut m.shard_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &ShardHash| { &m.hash },
                |m: &mut ShardHash| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShardHash>(
                "ShardHash",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShardHash {
        static instance: ::protobuf::rt::LazyV2<ShardHash> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShardHash::new)
    }
}

impl ::protobuf::Clear for ShardHash {
    fn clear(&mut self) {
        self.shard_index = 0;
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardHash {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vote {
    // message fields
    pub field_type: VoteType,
    pub height: ::protobuf::SingularPtrField<Height>,
    pub round: i64,
    pub value: ::protobuf::SingularPtrField<ShardHash>,
    pub voter: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    // .VoteType type = 1;


    pub fn get_field_type(&self) -> VoteType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = VoteType::PREVOTE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: VoteType) {
        self.field_type = v;
    }

    // .Height height = 2;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // int64 round = 3;


    pub fn get_round(&self) -> i64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i64) {
        self.round = v;
    }

    // .ShardHash value = 4;


    pub fn get_value(&self) -> &ShardHash {
        self.value.as_ref().unwrap_or_else(|| <ShardHash as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ShardHash) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ShardHash {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ShardHash {
        self.value.take().unwrap_or_else(|| ShardHash::new())
    }

    // bytes voter = 5;


    pub fn get_voter(&self) -> &[u8] {
        &self.voter
    }
    pub fn clear_voter(&mut self) {
        self.voter.clear();
    }

    // Param is passed by value, moved
    pub fn set_voter(&mut self, v: ::std::vec::Vec<u8>) {
        self.voter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voter(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.voter
    }

    // Take field
    pub fn take_voter(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.voter, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Vote {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.round = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.voter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != VoteType::PREVOTE {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(3, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.voter.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.voter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != VoteType::PREVOTE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.round != 0 {
            os.write_int64(3, self.round)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.voter.is_empty() {
            os.write_bytes(5, &self.voter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VoteType>>(
                "type",
                |m: &Vote| { &m.field_type },
                |m: &mut Vote| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &Vote| { &m.height },
                |m: &mut Vote| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "round",
                |m: &Vote| { &m.round },
                |m: &mut Vote| { &mut m.round },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShardHash>>(
                "value",
                |m: &Vote| { &m.value },
                |m: &mut Vote| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "voter",
                |m: &Vote| { &m.voter },
                |m: &mut Vote| { &mut m.voter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vote>(
                "Vote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Vote {
        static instance: ::protobuf::rt::LazyV2<Vote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vote::new)
    }
}

impl ::protobuf::Clear for Vote {
    fn clear(&mut self) {
        self.field_type = VoteType::PREVOTE;
        self.height.clear();
        self.round = 0;
        self.value.clear();
        self.voter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitSignature {
    // message fields
    pub signer: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitSignature {
    fn default() -> &'a CommitSignature {
        <CommitSignature as ::protobuf::Message>::default_instance()
    }
}

impl CommitSignature {
    pub fn new() -> CommitSignature {
        ::std::default::Default::default()
    }

    // bytes signer = 1;


    pub fn get_signer(&self) -> &[u8] {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::vec::Vec<u8>) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signer, ::std::vec::Vec::new())
    }

    // bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommitSignature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signer);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signer.is_empty() {
            os.write_bytes(1, &self.signer)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitSignature {
        CommitSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signer",
                |m: &CommitSignature| { &m.signer },
                |m: &mut CommitSignature| { &mut m.signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &CommitSignature| { &m.signature },
                |m: &mut CommitSignature| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitSignature>(
                "CommitSignature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitSignature {
        static instance: ::protobuf::rt::LazyV2<CommitSignature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitSignature::new)
    }
}

impl ::protobuf::Clear for CommitSignature {
    fn clear(&mut self) {
        self.signer.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Commits {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub round: i64,
    pub value: ::protobuf::SingularPtrField<ShardHash>,
    pub signatures: ::protobuf::RepeatedField<CommitSignature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Commits {
    fn default() -> &'a Commits {
        <Commits as ::protobuf::Message>::default_instance()
    }
}

impl Commits {
    pub fn new() -> Commits {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // int64 round = 2;


    pub fn get_round(&self) -> i64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i64) {
        self.round = v;
    }

    // .ShardHash value = 3;


    pub fn get_value(&self) -> &ShardHash {
        self.value.as_ref().unwrap_or_else(|| <ShardHash as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ShardHash) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ShardHash {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ShardHash {
        self.value.take().unwrap_or_else(|| ShardHash::new())
    }

    // repeated .CommitSignature signatures = 4;


    pub fn get_signatures(&self) -> &[CommitSignature] {
        &self.signatures
    }
    pub fn clear_signatures(&mut self) {
        self.signatures.clear();
    }

    // Param is passed by value, moved
    pub fn set_signatures(&mut self, v: ::protobuf::RepeatedField<CommitSignature>) {
        self.signatures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signatures(&mut self) -> &mut ::protobuf::RepeatedField<CommitSignature> {
        &mut self.signatures
    }

    // Take field
    pub fn take_signatures(&mut self) -> ::protobuf::RepeatedField<CommitSignature> {
        ::std::mem::replace(&mut self.signatures, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Commits {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signatures {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.round = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.signatures)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(2, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.signatures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.signatures {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Commits {
        Commits::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &Commits| { &m.height },
                |m: &mut Commits| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "round",
                |m: &Commits| { &m.round },
                |m: &mut Commits| { &mut m.round },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShardHash>>(
                "value",
                |m: &Commits| { &m.value },
                |m: &mut Commits| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommitSignature>>(
                "signatures",
                |m: &Commits| { &m.signatures },
                |m: &mut Commits| { &mut m.signatures },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Commits>(
                "Commits",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Commits {
        static instance: ::protobuf::rt::LazyV2<Commits> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Commits::new)
    }
}

impl ::protobuf::Clear for Commits {
    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.value.clear();
        self.signatures.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Commits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Commits {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Proposal {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub round: i64,
    pub pol_round: i64,
    pub proposer: ::std::vec::Vec<u8>,
    pub value: ::protobuf::SingularPtrField<ShardHash>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // int64 round = 2;


    pub fn get_round(&self) -> i64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i64) {
        self.round = v;
    }

    // int64 pol_round = 3;


    pub fn get_pol_round(&self) -> i64 {
        self.pol_round
    }
    pub fn clear_pol_round(&mut self) {
        self.pol_round = 0;
    }

    // Param is passed by value, moved
    pub fn set_pol_round(&mut self, v: i64) {
        self.pol_round = v;
    }

    // bytes proposer = 4;


    pub fn get_proposer(&self) -> &[u8] {
        &self.proposer
    }
    pub fn clear_proposer(&mut self) {
        self.proposer.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer(&mut self, v: ::std::vec::Vec<u8>) {
        self.proposer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proposer
    }

    // Take field
    pub fn take_proposer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proposer, ::std::vec::Vec::new())
    }

    // .ShardHash value = 5;


    pub fn get_value(&self) -> &ShardHash {
        self.value.as_ref().unwrap_or_else(|| <ShardHash as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ShardHash) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ShardHash {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ShardHash {
        self.value.take().unwrap_or_else(|| ShardHash::new())
    }
}

impl ::protobuf::Message for Proposal {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.round = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pol_round = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proposer)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(2, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pol_round != 0 {
            my_size += ::protobuf::rt::value_size(3, self.pol_round, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.proposer);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        if self.pol_round != 0 {
            os.write_int64(3, self.pol_round)?;
        }
        if !self.proposer.is_empty() {
            os.write_bytes(4, &self.proposer)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &Proposal| { &m.height },
                |m: &mut Proposal| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "round",
                |m: &Proposal| { &m.round },
                |m: &mut Proposal| { &mut m.round },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pol_round",
                |m: &Proposal| { &m.pol_round },
                |m: &mut Proposal| { &mut m.pol_round },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proposer",
                |m: &Proposal| { &m.proposer },
                |m: &mut Proposal| { &mut m.proposer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShardHash>>(
                "value",
                |m: &Proposal| { &m.value },
                |m: &mut Proposal| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Proposal>(
                "Proposal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Proposal {
        static instance: ::protobuf::rt::LazyV2<Proposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Proposal::new)
    }
}

impl ::protobuf::Clear for Proposal {
    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.pol_round = 0;
        self.proposer.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FullProposal {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub round: i64,
    pub proposer: ::std::vec::Vec<u8>,
    // message oneof groups
    pub proposed_value: ::std::option::Option<FullProposal_oneof_proposed_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FullProposal {
    fn default() -> &'a FullProposal {
        <FullProposal as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FullProposal_oneof_proposed_value {
    block(Block),
    shard(ShardChunk),
}

impl FullProposal {
    pub fn new() -> FullProposal {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // int64 round = 2;


    pub fn get_round(&self) -> i64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i64) {
        self.round = v;
    }

    // bytes proposer = 3;


    pub fn get_proposer(&self) -> &[u8] {
        &self.proposer
    }
    pub fn clear_proposer(&mut self) {
        self.proposer.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer(&mut self, v: ::std::vec::Vec<u8>) {
        self.proposer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proposer
    }

    // Take field
    pub fn take_proposer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proposer, ::std::vec::Vec::new())
    }

    // .Block block = 4;


    pub fn get_block(&self) -> &Block {
        match self.proposed_value {
            ::std::option::Option::Some(FullProposal_oneof_proposed_value::block(ref v)) => v,
            _ => <Block as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_block(&mut self) {
        self.proposed_value = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.proposed_value {
            ::std::option::Option::Some(FullProposal_oneof_proposed_value::block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: Block) {
        self.proposed_value = ::std::option::Option::Some(FullProposal_oneof_proposed_value::block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut Block {
        if let ::std::option::Option::Some(FullProposal_oneof_proposed_value::block(_)) = self.proposed_value {
        } else {
            self.proposed_value = ::std::option::Option::Some(FullProposal_oneof_proposed_value::block(Block::new()));
        }
        match self.proposed_value {
            ::std::option::Option::Some(FullProposal_oneof_proposed_value::block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> Block {
        if self.has_block() {
            match self.proposed_value.take() {
                ::std::option::Option::Some(FullProposal_oneof_proposed_value::block(v)) => v,
                _ => panic!(),
            }
        } else {
            Block::new()
        }
    }

    // .ShardChunk shard = 5;


    pub fn get_shard(&self) -> &ShardChunk {
        match self.proposed_value {
            ::std::option::Option::Some(FullProposal_oneof_proposed_value::shard(ref v)) => v,
            _ => <ShardChunk as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_shard(&mut self) {
        self.proposed_value = ::std::option::Option::None;
    }

    pub fn has_shard(&self) -> bool {
        match self.proposed_value {
            ::std::option::Option::Some(FullProposal_oneof_proposed_value::shard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shard(&mut self, v: ShardChunk) {
        self.proposed_value = ::std::option::Option::Some(FullProposal_oneof_proposed_value::shard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shard(&mut self) -> &mut ShardChunk {
        if let ::std::option::Option::Some(FullProposal_oneof_proposed_value::shard(_)) = self.proposed_value {
        } else {
            self.proposed_value = ::std::option::Option::Some(FullProposal_oneof_proposed_value::shard(ShardChunk::new()));
        }
        match self.proposed_value {
            ::std::option::Option::Some(FullProposal_oneof_proposed_value::shard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shard(&mut self) -> ShardChunk {
        if self.has_shard() {
            match self.proposed_value.take() {
                ::std::option::Option::Some(FullProposal_oneof_proposed_value::shard(v)) => v,
                _ => panic!(),
            }
        } else {
            ShardChunk::new()
        }
    }
}

impl ::protobuf::Message for FullProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(FullProposal_oneof_proposed_value::block(ref v)) = self.proposed_value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FullProposal_oneof_proposed_value::shard(ref v)) = self.proposed_value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.round = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proposer)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proposed_value = ::std::option::Option::Some(FullProposal_oneof_proposed_value::block(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.proposed_value = ::std::option::Option::Some(FullProposal_oneof_proposed_value::shard(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(2, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proposer);
        }
        if let ::std::option::Option::Some(ref v) = self.proposed_value {
            match v {
                &FullProposal_oneof_proposed_value::block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FullProposal_oneof_proposed_value::shard(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        if !self.proposer.is_empty() {
            os.write_bytes(3, &self.proposer)?;
        }
        if let ::std::option::Option::Some(ref v) = self.proposed_value {
            match v {
                &FullProposal_oneof_proposed_value::block(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FullProposal_oneof_proposed_value::shard(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FullProposal {
        FullProposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &FullProposal| { &m.height },
                |m: &mut FullProposal| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "round",
                |m: &FullProposal| { &m.round },
                |m: &mut FullProposal| { &mut m.round },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proposer",
                |m: &FullProposal| { &m.proposer },
                |m: &mut FullProposal| { &mut m.proposer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Block>(
                "block",
                FullProposal::has_block,
                FullProposal::get_block,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ShardChunk>(
                "shard",
                FullProposal::has_shard,
                FullProposal::get_shard,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FullProposal>(
                "FullProposal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FullProposal {
        static instance: ::protobuf::rt::LazyV2<FullProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FullProposal::new)
    }
}

impl ::protobuf::Clear for FullProposal {
    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.proposer.clear();
        self.proposed_value = ::std::option::Option::None;
        self.proposed_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FullProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FullProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecidedValue {
    // message oneof groups
    pub value: ::std::option::Option<DecidedValue_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecidedValue {
    fn default() -> &'a DecidedValue {
        <DecidedValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DecidedValue_oneof_value {
    block(Block),
    shard(ShardChunk),
}

impl DecidedValue {
    pub fn new() -> DecidedValue {
        ::std::default::Default::default()
    }

    // .Block block = 2;


    pub fn get_block(&self) -> &Block {
        match self.value {
            ::std::option::Option::Some(DecidedValue_oneof_value::block(ref v)) => v,
            _ => <Block as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_block(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(DecidedValue_oneof_value::block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: Block) {
        self.value = ::std::option::Option::Some(DecidedValue_oneof_value::block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut Block {
        if let ::std::option::Option::Some(DecidedValue_oneof_value::block(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(DecidedValue_oneof_value::block(Block::new()));
        }
        match self.value {
            ::std::option::Option::Some(DecidedValue_oneof_value::block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> Block {
        if self.has_block() {
            match self.value.take() {
                ::std::option::Option::Some(DecidedValue_oneof_value::block(v)) => v,
                _ => panic!(),
            }
        } else {
            Block::new()
        }
    }

    // .ShardChunk shard = 3;


    pub fn get_shard(&self) -> &ShardChunk {
        match self.value {
            ::std::option::Option::Some(DecidedValue_oneof_value::shard(ref v)) => v,
            _ => <ShardChunk as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_shard(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_shard(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(DecidedValue_oneof_value::shard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shard(&mut self, v: ShardChunk) {
        self.value = ::std::option::Option::Some(DecidedValue_oneof_value::shard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shard(&mut self) -> &mut ShardChunk {
        if let ::std::option::Option::Some(DecidedValue_oneof_value::shard(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(DecidedValue_oneof_value::shard(ShardChunk::new()));
        }
        match self.value {
            ::std::option::Option::Some(DecidedValue_oneof_value::shard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shard(&mut self) -> ShardChunk {
        if self.has_shard() {
            match self.value.take() {
                ::std::option::Option::Some(DecidedValue_oneof_value::shard(v)) => v,
                _ => panic!(),
            }
        } else {
            ShardChunk::new()
        }
    }
}

impl ::protobuf::Message for DecidedValue {
    fn is_initialized(&self) -> bool {
        if let Some(DecidedValue_oneof_value::block(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DecidedValue_oneof_value::shard(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(DecidedValue_oneof_value::block(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(DecidedValue_oneof_value::shard(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &DecidedValue_oneof_value::block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DecidedValue_oneof_value::shard(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &DecidedValue_oneof_value::block(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DecidedValue_oneof_value::shard(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecidedValue {
        DecidedValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Block>(
                "block",
                DecidedValue::has_block,
                DecidedValue::get_block,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ShardChunk>(
                "shard",
                DecidedValue::has_shard,
                DecidedValue::get_shard,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecidedValue>(
                "DecidedValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecidedValue {
        static instance: ::protobuf::rt::LazyV2<DecidedValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecidedValue::new)
    }
}

impl ::protobuf::Clear for DecidedValue {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecidedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecidedValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadNodeMessage {
    // message oneof groups
    pub read_node_message: ::std::option::Option<ReadNodeMessage_oneof_read_node_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadNodeMessage {
    fn default() -> &'a ReadNodeMessage {
        <ReadNodeMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ReadNodeMessage_oneof_read_node_message {
    decided_value(DecidedValue),
}

impl ReadNodeMessage {
    pub fn new() -> ReadNodeMessage {
        ::std::default::Default::default()
    }

    // .DecidedValue decided_value = 1;


    pub fn get_decided_value(&self) -> &DecidedValue {
        match self.read_node_message {
            ::std::option::Option::Some(ReadNodeMessage_oneof_read_node_message::decided_value(ref v)) => v,
            _ => <DecidedValue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_decided_value(&mut self) {
        self.read_node_message = ::std::option::Option::None;
    }

    pub fn has_decided_value(&self) -> bool {
        match self.read_node_message {
            ::std::option::Option::Some(ReadNodeMessage_oneof_read_node_message::decided_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_decided_value(&mut self, v: DecidedValue) {
        self.read_node_message = ::std::option::Option::Some(ReadNodeMessage_oneof_read_node_message::decided_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_decided_value(&mut self) -> &mut DecidedValue {
        if let ::std::option::Option::Some(ReadNodeMessage_oneof_read_node_message::decided_value(_)) = self.read_node_message {
        } else {
            self.read_node_message = ::std::option::Option::Some(ReadNodeMessage_oneof_read_node_message::decided_value(DecidedValue::new()));
        }
        match self.read_node_message {
            ::std::option::Option::Some(ReadNodeMessage_oneof_read_node_message::decided_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_decided_value(&mut self) -> DecidedValue {
        if self.has_decided_value() {
            match self.read_node_message.take() {
                ::std::option::Option::Some(ReadNodeMessage_oneof_read_node_message::decided_value(v)) => v,
                _ => panic!(),
            }
        } else {
            DecidedValue::new()
        }
    }
}

impl ::protobuf::Message for ReadNodeMessage {
    fn is_initialized(&self) -> bool {
        if let Some(ReadNodeMessage_oneof_read_node_message::decided_value(ref v)) = self.read_node_message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.read_node_message = ::std::option::Option::Some(ReadNodeMessage_oneof_read_node_message::decided_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.read_node_message {
            match v {
                &ReadNodeMessage_oneof_read_node_message::decided_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.read_node_message {
            match v {
                &ReadNodeMessage_oneof_read_node_message::decided_value(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadNodeMessage {
        ReadNodeMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DecidedValue>(
                "decided_value",
                ReadNodeMessage::has_decided_value,
                ReadNodeMessage::get_decided_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadNodeMessage>(
                "ReadNodeMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadNodeMessage {
        static instance: ::protobuf::rt::LazyV2<ReadNodeMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadNodeMessage::new)
    }
}

impl ::protobuf::Clear for ReadNodeMessage {
    fn clear(&mut self) {
        self.read_node_message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadNodeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadNodeMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConsensusMessage {
    // message fields
    pub signature: ::std::vec::Vec<u8>,
    // message oneof groups
    pub consensus_message: ::std::option::Option<ConsensusMessage_oneof_consensus_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsensusMessage {
    fn default() -> &'a ConsensusMessage {
        <ConsensusMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ConsensusMessage_oneof_consensus_message {
    vote(Vote),
    proposal(Proposal),
}

impl ConsensusMessage {
    pub fn new() -> ConsensusMessage {
        ::std::default::Default::default()
    }

    // .Vote vote = 1;


    pub fn get_vote(&self) -> &Vote {
        match self.consensus_message {
            ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::vote(ref v)) => v,
            _ => <Vote as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_vote(&mut self) {
        self.consensus_message = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        match self.consensus_message {
            ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::vote(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: Vote) {
        self.consensus_message = ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::vote(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote(&mut self) -> &mut Vote {
        if let ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::vote(_)) = self.consensus_message {
        } else {
            self.consensus_message = ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::vote(Vote::new()));
        }
        match self.consensus_message {
            ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::vote(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote(&mut self) -> Vote {
        if self.has_vote() {
            match self.consensus_message.take() {
                ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::vote(v)) => v,
                _ => panic!(),
            }
        } else {
            Vote::new()
        }
    }

    // .Proposal proposal = 2;


    pub fn get_proposal(&self) -> &Proposal {
        match self.consensus_message {
            ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::proposal(ref v)) => v,
            _ => <Proposal as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_proposal(&mut self) {
        self.consensus_message = ::std::option::Option::None;
    }

    pub fn has_proposal(&self) -> bool {
        match self.consensus_message {
            ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: Proposal) {
        self.consensus_message = ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proposal(&mut self) -> &mut Proposal {
        if let ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::proposal(_)) = self.consensus_message {
        } else {
            self.consensus_message = ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::proposal(Proposal::new()));
        }
        match self.consensus_message {
            ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::proposal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proposal(&mut self) -> Proposal {
        if self.has_proposal() {
            match self.consensus_message.take() {
                ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            Proposal::new()
        }
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ConsensusMessage {
    fn is_initialized(&self) -> bool {
        if let Some(ConsensusMessage_oneof_consensus_message::vote(ref v)) = self.consensus_message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsensusMessage_oneof_consensus_message::proposal(ref v)) = self.consensus_message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consensus_message = ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::vote(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consensus_message = ::std::option::Option::Some(ConsensusMessage_oneof_consensus_message::proposal(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if let ::std::option::Option::Some(ref v) = self.consensus_message {
            match v {
                &ConsensusMessage_oneof_consensus_message::vote(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsensusMessage_oneof_consensus_message::proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if let ::std::option::Option::Some(ref v) = self.consensus_message {
            match v {
                &ConsensusMessage_oneof_consensus_message::vote(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsensusMessage_oneof_consensus_message::proposal(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsensusMessage {
        ConsensusMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Vote>(
                "vote",
                ConsensusMessage::has_vote,
                ConsensusMessage::get_vote,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Proposal>(
                "proposal",
                ConsensusMessage::has_proposal,
                ConsensusMessage::get_proposal,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &ConsensusMessage| { &m.signature },
                |m: &mut ConsensusMessage| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsensusMessage>(
                "ConsensusMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsensusMessage {
        static instance: ::protobuf::rt::LazyV2<ConsensusMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsensusMessage::new)
    }
}

impl ::protobuf::Clear for ConsensusMessage {
    fn clear(&mut self) {
        self.consensus_message = ::std::option::Option::None;
        self.consensus_message = ::std::option::Option::None;
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsensusMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatEventBody {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeartbeatEventBody {
    fn default() -> &'a HeartbeatEventBody {
        <HeartbeatEventBody as ::protobuf::Message>::default_instance()
    }
}

impl HeartbeatEventBody {
    pub fn new() -> HeartbeatEventBody {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HeartbeatEventBody {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatEventBody {
        HeartbeatEventBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeartbeatEventBody>(
                "HeartbeatEventBody",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeartbeatEventBody {
        static instance: ::protobuf::rt::LazyV2<HeartbeatEventBody> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeartbeatEventBody::new)
    }
}

impl ::protobuf::Clear for HeartbeatEventBody {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatEventBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatEventBody {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MergeMessageEventBody {
    // message fields
    pub message: ::protobuf::SingularPtrField<super::message::Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MergeMessageEventBody {
    fn default() -> &'a MergeMessageEventBody {
        <MergeMessageEventBody as ::protobuf::Message>::default_instance()
    }
}

impl MergeMessageEventBody {
    pub fn new() -> MergeMessageEventBody {
        ::std::default::Default::default()
    }

    // .Message message = 1;


    pub fn get_message(&self) -> &super::message::Message {
        self.message.as_ref().unwrap_or_else(|| <super::message::Message as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::message::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::message::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::message::Message {
        self.message.take().unwrap_or_else(|| super::message::Message::new())
    }
}

impl ::protobuf::Message for MergeMessageEventBody {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MergeMessageEventBody {
        MergeMessageEventBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Message>>(
                "message",
                |m: &MergeMessageEventBody| { &m.message },
                |m: &mut MergeMessageEventBody| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MergeMessageEventBody>(
                "MergeMessageEventBody",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MergeMessageEventBody {
        static instance: ::protobuf::rt::LazyV2<MergeMessageEventBody> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MergeMessageEventBody::new)
    }
}

impl ::protobuf::Clear for MergeMessageEventBody {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MergeMessageEventBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MergeMessageEventBody {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockEventData {
    // message fields
    pub seqnum: u64,
    pub field_type: BlockEventType,
    pub block_number: u64,
    pub event_index: u64,
    pub block_timestamp: u64,
    // message oneof groups
    pub body: ::std::option::Option<BlockEventData_oneof_body>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockEventData {
    fn default() -> &'a BlockEventData {
        <BlockEventData as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BlockEventData_oneof_body {
    heartbeat_event_body(HeartbeatEventBody),
    merge_message_event_body(MergeMessageEventBody),
}

impl BlockEventData {
    pub fn new() -> BlockEventData {
        ::std::default::Default::default()
    }

    // uint64 seqnum = 1;


    pub fn get_seqnum(&self) -> u64 {
        self.seqnum
    }
    pub fn clear_seqnum(&mut self) {
        self.seqnum = 0;
    }

    // Param is passed by value, moved
    pub fn set_seqnum(&mut self, v: u64) {
        self.seqnum = v;
    }

    // .BlockEventType type = 2;


    pub fn get_field_type(&self) -> BlockEventType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: BlockEventType) {
        self.field_type = v;
    }

    // uint64 block_number = 3;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }

    // uint64 event_index = 4;


    pub fn get_event_index(&self) -> u64 {
        self.event_index
    }
    pub fn clear_event_index(&mut self) {
        self.event_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_index(&mut self, v: u64) {
        self.event_index = v;
    }

    // uint64 block_timestamp = 5;


    pub fn get_block_timestamp(&self) -> u64 {
        self.block_timestamp
    }
    pub fn clear_block_timestamp(&mut self) {
        self.block_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_timestamp(&mut self, v: u64) {
        self.block_timestamp = v;
    }

    // .HeartbeatEventBody heartbeat_event_body = 6;


    pub fn get_heartbeat_event_body(&self) -> &HeartbeatEventBody {
        match self.body {
            ::std::option::Option::Some(BlockEventData_oneof_body::heartbeat_event_body(ref v)) => v,
            _ => <HeartbeatEventBody as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_heartbeat_event_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_heartbeat_event_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(BlockEventData_oneof_body::heartbeat_event_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_event_body(&mut self, v: HeartbeatEventBody) {
        self.body = ::std::option::Option::Some(BlockEventData_oneof_body::heartbeat_event_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_heartbeat_event_body(&mut self) -> &mut HeartbeatEventBody {
        if let ::std::option::Option::Some(BlockEventData_oneof_body::heartbeat_event_body(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(BlockEventData_oneof_body::heartbeat_event_body(HeartbeatEventBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(BlockEventData_oneof_body::heartbeat_event_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_heartbeat_event_body(&mut self) -> HeartbeatEventBody {
        if self.has_heartbeat_event_body() {
            match self.body.take() {
                ::std::option::Option::Some(BlockEventData_oneof_body::heartbeat_event_body(v)) => v,
                _ => panic!(),
            }
        } else {
            HeartbeatEventBody::new()
        }
    }

    // .MergeMessageEventBody merge_message_event_body = 7;


    pub fn get_merge_message_event_body(&self) -> &MergeMessageEventBody {
        match self.body {
            ::std::option::Option::Some(BlockEventData_oneof_body::merge_message_event_body(ref v)) => v,
            _ => <MergeMessageEventBody as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_merge_message_event_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_merge_message_event_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(BlockEventData_oneof_body::merge_message_event_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_merge_message_event_body(&mut self, v: MergeMessageEventBody) {
        self.body = ::std::option::Option::Some(BlockEventData_oneof_body::merge_message_event_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_merge_message_event_body(&mut self) -> &mut MergeMessageEventBody {
        if let ::std::option::Option::Some(BlockEventData_oneof_body::merge_message_event_body(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(BlockEventData_oneof_body::merge_message_event_body(MergeMessageEventBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(BlockEventData_oneof_body::merge_message_event_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_merge_message_event_body(&mut self) -> MergeMessageEventBody {
        if self.has_merge_message_event_body() {
            match self.body.take() {
                ::std::option::Option::Some(BlockEventData_oneof_body::merge_message_event_body(v)) => v,
                _ => panic!(),
            }
        } else {
            MergeMessageEventBody::new()
        }
    }
}

impl ::protobuf::Message for BlockEventData {
    fn is_initialized(&self) -> bool {
        if let Some(BlockEventData_oneof_body::heartbeat_event_body(ref v)) = self.body {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlockEventData_oneof_body::merge_message_event_body(ref v)) = self.body {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seqnum = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_index = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_timestamp = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.body = ::std::option::Option::Some(BlockEventData_oneof_body::heartbeat_event_body(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.body = ::std::option::Option::Some(BlockEventData_oneof_body::merge_message_event_body(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seqnum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seqnum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.field_type != BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(3, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.event_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.event_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.block_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.body {
            match v {
                &BlockEventData_oneof_body::heartbeat_event_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlockEventData_oneof_body::merge_message_event_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.seqnum != 0 {
            os.write_uint64(1, self.seqnum)?;
        }
        if self.field_type != BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.block_number != 0 {
            os.write_uint64(3, self.block_number)?;
        }
        if self.event_index != 0 {
            os.write_uint64(4, self.event_index)?;
        }
        if self.block_timestamp != 0 {
            os.write_uint64(5, self.block_timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.body {
            match v {
                &BlockEventData_oneof_body::heartbeat_event_body(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlockEventData_oneof_body::merge_message_event_body(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockEventData {
        BlockEventData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seqnum",
                |m: &BlockEventData| { &m.seqnum },
                |m: &mut BlockEventData| { &mut m.seqnum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BlockEventType>>(
                "type",
                |m: &BlockEventData| { &m.field_type },
                |m: &mut BlockEventData| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_number",
                |m: &BlockEventData| { &m.block_number },
                |m: &mut BlockEventData| { &mut m.block_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "event_index",
                |m: &BlockEventData| { &m.event_index },
                |m: &mut BlockEventData| { &mut m.event_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_timestamp",
                |m: &BlockEventData| { &m.block_timestamp },
                |m: &mut BlockEventData| { &mut m.block_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HeartbeatEventBody>(
                "heartbeat_event_body",
                BlockEventData::has_heartbeat_event_body,
                BlockEventData::get_heartbeat_event_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MergeMessageEventBody>(
                "merge_message_event_body",
                BlockEventData::has_merge_message_event_body,
                BlockEventData::get_merge_message_event_body,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockEventData>(
                "BlockEventData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockEventData {
        static instance: ::protobuf::rt::LazyV2<BlockEventData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockEventData::new)
    }
}

impl ::protobuf::Clear for BlockEventData {
    fn clear(&mut self) {
        self.seqnum = 0;
        self.field_type = BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT;
        self.block_number = 0;
        self.event_index = 0;
        self.block_timestamp = 0;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockEventData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockEvent {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub data: ::protobuf::SingularPtrField<BlockEventData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockEvent {
    fn default() -> &'a BlockEvent {
        <BlockEvent as ::protobuf::Message>::default_instance()
    }
}

impl BlockEvent {
    pub fn new() -> BlockEvent {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // .BlockEventData data = 2;


    pub fn get_data(&self) -> &BlockEventData {
        self.data.as_ref().unwrap_or_else(|| <BlockEventData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: BlockEventData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut BlockEventData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> BlockEventData {
        self.data.take().unwrap_or_else(|| BlockEventData::new())
    }
}

impl ::protobuf::Message for BlockEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockEvent {
        BlockEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &BlockEvent| { &m.hash },
                |m: &mut BlockEvent| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockEventData>>(
                "data",
                |m: &BlockEvent| { &m.data },
                |m: &mut BlockEvent| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockEvent>(
                "BlockEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockEvent {
        static instance: ::protobuf::rt::LazyV2<BlockEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockEvent::new)
    }
}

impl ::protobuf::Clear for BlockEvent {
    fn clear(&mut self) {
        self.hash.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockHeader {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub timestamp: u64,
    pub version: u32,
    pub chain_id: super::message::FarcasterNetwork,
    pub shard_witnesses_hash: ::std::vec::Vec<u8>,
    pub parent_hash: ::std::vec::Vec<u8>,
    pub state_root: ::std::vec::Vec<u8>,
    pub events_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockHeader {
    fn default() -> &'a BlockHeader {
        <BlockHeader as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader {
    pub fn new() -> BlockHeader {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // uint32 version = 3;


    pub fn get_version(&self) -> u32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = v;
    }

    // .FarcasterNetwork chain_id = 4;


    pub fn get_chain_id(&self) -> super::message::FarcasterNetwork {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: super::message::FarcasterNetwork) {
        self.chain_id = v;
    }

    // bytes shard_witnesses_hash = 5;


    pub fn get_shard_witnesses_hash(&self) -> &[u8] {
        &self.shard_witnesses_hash
    }
    pub fn clear_shard_witnesses_hash(&mut self) {
        self.shard_witnesses_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_shard_witnesses_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.shard_witnesses_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_witnesses_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.shard_witnesses_hash
    }

    // Take field
    pub fn take_shard_witnesses_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.shard_witnesses_hash, ::std::vec::Vec::new())
    }

    // bytes parent_hash = 6;


    pub fn get_parent_hash(&self) -> &[u8] {
        &self.parent_hash
    }
    pub fn clear_parent_hash(&mut self) {
        self.parent_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parent_hash
    }

    // Take field
    pub fn take_parent_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parent_hash, ::std::vec::Vec::new())
    }

    // bytes state_root = 7;


    pub fn get_state_root(&self) -> &[u8] {
        &self.state_root
    }
    pub fn clear_state_root(&mut self) {
        self.state_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_root(&mut self, v: ::std::vec::Vec<u8>) {
        self.state_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_root(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.state_root
    }

    // Take field
    pub fn take_state_root(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.state_root, ::std::vec::Vec::new())
    }

    // bytes events_hash = 8;


    pub fn get_events_hash(&self) -> &[u8] {
        &self.events_hash
    }
    pub fn clear_events_hash(&mut self) {
        self.events_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_events_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.events_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_events_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.events_hash
    }

    // Take field
    pub fn take_events_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.events_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockHeader {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.chain_id, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.shard_witnesses_hash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parent_hash)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.state_root)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.events_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chain_id != super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE {
            my_size += ::protobuf::rt::enum_size(4, self.chain_id);
        }
        if !self.shard_witnesses_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.shard_witnesses_hash);
        }
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.parent_hash);
        }
        if !self.state_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.state_root);
        }
        if !self.events_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.events_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if self.version != 0 {
            os.write_uint32(3, self.version)?;
        }
        if self.chain_id != super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.chain_id))?;
        }
        if !self.shard_witnesses_hash.is_empty() {
            os.write_bytes(5, &self.shard_witnesses_hash)?;
        }
        if !self.parent_hash.is_empty() {
            os.write_bytes(6, &self.parent_hash)?;
        }
        if !self.state_root.is_empty() {
            os.write_bytes(7, &self.state_root)?;
        }
        if !self.events_hash.is_empty() {
            os.write_bytes(8, &self.events_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockHeader {
        BlockHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &BlockHeader| { &m.height },
                |m: &mut BlockHeader| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &BlockHeader| { &m.timestamp },
                |m: &mut BlockHeader| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &BlockHeader| { &m.version },
                |m: &mut BlockHeader| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::FarcasterNetwork>>(
                "chain_id",
                |m: &BlockHeader| { &m.chain_id },
                |m: &mut BlockHeader| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "shard_witnesses_hash",
                |m: &BlockHeader| { &m.shard_witnesses_hash },
                |m: &mut BlockHeader| { &mut m.shard_witnesses_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parent_hash",
                |m: &BlockHeader| { &m.parent_hash },
                |m: &mut BlockHeader| { &mut m.parent_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "state_root",
                |m: &BlockHeader| { &m.state_root },
                |m: &mut BlockHeader| { &mut m.state_root },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "events_hash",
                |m: &BlockHeader| { &m.events_hash },
                |m: &mut BlockHeader| { &mut m.events_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockHeader>(
                "BlockHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockHeader {
        static instance: ::protobuf::rt::LazyV2<BlockHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockHeader::new)
    }
}

impl ::protobuf::Clear for BlockHeader {
    fn clear(&mut self) {
        self.height.clear();
        self.timestamp = 0;
        self.version = 0;
        self.chain_id = super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE;
        self.shard_witnesses_hash.clear();
        self.parent_hash.clear();
        self.state_root.clear();
        self.events_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardWitness {
    // message fields
    pub shard_chunk_witnesses: ::protobuf::RepeatedField<ShardChunkWitness>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardWitness {
    fn default() -> &'a ShardWitness {
        <ShardWitness as ::protobuf::Message>::default_instance()
    }
}

impl ShardWitness {
    pub fn new() -> ShardWitness {
        ::std::default::Default::default()
    }

    // repeated .ShardChunkWitness shard_chunk_witnesses = 1;


    pub fn get_shard_chunk_witnesses(&self) -> &[ShardChunkWitness] {
        &self.shard_chunk_witnesses
    }
    pub fn clear_shard_chunk_witnesses(&mut self) {
        self.shard_chunk_witnesses.clear();
    }

    // Param is passed by value, moved
    pub fn set_shard_chunk_witnesses(&mut self, v: ::protobuf::RepeatedField<ShardChunkWitness>) {
        self.shard_chunk_witnesses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shard_chunk_witnesses(&mut self) -> &mut ::protobuf::RepeatedField<ShardChunkWitness> {
        &mut self.shard_chunk_witnesses
    }

    // Take field
    pub fn take_shard_chunk_witnesses(&mut self) -> ::protobuf::RepeatedField<ShardChunkWitness> {
        ::std::mem::replace(&mut self.shard_chunk_witnesses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ShardWitness {
    fn is_initialized(&self) -> bool {
        for v in &self.shard_chunk_witnesses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shard_chunk_witnesses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.shard_chunk_witnesses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.shard_chunk_witnesses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardWitness {
        ShardWitness::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShardChunkWitness>>(
                "shard_chunk_witnesses",
                |m: &ShardWitness| { &m.shard_chunk_witnesses },
                |m: &mut ShardWitness| { &mut m.shard_chunk_witnesses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShardWitness>(
                "ShardWitness",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShardWitness {
        static instance: ::protobuf::rt::LazyV2<ShardWitness> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShardWitness::new)
    }
}

impl ::protobuf::Clear for ShardWitness {
    fn clear(&mut self) {
        self.shard_chunk_witnesses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardWitness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardWitness {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardChunkWitness {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub shard_root: ::std::vec::Vec<u8>,
    pub shard_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardChunkWitness {
    fn default() -> &'a ShardChunkWitness {
        <ShardChunkWitness as ::protobuf::Message>::default_instance()
    }
}

impl ShardChunkWitness {
    pub fn new() -> ShardChunkWitness {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // bytes shard_root = 2;


    pub fn get_shard_root(&self) -> &[u8] {
        &self.shard_root
    }
    pub fn clear_shard_root(&mut self) {
        self.shard_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_shard_root(&mut self, v: ::std::vec::Vec<u8>) {
        self.shard_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_root(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.shard_root
    }

    // Take field
    pub fn take_shard_root(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.shard_root, ::std::vec::Vec::new())
    }

    // bytes shard_hash = 3;


    pub fn get_shard_hash(&self) -> &[u8] {
        &self.shard_hash
    }
    pub fn clear_shard_hash(&mut self) {
        self.shard_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_shard_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.shard_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.shard_hash
    }

    // Take field
    pub fn take_shard_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.shard_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ShardChunkWitness {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.shard_root)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.shard_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.shard_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.shard_root);
        }
        if !self.shard_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.shard_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.shard_root.is_empty() {
            os.write_bytes(2, &self.shard_root)?;
        }
        if !self.shard_hash.is_empty() {
            os.write_bytes(3, &self.shard_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardChunkWitness {
        ShardChunkWitness::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &ShardChunkWitness| { &m.height },
                |m: &mut ShardChunkWitness| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "shard_root",
                |m: &ShardChunkWitness| { &m.shard_root },
                |m: &mut ShardChunkWitness| { &mut m.shard_root },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "shard_hash",
                |m: &ShardChunkWitness| { &m.shard_hash },
                |m: &mut ShardChunkWitness| { &mut m.shard_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShardChunkWitness>(
                "ShardChunkWitness",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShardChunkWitness {
        static instance: ::protobuf::rt::LazyV2<ShardChunkWitness> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShardChunkWitness::new)
    }
}

impl ::protobuf::Clear for ShardChunkWitness {
    fn clear(&mut self) {
        self.height.clear();
        self.shard_root.clear();
        self.shard_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardChunkWitness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardChunkWitness {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub header: ::protobuf::SingularPtrField<BlockHeader>,
    pub hash: ::std::vec::Vec<u8>,
    pub shard_witness: ::protobuf::SingularPtrField<ShardWitness>,
    pub commits: ::protobuf::SingularPtrField<Commits>,
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    pub events: ::protobuf::RepeatedField<BlockEvent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // .BlockHeader header = 1;


    pub fn get_header(&self) -> &BlockHeader {
        self.header.as_ref().unwrap_or_else(|| <BlockHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BlockHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BlockHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BlockHeader {
        self.header.take().unwrap_or_else(|| BlockHeader::new())
    }

    // bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // .ShardWitness shard_witness = 3;


    pub fn get_shard_witness(&self) -> &ShardWitness {
        self.shard_witness.as_ref().unwrap_or_else(|| <ShardWitness as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shard_witness(&mut self) {
        self.shard_witness.clear();
    }

    pub fn has_shard_witness(&self) -> bool {
        self.shard_witness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shard_witness(&mut self, v: ShardWitness) {
        self.shard_witness = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_witness(&mut self) -> &mut ShardWitness {
        if self.shard_witness.is_none() {
            self.shard_witness.set_default();
        }
        self.shard_witness.as_mut().unwrap()
    }

    // Take field
    pub fn take_shard_witness(&mut self) -> ShardWitness {
        self.shard_witness.take().unwrap_or_else(|| ShardWitness::new())
    }

    // .Commits commits = 4;


    pub fn get_commits(&self) -> &Commits {
        self.commits.as_ref().unwrap_or_else(|| <Commits as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commits(&mut self) {
        self.commits.clear();
    }

    pub fn has_commits(&self) -> bool {
        self.commits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commits(&mut self, v: Commits) {
        self.commits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commits(&mut self) -> &mut Commits {
        if self.commits.is_none() {
            self.commits.set_default();
        }
        self.commits.as_mut().unwrap()
    }

    // Take field
    pub fn take_commits(&mut self) -> Commits {
        self.commits.take().unwrap_or_else(|| Commits::new())
    }

    // repeated .Transaction transactions = 5;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    // repeated .BlockEvent events = 6;


    pub fn get_events(&self) -> &[BlockEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<BlockEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<BlockEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<BlockEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shard_witness {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shard_witness)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commits)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if let Some(ref v) = self.shard_witness.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if let Some(ref v) = self.shard_witness.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commits.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.transactions {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.events {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockHeader>>(
                "header",
                |m: &Block| { &m.header },
                |m: &mut Block| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &Block| { &m.hash },
                |m: &mut Block| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShardWitness>>(
                "shard_witness",
                |m: &Block| { &m.shard_witness },
                |m: &mut Block| { &mut m.shard_witness },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Commits>>(
                "commits",
                |m: &Block| { &m.commits },
                |m: &mut Block| { &mut m.commits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                "transactions",
                |m: &Block| { &m.transactions },
                |m: &mut Block| { &mut m.transactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockEvent>>(
                "events",
                |m: &Block| { &m.events },
                |m: &mut Block| { &mut m.events },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Block>(
                "Block",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Block {
        static instance: ::protobuf::rt::LazyV2<Block> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Block::new)
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.header.clear();
        self.hash.clear();
        self.shard_witness.clear();
        self.commits.clear();
        self.transactions.clear();
        self.events.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardHeader {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub timestamp: u64,
    pub parent_hash: ::std::vec::Vec<u8>,
    pub shard_root: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardHeader {
    fn default() -> &'a ShardHeader {
        <ShardHeader as ::protobuf::Message>::default_instance()
    }
}

impl ShardHeader {
    pub fn new() -> ShardHeader {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // bytes parent_hash = 3;


    pub fn get_parent_hash(&self) -> &[u8] {
        &self.parent_hash
    }
    pub fn clear_parent_hash(&mut self) {
        self.parent_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parent_hash
    }

    // Take field
    pub fn take_parent_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parent_hash, ::std::vec::Vec::new())
    }

    // bytes shard_root = 4;


    pub fn get_shard_root(&self) -> &[u8] {
        &self.shard_root
    }
    pub fn clear_shard_root(&mut self) {
        self.shard_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_shard_root(&mut self, v: ::std::vec::Vec<u8>) {
        self.shard_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_root(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.shard_root
    }

    // Take field
    pub fn take_shard_root(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.shard_root, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ShardHeader {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parent_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.shard_root)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.parent_hash);
        }
        if !self.shard_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.shard_root);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if !self.parent_hash.is_empty() {
            os.write_bytes(3, &self.parent_hash)?;
        }
        if !self.shard_root.is_empty() {
            os.write_bytes(4, &self.shard_root)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardHeader {
        ShardHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &ShardHeader| { &m.height },
                |m: &mut ShardHeader| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &ShardHeader| { &m.timestamp },
                |m: &mut ShardHeader| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parent_hash",
                |m: &ShardHeader| { &m.parent_hash },
                |m: &mut ShardHeader| { &mut m.parent_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "shard_root",
                |m: &ShardHeader| { &m.shard_root },
                |m: &mut ShardHeader| { &mut m.shard_root },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShardHeader>(
                "ShardHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShardHeader {
        static instance: ::protobuf::rt::LazyV2<ShardHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShardHeader::new)
    }
}

impl ::protobuf::Clear for ShardHeader {
    fn clear(&mut self) {
        self.height.clear();
        self.timestamp = 0;
        self.parent_hash.clear();
        self.shard_root.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardChunk {
    // message fields
    pub header: ::protobuf::SingularPtrField<ShardHeader>,
    pub hash: ::std::vec::Vec<u8>,
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    pub commits: ::protobuf::SingularPtrField<Commits>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardChunk {
    fn default() -> &'a ShardChunk {
        <ShardChunk as ::protobuf::Message>::default_instance()
    }
}

impl ShardChunk {
    pub fn new() -> ShardChunk {
        ::std::default::Default::default()
    }

    // .ShardHeader header = 1;


    pub fn get_header(&self) -> &ShardHeader {
        self.header.as_ref().unwrap_or_else(|| <ShardHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ShardHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ShardHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ShardHeader {
        self.header.take().unwrap_or_else(|| ShardHeader::new())
    }

    // bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // repeated .Transaction transactions = 3;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    // .Commits commits = 4;


    pub fn get_commits(&self) -> &Commits {
        self.commits.as_ref().unwrap_or_else(|| <Commits as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commits(&mut self) {
        self.commits.clear();
    }

    pub fn has_commits(&self) -> bool {
        self.commits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commits(&mut self, v: Commits) {
        self.commits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commits(&mut self) -> &mut Commits {
        if self.commits.is_none() {
            self.commits.set_default();
        }
        self.commits.as_mut().unwrap()
    }

    // Take field
    pub fn take_commits(&mut self) -> Commits {
        self.commits.take().unwrap_or_else(|| Commits::new())
    }
}

impl ::protobuf::Message for ShardChunk {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.commits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        for v in &self.transactions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.commits.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardChunk {
        ShardChunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShardHeader>>(
                "header",
                |m: &ShardChunk| { &m.header },
                |m: &mut ShardChunk| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &ShardChunk| { &m.hash },
                |m: &mut ShardChunk| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                "transactions",
                |m: &ShardChunk| { &m.transactions },
                |m: &mut ShardChunk| { &mut m.transactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Commits>>(
                "commits",
                |m: &ShardChunk| { &m.commits },
                |m: &mut ShardChunk| { &mut m.commits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShardChunk>(
                "ShardChunk",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShardChunk {
        static instance: ::protobuf::rt::LazyV2<ShardChunk> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShardChunk::new)
    }
}

impl ::protobuf::Clear for ShardChunk {
    fn clear(&mut self) {
        self.header.clear();
        self.hash.clear();
        self.transactions.clear();
        self.commits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardChunk {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub fid: u64,
    pub user_messages: ::protobuf::RepeatedField<super::message::Message>,
    pub system_messages: ::protobuf::RepeatedField<ValidatorMessage>,
    pub account_root: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // repeated .Message user_messages = 2;


    pub fn get_user_messages(&self) -> &[super::message::Message] {
        &self.user_messages
    }
    pub fn clear_user_messages(&mut self) {
        self.user_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_messages(&mut self, v: ::protobuf::RepeatedField<super::message::Message>) {
        self.user_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_messages(&mut self) -> &mut ::protobuf::RepeatedField<super::message::Message> {
        &mut self.user_messages
    }

    // Take field
    pub fn take_user_messages(&mut self) -> ::protobuf::RepeatedField<super::message::Message> {
        ::std::mem::replace(&mut self.user_messages, ::protobuf::RepeatedField::new())
    }

    // repeated .ValidatorMessage system_messages = 3;


    pub fn get_system_messages(&self) -> &[ValidatorMessage] {
        &self.system_messages
    }
    pub fn clear_system_messages(&mut self) {
        self.system_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_system_messages(&mut self, v: ::protobuf::RepeatedField<ValidatorMessage>) {
        self.system_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_system_messages(&mut self) -> &mut ::protobuf::RepeatedField<ValidatorMessage> {
        &mut self.system_messages
    }

    // Take field
    pub fn take_system_messages(&mut self) -> ::protobuf::RepeatedField<ValidatorMessage> {
        ::std::mem::replace(&mut self.system_messages, ::protobuf::RepeatedField::new())
    }

    // bytes account_root = 4;


    pub fn get_account_root(&self) -> &[u8] {
        &self.account_root
    }
    pub fn clear_account_root(&mut self) {
        self.account_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_root(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_root(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_root
    }

    // Take field
    pub fn take_account_root(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_root, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.user_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.user_messages)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.system_messages)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_root)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.system_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.account_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.account_root);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        for v in &self.user_messages {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.system_messages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.account_root.is_empty() {
            os.write_bytes(4, &self.account_root)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &Transaction| { &m.fid },
                |m: &mut Transaction| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Message>>(
                "user_messages",
                |m: &Transaction| { &m.user_messages },
                |m: &mut Transaction| { &mut m.user_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValidatorMessage>>(
                "system_messages",
                |m: &Transaction| { &m.system_messages },
                |m: &mut Transaction| { &mut m.system_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "account_root",
                |m: &Transaction| { &m.account_root },
                |m: &mut Transaction| { &mut m.account_root },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction>(
                "Transaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction {
        static instance: ::protobuf::rt::LazyV2<Transaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction::new)
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.fid = 0;
        self.user_messages.clear();
        self.system_messages.clear();
        self.account_root.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FnameTransfer {
    // message fields
    pub id: u64,
    pub from_fid: u64,
    pub proof: ::protobuf::SingularPtrField<super::username_proof::UserNameProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FnameTransfer {
    fn default() -> &'a FnameTransfer {
        <FnameTransfer as ::protobuf::Message>::default_instance()
    }
}

impl FnameTransfer {
    pub fn new() -> FnameTransfer {
        ::std::default::Default::default()
    }

    // uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // uint64 from_fid = 2;


    pub fn get_from_fid(&self) -> u64 {
        self.from_fid
    }
    pub fn clear_from_fid(&mut self) {
        self.from_fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_fid(&mut self, v: u64) {
        self.from_fid = v;
    }

    // .UserNameProof proof = 4;


    pub fn get_proof(&self) -> &super::username_proof::UserNameProof {
        self.proof.as_ref().unwrap_or_else(|| <super::username_proof::UserNameProof as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof(&mut self) {
        self.proof.clear();
    }

    pub fn has_proof(&self) -> bool {
        self.proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof(&mut self, v: super::username_proof::UserNameProof) {
        self.proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof(&mut self) -> &mut super::username_proof::UserNameProof {
        if self.proof.is_none() {
            self.proof.set_default();
        }
        self.proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof(&mut self) -> super::username_proof::UserNameProof {
        self.proof.take().unwrap_or_else(|| super::username_proof::UserNameProof::new())
    }
}

impl ::protobuf::Message for FnameTransfer {
    fn is_initialized(&self) -> bool {
        for v in &self.proof {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.from_fid = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.from_fid != 0 {
            my_size += ::protobuf::rt::value_size(2, self.from_fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.from_fid != 0 {
            os.write_uint64(2, self.from_fid)?;
        }
        if let Some(ref v) = self.proof.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FnameTransfer {
        FnameTransfer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &FnameTransfer| { &m.id },
                |m: &mut FnameTransfer| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "from_fid",
                |m: &FnameTransfer| { &m.from_fid },
                |m: &mut FnameTransfer| { &mut m.from_fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::username_proof::UserNameProof>>(
                "proof",
                |m: &FnameTransfer| { &m.proof },
                |m: &mut FnameTransfer| { &mut m.proof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FnameTransfer>(
                "FnameTransfer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FnameTransfer {
        static instance: ::protobuf::rt::LazyV2<FnameTransfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FnameTransfer::new)
    }
}

impl ::protobuf::Clear for FnameTransfer {
    fn clear(&mut self) {
        self.id = 0;
        self.from_fid = 0;
        self.proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FnameTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FnameTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidatorMessage {
    // message fields
    pub on_chain_event: ::protobuf::SingularPtrField<super::onchain_event::OnChainEvent>,
    pub fname_transfer: ::protobuf::SingularPtrField<FnameTransfer>,
    pub block_event: ::protobuf::SingularPtrField<BlockEvent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorMessage {
    fn default() -> &'a ValidatorMessage {
        <ValidatorMessage as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorMessage {
    pub fn new() -> ValidatorMessage {
        ::std::default::Default::default()
    }

    // .OnChainEvent on_chain_event = 1;


    pub fn get_on_chain_event(&self) -> &super::onchain_event::OnChainEvent {
        self.on_chain_event.as_ref().unwrap_or_else(|| <super::onchain_event::OnChainEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_on_chain_event(&mut self) {
        self.on_chain_event.clear();
    }

    pub fn has_on_chain_event(&self) -> bool {
        self.on_chain_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_on_chain_event(&mut self, v: super::onchain_event::OnChainEvent) {
        self.on_chain_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_on_chain_event(&mut self) -> &mut super::onchain_event::OnChainEvent {
        if self.on_chain_event.is_none() {
            self.on_chain_event.set_default();
        }
        self.on_chain_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_on_chain_event(&mut self) -> super::onchain_event::OnChainEvent {
        self.on_chain_event.take().unwrap_or_else(|| super::onchain_event::OnChainEvent::new())
    }

    // .FnameTransfer fname_transfer = 2;


    pub fn get_fname_transfer(&self) -> &FnameTransfer {
        self.fname_transfer.as_ref().unwrap_or_else(|| <FnameTransfer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fname_transfer(&mut self) {
        self.fname_transfer.clear();
    }

    pub fn has_fname_transfer(&self) -> bool {
        self.fname_transfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fname_transfer(&mut self, v: FnameTransfer) {
        self.fname_transfer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fname_transfer(&mut self) -> &mut FnameTransfer {
        if self.fname_transfer.is_none() {
            self.fname_transfer.set_default();
        }
        self.fname_transfer.as_mut().unwrap()
    }

    // Take field
    pub fn take_fname_transfer(&mut self) -> FnameTransfer {
        self.fname_transfer.take().unwrap_or_else(|| FnameTransfer::new())
    }

    // .BlockEvent block_event = 3;


    pub fn get_block_event(&self) -> &BlockEvent {
        self.block_event.as_ref().unwrap_or_else(|| <BlockEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block_event(&mut self) {
        self.block_event.clear();
    }

    pub fn has_block_event(&self) -> bool {
        self.block_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_event(&mut self, v: BlockEvent) {
        self.block_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_event(&mut self) -> &mut BlockEvent {
        if self.block_event.is_none() {
            self.block_event.set_default();
        }
        self.block_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_event(&mut self) -> BlockEvent {
        self.block_event.take().unwrap_or_else(|| BlockEvent::new())
    }
}

impl ::protobuf::Message for ValidatorMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.on_chain_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fname_transfer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block_event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.on_chain_event)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fname_transfer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block_event)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.on_chain_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fname_transfer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.block_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.on_chain_event.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fname_transfer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.block_event.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorMessage {
        ValidatorMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::onchain_event::OnChainEvent>>(
                "on_chain_event",
                |m: &ValidatorMessage| { &m.on_chain_event },
                |m: &mut ValidatorMessage| { &mut m.on_chain_event },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FnameTransfer>>(
                "fname_transfer",
                |m: &ValidatorMessage| { &m.fname_transfer },
                |m: &mut ValidatorMessage| { &mut m.fname_transfer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockEvent>>(
                "block_event",
                |m: &ValidatorMessage| { &m.block_event },
                |m: &mut ValidatorMessage| { &mut m.block_event },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidatorMessage>(
                "ValidatorMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidatorMessage {
        static instance: ::protobuf::rt::LazyV2<ValidatorMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorMessage::new)
    }
}

impl ::protobuf::Clear for ValidatorMessage {
    fn clear(&mut self) {
        self.on_chain_event.clear();
        self.fname_transfer.clear();
        self.block_event.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidatorMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MempoolMessage {
    // message oneof groups
    pub mempool_message: ::std::option::Option<MempoolMessage_oneof_mempool_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MempoolMessage {
    fn default() -> &'a MempoolMessage {
        <MempoolMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MempoolMessage_oneof_mempool_message {
    user_message(super::message::Message),
}

impl MempoolMessage {
    pub fn new() -> MempoolMessage {
        ::std::default::Default::default()
    }

    // .Message user_message = 1;


    pub fn get_user_message(&self) -> &super::message::Message {
        match self.mempool_message {
            ::std::option::Option::Some(MempoolMessage_oneof_mempool_message::user_message(ref v)) => v,
            _ => <super::message::Message as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_user_message(&mut self) {
        self.mempool_message = ::std::option::Option::None;
    }

    pub fn has_user_message(&self) -> bool {
        match self.mempool_message {
            ::std::option::Option::Some(MempoolMessage_oneof_mempool_message::user_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_message(&mut self, v: super::message::Message) {
        self.mempool_message = ::std::option::Option::Some(MempoolMessage_oneof_mempool_message::user_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_message(&mut self) -> &mut super::message::Message {
        if let ::std::option::Option::Some(MempoolMessage_oneof_mempool_message::user_message(_)) = self.mempool_message {
        } else {
            self.mempool_message = ::std::option::Option::Some(MempoolMessage_oneof_mempool_message::user_message(super::message::Message::new()));
        }
        match self.mempool_message {
            ::std::option::Option::Some(MempoolMessage_oneof_mempool_message::user_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_message(&mut self) -> super::message::Message {
        if self.has_user_message() {
            match self.mempool_message.take() {
                ::std::option::Option::Some(MempoolMessage_oneof_mempool_message::user_message(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::Message::new()
        }
    }
}

impl ::protobuf::Message for MempoolMessage {
    fn is_initialized(&self) -> bool {
        if let Some(MempoolMessage_oneof_mempool_message::user_message(ref v)) = self.mempool_message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mempool_message = ::std::option::Option::Some(MempoolMessage_oneof_mempool_message::user_message(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mempool_message {
            match v {
                &MempoolMessage_oneof_mempool_message::user_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.mempool_message {
            match v {
                &MempoolMessage_oneof_mempool_message::user_message(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MempoolMessage {
        MempoolMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::message::Message>(
                "user_message",
                MempoolMessage::has_user_message,
                MempoolMessage::get_user_message,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MempoolMessage>(
                "MempoolMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MempoolMessage {
        static instance: ::protobuf::rt::LazyV2<MempoolMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MempoolMessage::new)
    }
}

impl ::protobuf::Clear for MempoolMessage {
    fn clear(&mut self) {
        self.mempool_message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MempoolMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MempoolMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusMessage {
    // message fields
    pub peer_id: ::std::vec::Vec<u8>,
    pub height: ::protobuf::SingularPtrField<Height>,
    pub min_height: ::protobuf::SingularPtrField<Height>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusMessage {
    fn default() -> &'a StatusMessage {
        <StatusMessage as ::protobuf::Message>::default_instance()
    }
}

impl StatusMessage {
    pub fn new() -> StatusMessage {
        ::std::default::Default::default()
    }

    // bytes peer_id = 1;


    pub fn get_peer_id(&self) -> &[u8] {
        &self.peer_id
    }
    pub fn clear_peer_id(&mut self) {
        self.peer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.peer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.peer_id
    }

    // Take field
    pub fn take_peer_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.peer_id, ::std::vec::Vec::new())
    }

    // .Height height = 2;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // .Height min_height = 3;


    pub fn get_min_height(&self) -> &Height {
        self.min_height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_min_height(&mut self) {
        self.min_height.clear();
    }

    pub fn has_min_height(&self) -> bool {
        self.min_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_height(&mut self, v: Height) {
        self.min_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_height(&mut self) -> &mut Height {
        if self.min_height.is_none() {
            self.min_height.set_default();
        }
        self.min_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_min_height(&mut self) -> Height {
        self.min_height.take().unwrap_or_else(|| Height::new())
    }
}

impl ::protobuf::Message for StatusMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.min_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.peer_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.min_height)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.peer_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.peer_id);
        }
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.min_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.peer_id.is_empty() {
            os.write_bytes(1, &self.peer_id)?;
        }
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.min_height.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusMessage {
        StatusMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "peer_id",
                |m: &StatusMessage| { &m.peer_id },
                |m: &mut StatusMessage| { &mut m.peer_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &StatusMessage| { &m.height },
                |m: &mut StatusMessage| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "min_height",
                |m: &StatusMessage| { &m.min_height },
                |m: &mut StatusMessage| { &mut m.min_height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusMessage>(
                "StatusMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusMessage {
        static instance: ::protobuf::rt::LazyV2<StatusMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusMessage::new)
    }
}

impl ::protobuf::Clear for StatusMessage {
    fn clear(&mut self) {
        self.peer_id.clear();
        self.height.clear();
        self.min_height.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncValueRequest {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncValueRequest {
    fn default() -> &'a SyncValueRequest {
        <SyncValueRequest as ::protobuf::Message>::default_instance()
    }
}

impl SyncValueRequest {
    pub fn new() -> SyncValueRequest {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }
}

impl ::protobuf::Message for SyncValueRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncValueRequest {
        SyncValueRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &SyncValueRequest| { &m.height },
                |m: &mut SyncValueRequest| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncValueRequest>(
                "SyncValueRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncValueRequest {
        static instance: ::protobuf::rt::LazyV2<SyncValueRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncValueRequest::new)
    }
}

impl ::protobuf::Clear for SyncValueRequest {
    fn clear(&mut self) {
        self.height.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncValueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncValueRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncVoteSetRequest {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub round: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncVoteSetRequest {
    fn default() -> &'a SyncVoteSetRequest {
        <SyncVoteSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl SyncVoteSetRequest {
    pub fn new() -> SyncVoteSetRequest {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // int64 round = 2;


    pub fn get_round(&self) -> i64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i64) {
        self.round = v;
    }
}

impl ::protobuf::Message for SyncVoteSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.round = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(2, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncVoteSetRequest {
        SyncVoteSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &SyncVoteSetRequest| { &m.height },
                |m: &mut SyncVoteSetRequest| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "round",
                |m: &SyncVoteSetRequest| { &m.round },
                |m: &mut SyncVoteSetRequest| { &mut m.round },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncVoteSetRequest>(
                "SyncVoteSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncVoteSetRequest {
        static instance: ::protobuf::rt::LazyV2<SyncVoteSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncVoteSetRequest::new)
    }
}

impl ::protobuf::Clear for SyncVoteSetRequest {
    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncVoteSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncVoteSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncRequest {
    // message oneof groups
    pub sync_request: ::std::option::Option<SyncRequest_oneof_sync_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncRequest {
    fn default() -> &'a SyncRequest {
        <SyncRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SyncRequest_oneof_sync_request {
    value(SyncValueRequest),
    vote_set(SyncVoteSetRequest),
}

impl SyncRequest {
    pub fn new() -> SyncRequest {
        ::std::default::Default::default()
    }

    // .SyncValueRequest value = 1;


    pub fn get_value(&self) -> &SyncValueRequest {
        match self.sync_request {
            ::std::option::Option::Some(SyncRequest_oneof_sync_request::value(ref v)) => v,
            _ => <SyncValueRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_value(&mut self) {
        self.sync_request = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        match self.sync_request {
            ::std::option::Option::Some(SyncRequest_oneof_sync_request::value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SyncValueRequest) {
        self.sync_request = ::std::option::Option::Some(SyncRequest_oneof_sync_request::value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut SyncValueRequest {
        if let ::std::option::Option::Some(SyncRequest_oneof_sync_request::value(_)) = self.sync_request {
        } else {
            self.sync_request = ::std::option::Option::Some(SyncRequest_oneof_sync_request::value(SyncValueRequest::new()));
        }
        match self.sync_request {
            ::std::option::Option::Some(SyncRequest_oneof_sync_request::value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value(&mut self) -> SyncValueRequest {
        if self.has_value() {
            match self.sync_request.take() {
                ::std::option::Option::Some(SyncRequest_oneof_sync_request::value(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncValueRequest::new()
        }
    }

    // .SyncVoteSetRequest vote_set = 2;


    pub fn get_vote_set(&self) -> &SyncVoteSetRequest {
        match self.sync_request {
            ::std::option::Option::Some(SyncRequest_oneof_sync_request::vote_set(ref v)) => v,
            _ => <SyncVoteSetRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_vote_set(&mut self) {
        self.sync_request = ::std::option::Option::None;
    }

    pub fn has_vote_set(&self) -> bool {
        match self.sync_request {
            ::std::option::Option::Some(SyncRequest_oneof_sync_request::vote_set(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote_set(&mut self, v: SyncVoteSetRequest) {
        self.sync_request = ::std::option::Option::Some(SyncRequest_oneof_sync_request::vote_set(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote_set(&mut self) -> &mut SyncVoteSetRequest {
        if let ::std::option::Option::Some(SyncRequest_oneof_sync_request::vote_set(_)) = self.sync_request {
        } else {
            self.sync_request = ::std::option::Option::Some(SyncRequest_oneof_sync_request::vote_set(SyncVoteSetRequest::new()));
        }
        match self.sync_request {
            ::std::option::Option::Some(SyncRequest_oneof_sync_request::vote_set(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote_set(&mut self) -> SyncVoteSetRequest {
        if self.has_vote_set() {
            match self.sync_request.take() {
                ::std::option::Option::Some(SyncRequest_oneof_sync_request::vote_set(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncVoteSetRequest::new()
        }
    }
}

impl ::protobuf::Message for SyncRequest {
    fn is_initialized(&self) -> bool {
        if let Some(SyncRequest_oneof_sync_request::value(ref v)) = self.sync_request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SyncRequest_oneof_sync_request::vote_set(ref v)) = self.sync_request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sync_request = ::std::option::Option::Some(SyncRequest_oneof_sync_request::value(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sync_request = ::std::option::Option::Some(SyncRequest_oneof_sync_request::vote_set(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.sync_request {
            match v {
                &SyncRequest_oneof_sync_request::value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SyncRequest_oneof_sync_request::vote_set(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.sync_request {
            match v {
                &SyncRequest_oneof_sync_request::value(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SyncRequest_oneof_sync_request::vote_set(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncRequest {
        SyncRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SyncValueRequest>(
                "value",
                SyncRequest::has_value,
                SyncRequest::get_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SyncVoteSetRequest>(
                "vote_set",
                SyncRequest::has_vote_set,
                SyncRequest::get_vote_set,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncRequest>(
                "SyncRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncRequest {
        static instance: ::protobuf::rt::LazyV2<SyncRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncRequest::new)
    }
}

impl ::protobuf::Clear for SyncRequest {
    fn clear(&mut self) {
        self.sync_request = ::std::option::Option::None;
        self.sync_request = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncValueResponse {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub full_value: ::std::vec::Vec<u8>,
    pub commits: ::protobuf::SingularPtrField<Commits>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncValueResponse {
    fn default() -> &'a SyncValueResponse {
        <SyncValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl SyncValueResponse {
    pub fn new() -> SyncValueResponse {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // bytes full_value = 2;


    pub fn get_full_value(&self) -> &[u8] {
        &self.full_value
    }
    pub fn clear_full_value(&mut self) {
        self.full_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_full_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.full_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.full_value
    }

    // Take field
    pub fn take_full_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.full_value, ::std::vec::Vec::new())
    }

    // .Commits commits = 3;


    pub fn get_commits(&self) -> &Commits {
        self.commits.as_ref().unwrap_or_else(|| <Commits as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commits(&mut self) {
        self.commits.clear();
    }

    pub fn has_commits(&self) -> bool {
        self.commits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commits(&mut self, v: Commits) {
        self.commits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commits(&mut self) -> &mut Commits {
        if self.commits.is_none() {
            self.commits.set_default();
        }
        self.commits.as_mut().unwrap()
    }

    // Take field
    pub fn take_commits(&mut self) -> Commits {
        self.commits.take().unwrap_or_else(|| Commits::new())
    }
}

impl ::protobuf::Message for SyncValueResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.full_value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.full_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.full_value);
        }
        if let Some(ref v) = self.commits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.full_value.is_empty() {
            os.write_bytes(2, &self.full_value)?;
        }
        if let Some(ref v) = self.commits.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncValueResponse {
        SyncValueResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &SyncValueResponse| { &m.height },
                |m: &mut SyncValueResponse| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "full_value",
                |m: &SyncValueResponse| { &m.full_value },
                |m: &mut SyncValueResponse| { &mut m.full_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Commits>>(
                "commits",
                |m: &SyncValueResponse| { &m.commits },
                |m: &mut SyncValueResponse| { &mut m.commits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncValueResponse>(
                "SyncValueResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncValueResponse {
        static instance: ::protobuf::rt::LazyV2<SyncValueResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncValueResponse::new)
    }
}

impl ::protobuf::Clear for SyncValueResponse {
    fn clear(&mut self) {
        self.height.clear();
        self.full_value.clear();
        self.commits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncValueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncVoteSetResponse {
    // message fields
    pub height: ::protobuf::SingularPtrField<Height>,
    pub round: i64,
    pub votes: ::protobuf::RepeatedField<Vote>,
    pub signatures: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncVoteSetResponse {
    fn default() -> &'a SyncVoteSetResponse {
        <SyncVoteSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl SyncVoteSetResponse {
    pub fn new() -> SyncVoteSetResponse {
        ::std::default::Default::default()
    }

    // .Height height = 1;


    pub fn get_height(&self) -> &Height {
        self.height.as_ref().unwrap_or_else(|| <Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height(&mut self) {
        self.height.clear();
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: Height) {
        self.height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height(&mut self) -> &mut Height {
        if self.height.is_none() {
            self.height.set_default();
        }
        self.height.as_mut().unwrap()
    }

    // Take field
    pub fn take_height(&mut self) -> Height {
        self.height.take().unwrap_or_else(|| Height::new())
    }

    // int64 round = 2;


    pub fn get_round(&self) -> i64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i64) {
        self.round = v;
    }

    // repeated .Vote votes = 3;


    pub fn get_votes(&self) -> &[Vote] {
        &self.votes
    }
    pub fn clear_votes(&mut self) {
        self.votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_votes(&mut self, v: ::protobuf::RepeatedField<Vote>) {
        self.votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_votes(&mut self) -> &mut ::protobuf::RepeatedField<Vote> {
        &mut self.votes
    }

    // Take field
    pub fn take_votes(&mut self) -> ::protobuf::RepeatedField<Vote> {
        ::std::mem::replace(&mut self.votes, ::protobuf::RepeatedField::new())
    }

    // repeated bytes signatures = 4;


    pub fn get_signatures(&self) -> &[::std::vec::Vec<u8>] {
        &self.signatures
    }
    pub fn clear_signatures(&mut self) {
        self.signatures.clear();
    }

    // Param is passed by value, moved
    pub fn set_signatures(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.signatures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signatures(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.signatures
    }

    // Take field
    pub fn take_signatures(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.signatures, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SyncVoteSetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.height {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.round = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.votes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.signatures)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(2, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.signatures {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        for v in &self.votes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.signatures {
            os.write_bytes(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncVoteSetResponse {
        SyncVoteSetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Height>>(
                "height",
                |m: &SyncVoteSetResponse| { &m.height },
                |m: &mut SyncVoteSetResponse| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "round",
                |m: &SyncVoteSetResponse| { &m.round },
                |m: &mut SyncVoteSetResponse| { &mut m.round },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vote>>(
                "votes",
                |m: &SyncVoteSetResponse| { &m.votes },
                |m: &mut SyncVoteSetResponse| { &mut m.votes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signatures",
                |m: &SyncVoteSetResponse| { &m.signatures },
                |m: &mut SyncVoteSetResponse| { &mut m.signatures },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncVoteSetResponse>(
                "SyncVoteSetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncVoteSetResponse {
        static instance: ::protobuf::rt::LazyV2<SyncVoteSetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncVoteSetResponse::new)
    }
}

impl ::protobuf::Clear for SyncVoteSetResponse {
    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.votes.clear();
        self.signatures.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncVoteSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncVoteSetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncResponse {
    // message oneof groups
    pub sync_response: ::std::option::Option<SyncResponse_oneof_sync_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncResponse {
    fn default() -> &'a SyncResponse {
        <SyncResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SyncResponse_oneof_sync_response {
    value(SyncValueResponse),
    vote_set(SyncVoteSetResponse),
}

impl SyncResponse {
    pub fn new() -> SyncResponse {
        ::std::default::Default::default()
    }

    // .SyncValueResponse value = 1;


    pub fn get_value(&self) -> &SyncValueResponse {
        match self.sync_response {
            ::std::option::Option::Some(SyncResponse_oneof_sync_response::value(ref v)) => v,
            _ => <SyncValueResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_value(&mut self) {
        self.sync_response = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        match self.sync_response {
            ::std::option::Option::Some(SyncResponse_oneof_sync_response::value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SyncValueResponse) {
        self.sync_response = ::std::option::Option::Some(SyncResponse_oneof_sync_response::value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut SyncValueResponse {
        if let ::std::option::Option::Some(SyncResponse_oneof_sync_response::value(_)) = self.sync_response {
        } else {
            self.sync_response = ::std::option::Option::Some(SyncResponse_oneof_sync_response::value(SyncValueResponse::new()));
        }
        match self.sync_response {
            ::std::option::Option::Some(SyncResponse_oneof_sync_response::value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value(&mut self) -> SyncValueResponse {
        if self.has_value() {
            match self.sync_response.take() {
                ::std::option::Option::Some(SyncResponse_oneof_sync_response::value(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncValueResponse::new()
        }
    }

    // .SyncVoteSetResponse vote_set = 2;


    pub fn get_vote_set(&self) -> &SyncVoteSetResponse {
        match self.sync_response {
            ::std::option::Option::Some(SyncResponse_oneof_sync_response::vote_set(ref v)) => v,
            _ => <SyncVoteSetResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_vote_set(&mut self) {
        self.sync_response = ::std::option::Option::None;
    }

    pub fn has_vote_set(&self) -> bool {
        match self.sync_response {
            ::std::option::Option::Some(SyncResponse_oneof_sync_response::vote_set(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote_set(&mut self, v: SyncVoteSetResponse) {
        self.sync_response = ::std::option::Option::Some(SyncResponse_oneof_sync_response::vote_set(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote_set(&mut self) -> &mut SyncVoteSetResponse {
        if let ::std::option::Option::Some(SyncResponse_oneof_sync_response::vote_set(_)) = self.sync_response {
        } else {
            self.sync_response = ::std::option::Option::Some(SyncResponse_oneof_sync_response::vote_set(SyncVoteSetResponse::new()));
        }
        match self.sync_response {
            ::std::option::Option::Some(SyncResponse_oneof_sync_response::vote_set(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote_set(&mut self) -> SyncVoteSetResponse {
        if self.has_vote_set() {
            match self.sync_response.take() {
                ::std::option::Option::Some(SyncResponse_oneof_sync_response::vote_set(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncVoteSetResponse::new()
        }
    }
}

impl ::protobuf::Message for SyncResponse {
    fn is_initialized(&self) -> bool {
        if let Some(SyncResponse_oneof_sync_response::value(ref v)) = self.sync_response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SyncResponse_oneof_sync_response::vote_set(ref v)) = self.sync_response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sync_response = ::std::option::Option::Some(SyncResponse_oneof_sync_response::value(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sync_response = ::std::option::Option::Some(SyncResponse_oneof_sync_response::vote_set(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.sync_response {
            match v {
                &SyncResponse_oneof_sync_response::value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SyncResponse_oneof_sync_response::vote_set(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.sync_response {
            match v {
                &SyncResponse_oneof_sync_response::value(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SyncResponse_oneof_sync_response::vote_set(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncResponse {
        SyncResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SyncValueResponse>(
                "value",
                SyncResponse::has_value,
                SyncResponse::get_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SyncVoteSetResponse>(
                "vote_set",
                SyncResponse::has_vote_set,
                SyncResponse::get_vote_set,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncResponse>(
                "SyncResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncResponse {
        static instance: ::protobuf::rt::LazyV2<SyncResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncResponse::new)
    }
}

impl ::protobuf::Clear for SyncResponse {
    fn clear(&mut self) {
        self.sync_response = ::std::option::Option::None;
        self.sync_response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VoteType {
    PREVOTE = 0,
    PRECOMMIT = 1,
}

impl ::protobuf::ProtobufEnum for VoteType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoteType> {
        match value {
            0 => ::std::option::Option::Some(VoteType::PREVOTE),
            1 => ::std::option::Option::Some(VoteType::PRECOMMIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VoteType] = &[
            VoteType::PREVOTE,
            VoteType::PRECOMMIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<VoteType>("VoteType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for VoteType {
}

impl ::std::default::Default for VoteType {
    fn default() -> Self {
        VoteType::PREVOTE
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BlockEventType {
    BLOCK_EVENT_TYPE_HEARTBEAT = 0,
    BLOCK_EVENT_TYPE_MERGE_MESSAGE = 1,
}

impl ::protobuf::ProtobufEnum for BlockEventType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockEventType> {
        match value {
            0 => ::std::option::Option::Some(BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT),
            1 => ::std::option::Option::Some(BlockEventType::BLOCK_EVENT_TYPE_MERGE_MESSAGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlockEventType] = &[
            BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT,
            BlockEventType::BLOCK_EVENT_TYPE_MERGE_MESSAGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BlockEventType>("BlockEventType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BlockEventType {
}

impl ::std::default::Default for BlockEventType {
    fn default() -> Self {
        BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockEventType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cblocks.proto\x1a\rmessage.proto\x1a\x14username_proof.proto\x1a\
    \x13onchain_event.proto\"\xaa\x01\n\tValidator\x12\x12\n\x03fid\x18\x01\
    \x20\x01(\x04R\x03fidB\0\x12\x18\n\x06signer\x18\x02\x20\x01(\x0cR\x06si\
    gnerB\0\x12!\n\x0brpc_address\x18\x03\x20\x01(\tR\nrpcAddressB\0\x12!\n\
    \x0bshard_index\x18\x04\x20\x01(\rR\nshardIndexB\0\x12'\n\x0ecurrent_hei\
    ght\x18\x05\x20\x01(\x04R\rcurrentHeightB\0:\0\">\n\x0cValidatorSet\x12,\
    \n\nvalidators\x18\x01\x20\x03(\x0b2\n.ValidatorR\nvalidatorsB\0:\0\"R\n\
    \x06Height\x12!\n\x0bshard_index\x18\x01\x20\x01(\rR\nshardIndexB\0\x12#\
    \n\x0cblock_number\x18\x02\x20\x01(\x04R\x0bblockNumberB\0:\0\"F\n\tShar\
    dHash\x12!\n\x0bshard_index\x18\x01\x20\x01(\rR\nshardIndexB\0\x12\x14\n\
    \x04hash\x18\x02\x20\x01(\x0cR\x04hashB\0:\0\"\xa0\x01\n\x04Vote\x12\x1f\
    \n\x04type\x18\x01\x20\x01(\x0e2\t.VoteTypeR\x04typeB\0\x12!\n\x06height\
    \x18\x02\x20\x01(\x0b2\x07.HeightR\x06heightB\0\x12\x16\n\x05round\x18\
    \x03\x20\x01(\x03R\x05roundB\0\x12\"\n\x05value\x18\x04\x20\x01(\x0b2\n.\
    ShardHashR\x05valueB\0\x12\x16\n\x05voter\x18\x05\x20\x01(\x0cR\x05voter\
    B\0:\0\"M\n\x0fCommitSignature\x12\x18\n\x06signer\x18\x01\x20\x01(\x0cR\
    \x06signerB\0\x12\x1e\n\tsignature\x18\x02\x20\x01(\x0cR\tsignatureB\0:\
    \0\"\x9e\x01\n\x07Commits\x12!\n\x06height\x18\x01\x20\x01(\x0b2\x07.Hei\
    ghtR\x06heightB\0\x12\x16\n\x05round\x18\x02\x20\x01(\x03R\x05roundB\0\
    \x12\"\n\x05value\x18\x03\x20\x01(\x0b2\n.ShardHashR\x05valueB\0\x122\n\
    \nsignatures\x18\x04\x20\x03(\x0b2\x10.CommitSignatureR\nsignaturesB\0:\
    \0\"\xa8\x01\n\x08Proposal\x12!\n\x06height\x18\x01\x20\x01(\x0b2\x07.He\
    ightR\x06heightB\0\x12\x16\n\x05round\x18\x02\x20\x01(\x03R\x05roundB\0\
    \x12\x1d\n\tpol_round\x18\x03\x20\x01(\x03R\x08polRoundB\0\x12\x1c\n\x08\
    proposer\x18\x04\x20\x01(\x0cR\x08proposerB\0\x12\"\n\x05value\x18\x05\
    \x20\x01(\x0b2\n.ShardHashR\x05valueB\0:\0\"\xc4\x01\n\x0cFullProposal\
    \x12!\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06heightB\0\x12\x16\
    \n\x05round\x18\x02\x20\x01(\x03R\x05roundB\0\x12\x1c\n\x08proposer\x18\
    \x03\x20\x01(\x0cR\x08proposerB\0\x12\x20\n\x05block\x18\x04\x20\x01(\
    \x0b2\x06.BlockH\0R\x05blockB\0\x12%\n\x05shard\x18\x05\x20\x01(\x0b2\
    \x0b.ShardChunkH\0R\x05shardB\0B\x10\n\x0eproposed_value:\0\"b\n\x0cDeci\
    dedValue\x12\x20\n\x05block\x18\x02\x20\x01(\x0b2\x06.BlockH\0R\x05block\
    B\0\x12%\n\x05shard\x18\x03\x20\x01(\x0b2\x0b.ShardChunkH\0R\x05shardB\0\
    B\x07\n\x05value:\0\"`\n\x0fReadNodeMessage\x126\n\rdecided_value\x18\
    \x01\x20\x01(\x0b2\r.DecidedValueH\0R\x0cdecidedValueB\0B\x13\n\x11read_\
    node_message:\0\"\x93\x01\n\x10ConsensusMessage\x12\x1d\n\x04vote\x18\
    \x01\x20\x01(\x0b2\x05.VoteH\0R\x04voteB\0\x12)\n\x08proposal\x18\x02\
    \x20\x01(\x0b2\t.ProposalH\0R\x08proposalB\0\x12\x1e\n\tsignature\x18\
    \x03\x20\x01(\x0cR\tsignatureB\0B\x13\n\x11consensus_message:\0\"\x16\n\
    \x12HeartbeatEventBody:\0\"?\n\x15MergeMessageEventBody\x12$\n\x07messag\
    e\x18\x01\x20\x01(\x0b2\x08.MessageR\x07messageB\0:\0\"\xee\x02\n\x0eBlo\
    ckEventData\x12\x18\n\x06seqnum\x18\x01\x20\x01(\x04R\x06seqnumB\0\x12%\
    \n\x04type\x18\x02\x20\x01(\x0e2\x0f.BlockEventTypeR\x04typeB\0\x12#\n\
    \x0cblock_number\x18\x03\x20\x01(\x04R\x0bblockNumberB\0\x12!\n\x0bevent\
    _index\x18\x04\x20\x01(\x04R\neventIndexB\0\x12)\n\x0fblock_timestamp\
    \x18\x05\x20\x01(\x04R\x0eblockTimestampB\0\x12I\n\x14heartbeat_event_bo\
    dy\x18\x06\x20\x01(\x0b2\x13.HeartbeatEventBodyH\0R\x12heartbeatEventBod\
    yB\0\x12S\n\x18merge_message_event_body\x18\x07\x20\x01(\x0b2\x16.MergeM\
    essageEventBodyH\0R\x15mergeMessageEventBodyB\0B\x06\n\x04body:\0\"K\n\n\
    BlockEvent\x12\x14\n\x04hash\x18\x01\x20\x01(\x0cR\x04hashB\0\x12%\n\x04\
    data\x18\x02\x20\x01(\x0b2\x0f.BlockEventDataR\x04dataB\0:\0\"\xb9\x02\n\
    \x0bBlockHeader\x12!\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06he\
    ightB\0\x12\x1e\n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestampB\0\x12\x1a\
    \n\x07version\x18\x03\x20\x01(\rR\x07versionB\0\x12.\n\x08chain_id\x18\
    \x04\x20\x01(\x0e2\x11.FarcasterNetworkR\x07chainIdB\0\x122\n\x14shard_w\
    itnesses_hash\x18\x05\x20\x01(\x0cR\x12shardWitnessesHashB\0\x12!\n\x0bp\
    arent_hash\x18\x06\x20\x01(\x0cR\nparentHashB\0\x12\x1f\n\nstate_root\
    \x18\x07\x20\x01(\x0cR\tstateRootB\0\x12!\n\x0bevents_hash\x18\x08\x20\
    \x01(\x0cR\neventsHashB\0:\0\"Z\n\x0cShardWitness\x12H\n\x15shard_chunk_\
    witnesses\x18\x01\x20\x03(\x0b2\x12.ShardChunkWitnessR\x13shardChunkWitn\
    essesB\0:\0\"z\n\x11ShardChunkWitness\x12!\n\x06height\x18\x01\x20\x01(\
    \x0b2\x07.HeightR\x06heightB\0\x12\x1f\n\nshard_root\x18\x02\x20\x01(\
    \x0cR\tshardRootB\0\x12\x1f\n\nshard_hash\x18\x03\x20\x01(\x0cR\tshardHa\
    shB\0:\0\"\xfe\x01\n\x05Block\x12&\n\x06header\x18\x01\x20\x01(\x0b2\x0c\
    .BlockHeaderR\x06headerB\0\x12\x14\n\x04hash\x18\x02\x20\x01(\x0cR\x04ha\
    shB\0\x124\n\rshard_witness\x18\x03\x20\x01(\x0b2\r.ShardWitnessR\x0csha\
    rdWitnessB\0\x12$\n\x07commits\x18\x04\x20\x01(\x0b2\x08.CommitsR\x07com\
    mitsB\0\x122\n\x0ctransactions\x18\x05\x20\x03(\x0b2\x0c.TransactionR\
    \x0ctransactionsB\0\x12%\n\x06events\x18\x06\x20\x03(\x0b2\x0b.BlockEven\
    tR\x06eventsB\0:\0\"\x96\x01\n\x0bShardHeader\x12!\n\x06height\x18\x01\
    \x20\x01(\x0b2\x07.HeightR\x06heightB\0\x12\x1e\n\ttimestamp\x18\x02\x20\
    \x01(\x04R\ttimestampB\0\x12!\n\x0bparent_hash\x18\x03\x20\x01(\x0cR\npa\
    rentHashB\0\x12\x1f\n\nshard_root\x18\x04\x20\x01(\x0cR\tshardRootB\0:\0\
    \"\xa6\x01\n\nShardChunk\x12&\n\x06header\x18\x01\x20\x01(\x0b2\x0c.Shar\
    dHeaderR\x06headerB\0\x12\x14\n\x04hash\x18\x02\x20\x01(\x0cR\x04hashB\0\
    \x122\n\x0ctransactions\x18\x03\x20\x03(\x0b2\x0c.TransactionR\x0ctransa\
    ctionsB\0\x12$\n\x07commits\x18\x04\x20\x01(\x0b2\x08.CommitsR\x07commit\
    sB\0:\0\"\xb7\x01\n\x0bTransaction\x12\x12\n\x03fid\x18\x01\x20\x01(\x04\
    R\x03fidB\0\x12/\n\ruser_messages\x18\x02\x20\x03(\x0b2\x08.MessageR\x0c\
    userMessagesB\0\x12<\n\x0fsystem_messages\x18\x03\x20\x03(\x0b2\x11.Vali\
    datorMessageR\x0esystemMessagesB\0\x12#\n\x0caccount_root\x18\x04\x20\
    \x01(\x0cR\x0baccountRootB\0:\0\"h\n\rFnameTransfer\x12\x10\n\x02id\x18\
    \x01\x20\x01(\x04R\x02idB\0\x12\x1b\n\x08from_fid\x18\x02\x20\x01(\x04R\
    \x07fromFidB\0\x12&\n\x05proof\x18\x04\x20\x01(\x0b2\x0e.UserNameProofR\
    \x05proofB\0:\0\"\xb4\x01\n\x10ValidatorMessage\x125\n\x0eon_chain_event\
    \x18\x01\x20\x01(\x0b2\r.OnChainEventR\x0conChainEventB\0\x127\n\x0efnam\
    e_transfer\x18\x02\x20\x01(\x0b2\x0e.FnameTransferR\rfnameTransferB\0\
    \x12.\n\x0bblock_event\x18\x03\x20\x01(\x0b2\x0b.BlockEventR\nblockEvent\
    B\0:\0\"V\n\x0eMempoolMessage\x12/\n\x0cuser_message\x18\x01\x20\x01(\
    \x0b2\x08.MessageH\0R\x0buserMessageB\0B\x11\n\x0fmempool_message:\0\"y\
    \n\rStatusMessage\x12\x19\n\x07peer_id\x18\x01\x20\x01(\x0cR\x06peerIdB\
    \0\x12!\n\x06height\x18\x02\x20\x01(\x0b2\x07.HeightR\x06heightB\0\x12(\
    \n\nmin_height\x18\x03\x20\x01(\x0b2\x07.HeightR\tminHeightB\0:\0\"7\n\
    \x10SyncValueRequest\x12!\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\
    \x06heightB\0:\0\"Q\n\x12SyncVoteSetRequest\x12!\n\x06height\x18\x01\x20\
    \x01(\x0b2\x07.HeightR\x06heightB\0\x12\x16\n\x05round\x18\x02\x20\x01(\
    \x03R\x05roundB\0:\0\"\x80\x01\n\x0bSyncRequest\x12+\n\x05value\x18\x01\
    \x20\x01(\x0b2\x11.SyncValueRequestH\0R\x05valueB\0\x122\n\x08vote_set\
    \x18\x02\x20\x01(\x0b2\x13.SyncVoteSetRequestH\0R\x07voteSetB\0B\x0e\n\
    \x0csync_request:\0\"\x7f\n\x11SyncValueResponse\x12!\n\x06height\x18\
    \x01\x20\x01(\x0b2\x07.HeightR\x06heightB\0\x12\x1f\n\nfull_value\x18\
    \x02\x20\x01(\x0cR\tfullValueB\0\x12$\n\x07commits\x18\x03\x20\x01(\x0b2\
    \x08.CommitsR\x07commitsB\0:\0\"\x93\x01\n\x13SyncVoteSetResponse\x12!\n\
    \x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06heightB\0\x12\x16\n\x05r\
    ound\x18\x02\x20\x01(\x03R\x05roundB\0\x12\x1d\n\x05votes\x18\x03\x20\
    \x03(\x0b2\x05.VoteR\x05votesB\0\x12\x20\n\nsignatures\x18\x04\x20\x03(\
    \x0cR\nsignaturesB\0:\0\"\x84\x01\n\x0cSyncResponse\x12,\n\x05value\x18\
    \x01\x20\x01(\x0b2\x12.SyncValueResponseH\0R\x05valueB\0\x123\n\x08vote_\
    set\x18\x02\x20\x01(\x0b2\x14.SyncVoteSetResponseH\0R\x07voteSetB\0B\x0f\
    \n\rsync_response:\0*(\n\x08VoteType\x12\x0b\n\x07PREVOTE\x10\0\x12\r\n\
    \tPRECOMMIT\x10\x01\x1a\0*V\n\x0eBlockEventType\x12\x1e\n\x1aBLOCK_EVENT\
    _TYPE_HEARTBEAT\x10\0\x12\"\n\x1eBLOCK_EVENT_TYPE_MERGE_MESSAGE\x10\x01\
    \x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
