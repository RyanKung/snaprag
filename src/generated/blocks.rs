#![allow(clippy::all)]
#![allow(clippy::pedantic)]
#![allow(clippy::nursery)]
#![allow(unused_lifetimes)]
#![allow(elided_lifetimes_in_paths)]
#![allow(unused_parens)]
#![allow(unknown_lints)]
#![allow(renamed_and_removed_lints)]
#![allow(warnings)]

// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `blocks.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:Validator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Validator {
    // message fields
    // @@protoc_insertion_point(field:Validator.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:Validator.signer)
    pub signer: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:Validator.rpc_address)
    pub rpc_address: ::std::string::String,
    // @@protoc_insertion_point(field:Validator.shard_index)
    pub shard_index: u32,
    // @@protoc_insertion_point(field:Validator.current_height)
    pub current_height: u64,
    // special fields
    // @@protoc_insertion_point(special_field:Validator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Validator| { &m.fid },
            |m: &mut Validator| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &Validator| { &m.signer },
            |m: &mut Validator| { &mut m.signer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rpc_address",
            |m: &Validator| { &m.rpc_address },
            |m: &mut Validator| { &mut m.rpc_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_index",
            |m: &Validator| { &m.shard_index },
            |m: &mut Validator| { &mut m.shard_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_height",
            |m: &Validator| { &m.current_height },
            |m: &mut Validator| { &mut m.current_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Validator>(
            "Validator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Validator {
    const NAME: &'static str = "Validator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.signer = is.read_bytes()?;
                },
                26 => {
                    self.rpc_address = is.read_string()?;
                },
                32 => {
                    self.shard_index = is.read_uint32()?;
                },
                40 => {
                    self.current_height = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signer);
        }
        if !self.rpc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.rpc_address);
        }
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.shard_index);
        }
        if self.current_height != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.current_height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.signer.is_empty() {
            os.write_bytes(2, &self.signer)?;
        }
        if !self.rpc_address.is_empty() {
            os.write_string(3, &self.rpc_address)?;
        }
        if self.shard_index != 0 {
            os.write_uint32(4, self.shard_index)?;
        }
        if self.current_height != 0 {
            os.write_uint64(5, self.current_height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.signer.clear();
        self.rpc_address.clear();
        self.shard_index = 0;
        self.current_height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Validator {
        static instance: Validator = Validator {
            fid: 0,
            signer: ::std::vec::Vec::new(),
            rpc_address: ::std::string::String::new(),
            shard_index: 0,
            current_height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Validator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Validator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ValidatorSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatorSet {
    // message fields
    // @@protoc_insertion_point(field:ValidatorSet.validators)
    pub validators: ::std::vec::Vec<Validator>,
    // special fields
    // @@protoc_insertion_point(special_field:ValidatorSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorSet {
    fn default() -> &'a ValidatorSet {
        <ValidatorSet as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorSet {
    pub fn new() -> ValidatorSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validators",
            |m: &ValidatorSet| { &m.validators },
            |m: &mut ValidatorSet| { &mut m.validators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorSet>(
            "ValidatorSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorSet {
    const NAME: &'static str = "ValidatorSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validators.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.validators {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorSet {
        ValidatorSet::new()
    }

    fn clear(&mut self) {
        self.validators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorSet {
        static instance: ValidatorSet = ValidatorSet {
            validators: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Height)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Height {
    // message fields
    // @@protoc_insertion_point(field:Height.shard_index)
    pub shard_index: u32,
    // @@protoc_insertion_point(field:Height.block_number)
    pub block_number: u64,
    // special fields
    // @@protoc_insertion_point(special_field:Height.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Height {
    fn default() -> &'a Height {
        <Height as ::protobuf::Message>::default_instance()
    }
}

impl Height {
    pub fn new() -> Height {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_index",
            |m: &Height| { &m.shard_index },
            |m: &mut Height| { &mut m.shard_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_number",
            |m: &Height| { &m.block_number },
            |m: &mut Height| { &mut m.block_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Height>(
            "Height",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Height {
    const NAME: &'static str = "Height";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_index = is.read_uint32()?;
                },
                16 => {
                    self.block_number = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_index);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.block_number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_index != 0 {
            os.write_uint32(1, self.shard_index)?;
        }
        if self.block_number != 0 {
            os.write_uint64(2, self.block_number)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Height {
        Height::new()
    }

    fn clear(&mut self) {
        self.shard_index = 0;
        self.block_number = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Height {
        static instance: Height = Height {
            shard_index: 0,
            block_number: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Height {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Height").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Height {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Height {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardHash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardHash {
    // message fields
    // @@protoc_insertion_point(field:ShardHash.shard_index)
    pub shard_index: u32,
    // @@protoc_insertion_point(field:ShardHash.hash)
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardHash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardHash {
    fn default() -> &'a ShardHash {
        <ShardHash as ::protobuf::Message>::default_instance()
    }
}

impl ShardHash {
    pub fn new() -> ShardHash {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_index",
            |m: &ShardHash| { &m.shard_index },
            |m: &mut ShardHash| { &mut m.shard_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &ShardHash| { &m.hash },
            |m: &mut ShardHash| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardHash>(
            "ShardHash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardHash {
    const NAME: &'static str = "ShardHash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_index = is.read_uint32()?;
                },
                18 => {
                    self.hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_index);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_index != 0 {
            os.write_uint32(1, self.shard_index)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardHash {
        ShardHash::new()
    }

    fn clear(&mut self) {
        self.shard_index = 0;
        self.hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardHash {
        static instance: ShardHash = ShardHash {
            shard_index: 0,
            hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardHash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardHash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardHash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Vote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Vote {
    // message fields
    // @@protoc_insertion_point(field:Vote.type)
    pub type_: ::protobuf::EnumOrUnknown<VoteType>,
    // @@protoc_insertion_point(field:Vote.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:Vote.round)
    pub round: i64,
    // @@protoc_insertion_point(field:Vote.value)
    pub value: ::protobuf::MessageField<ShardHash>,
    // @@protoc_insertion_point(field:Vote.voter)
    pub voter: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:Vote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Vote| { &m.type_ },
            |m: &mut Vote| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &Vote| { &m.height },
            |m: &mut Vote| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &Vote| { &m.round },
            |m: &mut Vote| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ShardHash>(
            "value",
            |m: &Vote| { &m.value },
            |m: &mut Vote| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "voter",
            |m: &Vote| { &m.voter },
            |m: &mut Vote| { &mut m.voter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vote>(
            "Vote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vote {
    const NAME: &'static str = "Vote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                24 => {
                    self.round = is.read_int64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                42 => {
                    self.voter = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(VoteType::PREVOTE) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.round);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.voter.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.voter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(VoteType::PREVOTE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.round != 0 {
            os.write_int64(3, self.round)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.voter.is_empty() {
            os.write_bytes(5, &self.voter)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(VoteType::PREVOTE);
        self.height.clear();
        self.round = 0;
        self.value.clear();
        self.voter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vote {
        static instance: Vote = Vote {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            height: ::protobuf::MessageField::none(),
            round: 0,
            value: ::protobuf::MessageField::none(),
            voter: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CommitSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommitSignature {
    // message fields
    // @@protoc_insertion_point(field:CommitSignature.signer)
    pub signer: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:CommitSignature.signature)
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:CommitSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommitSignature {
    fn default() -> &'a CommitSignature {
        <CommitSignature as ::protobuf::Message>::default_instance()
    }
}

impl CommitSignature {
    pub fn new() -> CommitSignature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &CommitSignature| { &m.signer },
            |m: &mut CommitSignature| { &mut m.signer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &CommitSignature| { &m.signature },
            |m: &mut CommitSignature| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommitSignature>(
            "CommitSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommitSignature {
    const NAME: &'static str = "CommitSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.signer = is.read_bytes()?;
                },
                18 => {
                    self.signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signer);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.signer.is_empty() {
            os.write_bytes(1, &self.signer)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommitSignature {
        CommitSignature::new()
    }

    fn clear(&mut self) {
        self.signer.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommitSignature {
        static instance: CommitSignature = CommitSignature {
            signer: ::std::vec::Vec::new(),
            signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommitSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommitSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommitSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Commits)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Commits {
    // message fields
    // @@protoc_insertion_point(field:Commits.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:Commits.round)
    pub round: i64,
    // @@protoc_insertion_point(field:Commits.value)
    pub value: ::protobuf::MessageField<ShardHash>,
    // @@protoc_insertion_point(field:Commits.signatures)
    pub signatures: ::std::vec::Vec<CommitSignature>,
    // special fields
    // @@protoc_insertion_point(special_field:Commits.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Commits {
    fn default() -> &'a Commits {
        <Commits as ::protobuf::Message>::default_instance()
    }
}

impl Commits {
    pub fn new() -> Commits {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &Commits| { &m.height },
            |m: &mut Commits| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &Commits| { &m.round },
            |m: &mut Commits| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ShardHash>(
            "value",
            |m: &Commits| { &m.value },
            |m: &mut Commits| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &Commits| { &m.signatures },
            |m: &mut Commits| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Commits>(
            "Commits",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Commits {
    const NAME: &'static str = "Commits";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                16 => {
                    self.round = is.read_int64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                34 => {
                    self.signatures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.round);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.signatures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.signatures {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Commits {
        Commits::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.value.clear();
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Commits {
        static instance: Commits = Commits {
            height: ::protobuf::MessageField::none(),
            round: 0,
            value: ::protobuf::MessageField::none(),
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Commits {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Commits").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Commits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Commits {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Proposal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Proposal {
    // message fields
    // @@protoc_insertion_point(field:Proposal.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:Proposal.round)
    pub round: i64,
    // @@protoc_insertion_point(field:Proposal.pol_round)
    pub pol_round: i64,
    // @@protoc_insertion_point(field:Proposal.proposer)
    pub proposer: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:Proposal.value)
    pub value: ::protobuf::MessageField<ShardHash>,
    // special fields
    // @@protoc_insertion_point(special_field:Proposal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &Proposal| { &m.height },
            |m: &mut Proposal| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &Proposal| { &m.round },
            |m: &mut Proposal| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pol_round",
            |m: &Proposal| { &m.pol_round },
            |m: &mut Proposal| { &mut m.pol_round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposer",
            |m: &Proposal| { &m.proposer },
            |m: &mut Proposal| { &mut m.proposer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ShardHash>(
            "value",
            |m: &Proposal| { &m.value },
            |m: &mut Proposal| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Proposal>(
            "Proposal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Proposal {
    const NAME: &'static str = "Proposal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                16 => {
                    self.round = is.read_int64()?;
                },
                24 => {
                    self.pol_round = is.read_int64()?;
                },
                34 => {
                    self.proposer = is.read_bytes()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.round);
        }
        if self.pol_round != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.pol_round);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.proposer);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        if self.pol_round != 0 {
            os.write_int64(3, self.pol_round)?;
        }
        if !self.proposer.is_empty() {
            os.write_bytes(4, &self.proposer)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.pol_round = 0;
        self.proposer.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Proposal {
        static instance: Proposal = Proposal {
            height: ::protobuf::MessageField::none(),
            round: 0,
            pol_round: 0,
            proposer: ::std::vec::Vec::new(),
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Proposal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Proposal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FullProposal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FullProposal {
    // message fields
    // @@protoc_insertion_point(field:FullProposal.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:FullProposal.round)
    pub round: i64,
    // @@protoc_insertion_point(field:FullProposal.proposer)
    pub proposer: ::std::vec::Vec<u8>,
    // message oneof groups
    pub proposed_value: ::std::option::Option<full_proposal::Proposed_value>,
    // special fields
    // @@protoc_insertion_point(special_field:FullProposal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FullProposal {
    fn default() -> &'a FullProposal {
        <FullProposal as ::protobuf::Message>::default_instance()
    }
}

impl FullProposal {
    pub fn new() -> FullProposal {
        ::std::default::Default::default()
    }

    // .Block block = 4;

    pub fn block(&self) -> &Block {
        match self.proposed_value {
            ::std::option::Option::Some(full_proposal::Proposed_value::Block(ref v)) => v,
            _ => <Block as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block(&mut self) {
        self.proposed_value = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.proposed_value {
            ::std::option::Option::Some(full_proposal::Proposed_value::Block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: Block) {
        self.proposed_value = ::std::option::Option::Some(full_proposal::Proposed_value::Block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut Block {
        if let ::std::option::Option::Some(full_proposal::Proposed_value::Block(_)) = self.proposed_value {
        } else {
            self.proposed_value = ::std::option::Option::Some(full_proposal::Proposed_value::Block(Block::new()));
        }
        match self.proposed_value {
            ::std::option::Option::Some(full_proposal::Proposed_value::Block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> Block {
        if self.has_block() {
            match self.proposed_value.take() {
                ::std::option::Option::Some(full_proposal::Proposed_value::Block(v)) => v,
                _ => panic!(),
            }
        } else {
            Block::new()
        }
    }

    // .ShardChunk shard = 5;

    pub fn shard(&self) -> &ShardChunk {
        match self.proposed_value {
            ::std::option::Option::Some(full_proposal::Proposed_value::Shard(ref v)) => v,
            _ => <ShardChunk as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_shard(&mut self) {
        self.proposed_value = ::std::option::Option::None;
    }

    pub fn has_shard(&self) -> bool {
        match self.proposed_value {
            ::std::option::Option::Some(full_proposal::Proposed_value::Shard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shard(&mut self, v: ShardChunk) {
        self.proposed_value = ::std::option::Option::Some(full_proposal::Proposed_value::Shard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shard(&mut self) -> &mut ShardChunk {
        if let ::std::option::Option::Some(full_proposal::Proposed_value::Shard(_)) = self.proposed_value {
        } else {
            self.proposed_value = ::std::option::Option::Some(full_proposal::Proposed_value::Shard(ShardChunk::new()));
        }
        match self.proposed_value {
            ::std::option::Option::Some(full_proposal::Proposed_value::Shard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shard(&mut self) -> ShardChunk {
        if self.has_shard() {
            match self.proposed_value.take() {
                ::std::option::Option::Some(full_proposal::Proposed_value::Shard(v)) => v,
                _ => panic!(),
            }
        } else {
            ShardChunk::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &FullProposal| { &m.height },
            |m: &mut FullProposal| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &FullProposal| { &m.round },
            |m: &mut FullProposal| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposer",
            |m: &FullProposal| { &m.proposer },
            |m: &mut FullProposal| { &mut m.proposer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Block>(
            "block",
            FullProposal::has_block,
            FullProposal::block,
            FullProposal::mut_block,
            FullProposal::set_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ShardChunk>(
            "shard",
            FullProposal::has_shard,
            FullProposal::shard,
            FullProposal::mut_shard,
            FullProposal::set_shard,
        ));
        oneofs.push(full_proposal::Proposed_value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FullProposal>(
            "FullProposal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FullProposal {
    const NAME: &'static str = "FullProposal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                16 => {
                    self.round = is.read_int64()?;
                },
                26 => {
                    self.proposer = is.read_bytes()?;
                },
                34 => {
                    self.proposed_value = ::std::option::Option::Some(full_proposal::Proposed_value::Block(is.read_message()?));
                },
                42 => {
                    self.proposed_value = ::std::option::Option::Some(full_proposal::Proposed_value::Shard(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.round);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proposer);
        }
        if let ::std::option::Option::Some(ref v) = self.proposed_value {
            match v {
                &full_proposal::Proposed_value::Block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &full_proposal::Proposed_value::Shard(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        if !self.proposer.is_empty() {
            os.write_bytes(3, &self.proposer)?;
        }
        if let ::std::option::Option::Some(ref v) = self.proposed_value {
            match v {
                &full_proposal::Proposed_value::Block(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &full_proposal::Proposed_value::Shard(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FullProposal {
        FullProposal::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.proposer.clear();
        self.proposed_value = ::std::option::Option::None;
        self.proposed_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FullProposal {
        static instance: FullProposal = FullProposal {
            height: ::protobuf::MessageField::none(),
            round: 0,
            proposer: ::std::vec::Vec::new(),
            proposed_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FullProposal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FullProposal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FullProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FullProposal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FullProposal`
pub mod full_proposal {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:FullProposal.proposed_value)
    pub enum Proposed_value {
        // @@protoc_insertion_point(oneof_field:FullProposal.block)
        Block(super::Block),
        // @@protoc_insertion_point(oneof_field:FullProposal.shard)
        Shard(super::ShardChunk),
    }

    impl ::protobuf::Oneof for Proposed_value {
    }

    impl ::protobuf::OneofFull for Proposed_value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FullProposal as ::protobuf::MessageFull>::descriptor().oneof_by_name("proposed_value").unwrap()).clone()
        }
    }

    impl Proposed_value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Proposed_value>("proposed_value")
        }
    }
}

// @@protoc_insertion_point(message:DecidedValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DecidedValue {
    // message oneof groups
    pub value: ::std::option::Option<decided_value::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:DecidedValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DecidedValue {
    fn default() -> &'a DecidedValue {
        <DecidedValue as ::protobuf::Message>::default_instance()
    }
}

impl DecidedValue {
    pub fn new() -> DecidedValue {
        ::std::default::Default::default()
    }

    // .Block block = 2;

    pub fn block(&self) -> &Block {
        match self.value {
            ::std::option::Option::Some(decided_value::Value::Block(ref v)) => v,
            _ => <Block as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(decided_value::Value::Block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: Block) {
        self.value = ::std::option::Option::Some(decided_value::Value::Block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut Block {
        if let ::std::option::Option::Some(decided_value::Value::Block(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(decided_value::Value::Block(Block::new()));
        }
        match self.value {
            ::std::option::Option::Some(decided_value::Value::Block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> Block {
        if self.has_block() {
            match self.value.take() {
                ::std::option::Option::Some(decided_value::Value::Block(v)) => v,
                _ => panic!(),
            }
        } else {
            Block::new()
        }
    }

    // .ShardChunk shard = 3;

    pub fn shard(&self) -> &ShardChunk {
        match self.value {
            ::std::option::Option::Some(decided_value::Value::Shard(ref v)) => v,
            _ => <ShardChunk as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_shard(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_shard(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(decided_value::Value::Shard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shard(&mut self, v: ShardChunk) {
        self.value = ::std::option::Option::Some(decided_value::Value::Shard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shard(&mut self) -> &mut ShardChunk {
        if let ::std::option::Option::Some(decided_value::Value::Shard(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(decided_value::Value::Shard(ShardChunk::new()));
        }
        match self.value {
            ::std::option::Option::Some(decided_value::Value::Shard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shard(&mut self) -> ShardChunk {
        if self.has_shard() {
            match self.value.take() {
                ::std::option::Option::Some(decided_value::Value::Shard(v)) => v,
                _ => panic!(),
            }
        } else {
            ShardChunk::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Block>(
            "block",
            DecidedValue::has_block,
            DecidedValue::block,
            DecidedValue::mut_block,
            DecidedValue::set_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ShardChunk>(
            "shard",
            DecidedValue::has_shard,
            DecidedValue::shard,
            DecidedValue::mut_shard,
            DecidedValue::set_shard,
        ));
        oneofs.push(decided_value::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DecidedValue>(
            "DecidedValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DecidedValue {
    const NAME: &'static str = "DecidedValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.value = ::std::option::Option::Some(decided_value::Value::Block(is.read_message()?));
                },
                26 => {
                    self.value = ::std::option::Option::Some(decided_value::Value::Shard(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &decided_value::Value::Block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &decided_value::Value::Shard(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &decided_value::Value::Block(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &decided_value::Value::Shard(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DecidedValue {
        DecidedValue::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DecidedValue {
        static instance: DecidedValue = DecidedValue {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DecidedValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DecidedValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DecidedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecidedValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DecidedValue`
pub mod decided_value {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:DecidedValue.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:DecidedValue.block)
        Block(super::Block),
        // @@protoc_insertion_point(oneof_field:DecidedValue.shard)
        Shard(super::ShardChunk),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DecidedValue as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

// @@protoc_insertion_point(message:ReadNodeMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReadNodeMessage {
    // message oneof groups
    pub read_node_message: ::std::option::Option<read_node_message::Read_node_message>,
    // special fields
    // @@protoc_insertion_point(special_field:ReadNodeMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadNodeMessage {
    fn default() -> &'a ReadNodeMessage {
        <ReadNodeMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReadNodeMessage {
    pub fn new() -> ReadNodeMessage {
        ::std::default::Default::default()
    }

    // .DecidedValue decided_value = 1;

    pub fn decided_value(&self) -> &DecidedValue {
        match self.read_node_message {
            ::std::option::Option::Some(read_node_message::Read_node_message::DecidedValue(ref v)) => v,
            _ => <DecidedValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_decided_value(&mut self) {
        self.read_node_message = ::std::option::Option::None;
    }

    pub fn has_decided_value(&self) -> bool {
        match self.read_node_message {
            ::std::option::Option::Some(read_node_message::Read_node_message::DecidedValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_decided_value(&mut self, v: DecidedValue) {
        self.read_node_message = ::std::option::Option::Some(read_node_message::Read_node_message::DecidedValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_decided_value(&mut self) -> &mut DecidedValue {
        if let ::std::option::Option::Some(read_node_message::Read_node_message::DecidedValue(_)) = self.read_node_message {
        } else {
            self.read_node_message = ::std::option::Option::Some(read_node_message::Read_node_message::DecidedValue(DecidedValue::new()));
        }
        match self.read_node_message {
            ::std::option::Option::Some(read_node_message::Read_node_message::DecidedValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_decided_value(&mut self) -> DecidedValue {
        if self.has_decided_value() {
            match self.read_node_message.take() {
                ::std::option::Option::Some(read_node_message::Read_node_message::DecidedValue(v)) => v,
                _ => panic!(),
            }
        } else {
            DecidedValue::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DecidedValue>(
            "decided_value",
            ReadNodeMessage::has_decided_value,
            ReadNodeMessage::decided_value,
            ReadNodeMessage::mut_decided_value,
            ReadNodeMessage::set_decided_value,
        ));
        oneofs.push(read_node_message::Read_node_message::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadNodeMessage>(
            "ReadNodeMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadNodeMessage {
    const NAME: &'static str = "ReadNodeMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.read_node_message = ::std::option::Option::Some(read_node_message::Read_node_message::DecidedValue(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.read_node_message {
            match v {
                &read_node_message::Read_node_message::DecidedValue(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.read_node_message {
            match v {
                &read_node_message::Read_node_message::DecidedValue(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadNodeMessage {
        ReadNodeMessage::new()
    }

    fn clear(&mut self) {
        self.read_node_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadNodeMessage {
        static instance: ReadNodeMessage = ReadNodeMessage {
            read_node_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadNodeMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadNodeMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadNodeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadNodeMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ReadNodeMessage`
pub mod read_node_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ReadNodeMessage.read_node_message)
    pub enum Read_node_message {
        // @@protoc_insertion_point(oneof_field:ReadNodeMessage.decided_value)
        DecidedValue(super::DecidedValue),
    }

    impl ::protobuf::Oneof for Read_node_message {
    }

    impl ::protobuf::OneofFull for Read_node_message {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ReadNodeMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("read_node_message").unwrap()).clone()
        }
    }

    impl Read_node_message {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Read_node_message>("read_node_message")
        }
    }
}

// @@protoc_insertion_point(message:ConsensusMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConsensusMessage {
    // message fields
    // @@protoc_insertion_point(field:ConsensusMessage.signature)
    pub signature: ::std::vec::Vec<u8>,
    // message oneof groups
    pub consensus_message: ::std::option::Option<consensus_message::Consensus_message>,
    // special fields
    // @@protoc_insertion_point(special_field:ConsensusMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConsensusMessage {
    fn default() -> &'a ConsensusMessage {
        <ConsensusMessage as ::protobuf::Message>::default_instance()
    }
}

impl ConsensusMessage {
    pub fn new() -> ConsensusMessage {
        ::std::default::Default::default()
    }

    // .Vote vote = 1;

    pub fn vote(&self) -> &Vote {
        match self.consensus_message {
            ::std::option::Option::Some(consensus_message::Consensus_message::Vote(ref v)) => v,
            _ => <Vote as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vote(&mut self) {
        self.consensus_message = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        match self.consensus_message {
            ::std::option::Option::Some(consensus_message::Consensus_message::Vote(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: Vote) {
        self.consensus_message = ::std::option::Option::Some(consensus_message::Consensus_message::Vote(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote(&mut self) -> &mut Vote {
        if let ::std::option::Option::Some(consensus_message::Consensus_message::Vote(_)) = self.consensus_message {
        } else {
            self.consensus_message = ::std::option::Option::Some(consensus_message::Consensus_message::Vote(Vote::new()));
        }
        match self.consensus_message {
            ::std::option::Option::Some(consensus_message::Consensus_message::Vote(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote(&mut self) -> Vote {
        if self.has_vote() {
            match self.consensus_message.take() {
                ::std::option::Option::Some(consensus_message::Consensus_message::Vote(v)) => v,
                _ => panic!(),
            }
        } else {
            Vote::new()
        }
    }

    // .Proposal proposal = 2;

    pub fn proposal(&self) -> &Proposal {
        match self.consensus_message {
            ::std::option::Option::Some(consensus_message::Consensus_message::Proposal(ref v)) => v,
            _ => <Proposal as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_proposal(&mut self) {
        self.consensus_message = ::std::option::Option::None;
    }

    pub fn has_proposal(&self) -> bool {
        match self.consensus_message {
            ::std::option::Option::Some(consensus_message::Consensus_message::Proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: Proposal) {
        self.consensus_message = ::std::option::Option::Some(consensus_message::Consensus_message::Proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proposal(&mut self) -> &mut Proposal {
        if let ::std::option::Option::Some(consensus_message::Consensus_message::Proposal(_)) = self.consensus_message {
        } else {
            self.consensus_message = ::std::option::Option::Some(consensus_message::Consensus_message::Proposal(Proposal::new()));
        }
        match self.consensus_message {
            ::std::option::Option::Some(consensus_message::Consensus_message::Proposal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proposal(&mut self) -> Proposal {
        if self.has_proposal() {
            match self.consensus_message.take() {
                ::std::option::Option::Some(consensus_message::Consensus_message::Proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            Proposal::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Vote>(
            "vote",
            ConsensusMessage::has_vote,
            ConsensusMessage::vote,
            ConsensusMessage::mut_vote,
            ConsensusMessage::set_vote,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Proposal>(
            "proposal",
            ConsensusMessage::has_proposal,
            ConsensusMessage::proposal,
            ConsensusMessage::mut_proposal,
            ConsensusMessage::set_proposal,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &ConsensusMessage| { &m.signature },
            |m: &mut ConsensusMessage| { &mut m.signature },
        ));
        oneofs.push(consensus_message::Consensus_message::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConsensusMessage>(
            "ConsensusMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConsensusMessage {
    const NAME: &'static str = "ConsensusMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.consensus_message = ::std::option::Option::Some(consensus_message::Consensus_message::Vote(is.read_message()?));
                },
                18 => {
                    self.consensus_message = ::std::option::Option::Some(consensus_message::Consensus_message::Proposal(is.read_message()?));
                },
                26 => {
                    self.signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if let ::std::option::Option::Some(ref v) = self.consensus_message {
            match v {
                &consensus_message::Consensus_message::Vote(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &consensus_message::Consensus_message::Proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if let ::std::option::Option::Some(ref v) = self.consensus_message {
            match v {
                &consensus_message::Consensus_message::Vote(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &consensus_message::Consensus_message::Proposal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConsensusMessage {
        ConsensusMessage::new()
    }

    fn clear(&mut self) {
        self.consensus_message = ::std::option::Option::None;
        self.consensus_message = ::std::option::Option::None;
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConsensusMessage {
        static instance: ConsensusMessage = ConsensusMessage {
            signature: ::std::vec::Vec::new(),
            consensus_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConsensusMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConsensusMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConsensusMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConsensusMessage`
pub mod consensus_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ConsensusMessage.consensus_message)
    pub enum Consensus_message {
        // @@protoc_insertion_point(oneof_field:ConsensusMessage.vote)
        Vote(super::Vote),
        // @@protoc_insertion_point(oneof_field:ConsensusMessage.proposal)
        Proposal(super::Proposal),
    }

    impl ::protobuf::Oneof for Consensus_message {
    }

    impl ::protobuf::OneofFull for Consensus_message {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ConsensusMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("consensus_message").unwrap()).clone()
        }
    }

    impl Consensus_message {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Consensus_message>("consensus_message")
        }
    }
}

// @@protoc_insertion_point(message:HeartbeatEventBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HeartbeatEventBody {
    // special fields
    // @@protoc_insertion_point(special_field:HeartbeatEventBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeartbeatEventBody {
    fn default() -> &'a HeartbeatEventBody {
        <HeartbeatEventBody as ::protobuf::Message>::default_instance()
    }
}

impl HeartbeatEventBody {
    pub fn new() -> HeartbeatEventBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeartbeatEventBody>(
            "HeartbeatEventBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HeartbeatEventBody {
    const NAME: &'static str = "HeartbeatEventBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeartbeatEventBody {
        HeartbeatEventBody::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeartbeatEventBody {
        static instance: HeartbeatEventBody = HeartbeatEventBody {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HeartbeatEventBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HeartbeatEventBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HeartbeatEventBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatEventBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MergeMessageEventBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MergeMessageEventBody {
    // message fields
    // @@protoc_insertion_point(field:MergeMessageEventBody.message)
    pub message: ::protobuf::MessageField<super::message::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:MergeMessageEventBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MergeMessageEventBody {
    fn default() -> &'a MergeMessageEventBody {
        <MergeMessageEventBody as ::protobuf::Message>::default_instance()
    }
}

impl MergeMessageEventBody {
    pub fn new() -> MergeMessageEventBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::message::Message>(
            "message",
            |m: &MergeMessageEventBody| { &m.message },
            |m: &mut MergeMessageEventBody| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MergeMessageEventBody>(
            "MergeMessageEventBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MergeMessageEventBody {
    const NAME: &'static str = "MergeMessageEventBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MergeMessageEventBody {
        MergeMessageEventBody::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MergeMessageEventBody {
        static instance: MergeMessageEventBody = MergeMessageEventBody {
            message: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MergeMessageEventBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MergeMessageEventBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MergeMessageEventBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MergeMessageEventBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BlockEventData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockEventData {
    // message fields
    // @@protoc_insertion_point(field:BlockEventData.seqnum)
    pub seqnum: u64,
    // @@protoc_insertion_point(field:BlockEventData.type)
    pub type_: ::protobuf::EnumOrUnknown<BlockEventType>,
    // @@protoc_insertion_point(field:BlockEventData.block_number)
    pub block_number: u64,
    // @@protoc_insertion_point(field:BlockEventData.event_index)
    pub event_index: u64,
    // @@protoc_insertion_point(field:BlockEventData.block_timestamp)
    pub block_timestamp: u64,
    // message oneof groups
    pub body: ::std::option::Option<block_event_data::Body>,
    // special fields
    // @@protoc_insertion_point(special_field:BlockEventData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockEventData {
    fn default() -> &'a BlockEventData {
        <BlockEventData as ::protobuf::Message>::default_instance()
    }
}

impl BlockEventData {
    pub fn new() -> BlockEventData {
        ::std::default::Default::default()
    }

    // .HeartbeatEventBody heartbeat_event_body = 6;

    pub fn heartbeat_event_body(&self) -> &HeartbeatEventBody {
        match self.body {
            ::std::option::Option::Some(block_event_data::Body::HeartbeatEventBody(ref v)) => v,
            _ => <HeartbeatEventBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_heartbeat_event_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_heartbeat_event_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(block_event_data::Body::HeartbeatEventBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_event_body(&mut self, v: HeartbeatEventBody) {
        self.body = ::std::option::Option::Some(block_event_data::Body::HeartbeatEventBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_heartbeat_event_body(&mut self) -> &mut HeartbeatEventBody {
        if let ::std::option::Option::Some(block_event_data::Body::HeartbeatEventBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(block_event_data::Body::HeartbeatEventBody(HeartbeatEventBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(block_event_data::Body::HeartbeatEventBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_heartbeat_event_body(&mut self) -> HeartbeatEventBody {
        if self.has_heartbeat_event_body() {
            match self.body.take() {
                ::std::option::Option::Some(block_event_data::Body::HeartbeatEventBody(v)) => v,
                _ => panic!(),
            }
        } else {
            HeartbeatEventBody::new()
        }
    }

    // .MergeMessageEventBody merge_message_event_body = 7;

    pub fn merge_message_event_body(&self) -> &MergeMessageEventBody {
        match self.body {
            ::std::option::Option::Some(block_event_data::Body::MergeMessageEventBody(ref v)) => v,
            _ => <MergeMessageEventBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_merge_message_event_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_merge_message_event_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(block_event_data::Body::MergeMessageEventBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_merge_message_event_body(&mut self, v: MergeMessageEventBody) {
        self.body = ::std::option::Option::Some(block_event_data::Body::MergeMessageEventBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_merge_message_event_body(&mut self) -> &mut MergeMessageEventBody {
        if let ::std::option::Option::Some(block_event_data::Body::MergeMessageEventBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(block_event_data::Body::MergeMessageEventBody(MergeMessageEventBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(block_event_data::Body::MergeMessageEventBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_merge_message_event_body(&mut self) -> MergeMessageEventBody {
        if self.has_merge_message_event_body() {
            match self.body.take() {
                ::std::option::Option::Some(block_event_data::Body::MergeMessageEventBody(v)) => v,
                _ => panic!(),
            }
        } else {
            MergeMessageEventBody::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seqnum",
            |m: &BlockEventData| { &m.seqnum },
            |m: &mut BlockEventData| { &mut m.seqnum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &BlockEventData| { &m.type_ },
            |m: &mut BlockEventData| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_number",
            |m: &BlockEventData| { &m.block_number },
            |m: &mut BlockEventData| { &mut m.block_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_index",
            |m: &BlockEventData| { &m.event_index },
            |m: &mut BlockEventData| { &mut m.event_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_timestamp",
            |m: &BlockEventData| { &m.block_timestamp },
            |m: &mut BlockEventData| { &mut m.block_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HeartbeatEventBody>(
            "heartbeat_event_body",
            BlockEventData::has_heartbeat_event_body,
            BlockEventData::heartbeat_event_body,
            BlockEventData::mut_heartbeat_event_body,
            BlockEventData::set_heartbeat_event_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MergeMessageEventBody>(
            "merge_message_event_body",
            BlockEventData::has_merge_message_event_body,
            BlockEventData::merge_message_event_body,
            BlockEventData::mut_merge_message_event_body,
            BlockEventData::set_merge_message_event_body,
        ));
        oneofs.push(block_event_data::Body::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockEventData>(
            "BlockEventData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockEventData {
    const NAME: &'static str = "BlockEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seqnum = is.read_uint64()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.block_number = is.read_uint64()?;
                },
                32 => {
                    self.event_index = is.read_uint64()?;
                },
                40 => {
                    self.block_timestamp = is.read_uint64()?;
                },
                50 => {
                    self.body = ::std::option::Option::Some(block_event_data::Body::HeartbeatEventBody(is.read_message()?));
                },
                58 => {
                    self.body = ::std::option::Option::Some(block_event_data::Body::MergeMessageEventBody(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.seqnum != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.seqnum);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.block_number);
        }
        if self.event_index != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.event_index);
        }
        if self.block_timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.block_timestamp);
        }
        if let ::std::option::Option::Some(ref v) = self.body {
            match v {
                &block_event_data::Body::HeartbeatEventBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &block_event_data::Body::MergeMessageEventBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.seqnum != 0 {
            os.write_uint64(1, self.seqnum)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.block_number != 0 {
            os.write_uint64(3, self.block_number)?;
        }
        if self.event_index != 0 {
            os.write_uint64(4, self.event_index)?;
        }
        if self.block_timestamp != 0 {
            os.write_uint64(5, self.block_timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.body {
            match v {
                &block_event_data::Body::HeartbeatEventBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &block_event_data::Body::MergeMessageEventBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockEventData {
        BlockEventData::new()
    }

    fn clear(&mut self) {
        self.seqnum = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT);
        self.block_number = 0;
        self.event_index = 0;
        self.block_timestamp = 0;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockEventData {
        static instance: BlockEventData = BlockEventData {
            seqnum: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            block_number: 0,
            event_index: 0,
            block_timestamp: 0,
            body: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockEventData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockEventData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockEventData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BlockEventData`
pub mod block_event_data {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:BlockEventData.body)
    pub enum Body {
        // @@protoc_insertion_point(oneof_field:BlockEventData.heartbeat_event_body)
        HeartbeatEventBody(super::HeartbeatEventBody),
        // @@protoc_insertion_point(oneof_field:BlockEventData.merge_message_event_body)
        MergeMessageEventBody(super::MergeMessageEventBody),
    }

    impl ::protobuf::Oneof for Body {
    }

    impl ::protobuf::OneofFull for Body {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BlockEventData as ::protobuf::MessageFull>::descriptor().oneof_by_name("body").unwrap()).clone()
        }
    }

    impl Body {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Body>("body")
        }
    }
}

// @@protoc_insertion_point(message:BlockEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockEvent {
    // message fields
    // @@protoc_insertion_point(field:BlockEvent.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:BlockEvent.data)
    pub data: ::protobuf::MessageField<BlockEventData>,
    // special fields
    // @@protoc_insertion_point(special_field:BlockEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockEvent {
    fn default() -> &'a BlockEvent {
        <BlockEvent as ::protobuf::Message>::default_instance()
    }
}

impl BlockEvent {
    pub fn new() -> BlockEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &BlockEvent| { &m.hash },
            |m: &mut BlockEvent| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockEventData>(
            "data",
            |m: &BlockEvent| { &m.data },
            |m: &mut BlockEvent| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockEvent>(
            "BlockEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockEvent {
    const NAME: &'static str = "BlockEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockEvent {
        BlockEvent::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockEvent {
        static instance: BlockEvent = BlockEvent {
            hash: ::std::vec::Vec::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BlockHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockHeader {
    // message fields
    // @@protoc_insertion_point(field:BlockHeader.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:BlockHeader.timestamp)
    pub timestamp: u64,
    // @@protoc_insertion_point(field:BlockHeader.version)
    pub version: u32,
    // @@protoc_insertion_point(field:BlockHeader.chain_id)
    pub chain_id: ::protobuf::EnumOrUnknown<super::message::FarcasterNetwork>,
    // @@protoc_insertion_point(field:BlockHeader.shard_witnesses_hash)
    pub shard_witnesses_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:BlockHeader.parent_hash)
    pub parent_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:BlockHeader.state_root)
    pub state_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:BlockHeader.events_hash)
    pub events_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BlockHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeader {
    fn default() -> &'a BlockHeader {
        <BlockHeader as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader {
    pub fn new() -> BlockHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &BlockHeader| { &m.height },
            |m: &mut BlockHeader| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &BlockHeader| { &m.timestamp },
            |m: &mut BlockHeader| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &BlockHeader| { &m.version },
            |m: &mut BlockHeader| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &BlockHeader| { &m.chain_id },
            |m: &mut BlockHeader| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_witnesses_hash",
            |m: &BlockHeader| { &m.shard_witnesses_hash },
            |m: &mut BlockHeader| { &mut m.shard_witnesses_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_hash",
            |m: &BlockHeader| { &m.parent_hash },
            |m: &mut BlockHeader| { &mut m.parent_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_root",
            |m: &BlockHeader| { &m.state_root },
            |m: &mut BlockHeader| { &mut m.state_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "events_hash",
            |m: &BlockHeader| { &m.events_hash },
            |m: &mut BlockHeader| { &mut m.events_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeader>(
            "BlockHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeader {
    const NAME: &'static str = "BlockHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                16 => {
                    self.timestamp = is.read_uint64()?;
                },
                24 => {
                    self.version = is.read_uint32()?;
                },
                32 => {
                    self.chain_id = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.shard_witnesses_hash = is.read_bytes()?;
                },
                50 => {
                    self.parent_hash = is.read_bytes()?;
                },
                58 => {
                    self.state_root = is.read_bytes()?;
                },
                66 => {
                    self.events_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.timestamp);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.version);
        }
        if self.chain_id != ::protobuf::EnumOrUnknown::new(super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE) {
            my_size += ::protobuf::rt::int32_size(4, self.chain_id.value());
        }
        if !self.shard_witnesses_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.shard_witnesses_hash);
        }
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.parent_hash);
        }
        if !self.state_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.state_root);
        }
        if !self.events_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.events_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if self.version != 0 {
            os.write_uint32(3, self.version)?;
        }
        if self.chain_id != ::protobuf::EnumOrUnknown::new(super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.chain_id))?;
        }
        if !self.shard_witnesses_hash.is_empty() {
            os.write_bytes(5, &self.shard_witnesses_hash)?;
        }
        if !self.parent_hash.is_empty() {
            os.write_bytes(6, &self.parent_hash)?;
        }
        if !self.state_root.is_empty() {
            os.write_bytes(7, &self.state_root)?;
        }
        if !self.events_hash.is_empty() {
            os.write_bytes(8, &self.events_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeader {
        BlockHeader::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.timestamp = 0;
        self.version = 0;
        self.chain_id = ::protobuf::EnumOrUnknown::new(super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE);
        self.shard_witnesses_hash.clear();
        self.parent_hash.clear();
        self.state_root.clear();
        self.events_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeader {
        static instance: BlockHeader = BlockHeader {
            height: ::protobuf::MessageField::none(),
            timestamp: 0,
            version: 0,
            chain_id: ::protobuf::EnumOrUnknown::from_i32(0),
            shard_witnesses_hash: ::std::vec::Vec::new(),
            parent_hash: ::std::vec::Vec::new(),
            state_root: ::std::vec::Vec::new(),
            events_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardWitness)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardWitness {
    // message fields
    // @@protoc_insertion_point(field:ShardWitness.shard_chunk_witnesses)
    pub shard_chunk_witnesses: ::std::vec::Vec<ShardChunkWitness>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardWitness.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardWitness {
    fn default() -> &'a ShardWitness {
        <ShardWitness as ::protobuf::Message>::default_instance()
    }
}

impl ShardWitness {
    pub fn new() -> ShardWitness {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shard_chunk_witnesses",
            |m: &ShardWitness| { &m.shard_chunk_witnesses },
            |m: &mut ShardWitness| { &mut m.shard_chunk_witnesses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardWitness>(
            "ShardWitness",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardWitness {
    const NAME: &'static str = "ShardWitness";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shard_chunk_witnesses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.shard_chunk_witnesses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.shard_chunk_witnesses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardWitness {
        ShardWitness::new()
    }

    fn clear(&mut self) {
        self.shard_chunk_witnesses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardWitness {
        static instance: ShardWitness = ShardWitness {
            shard_chunk_witnesses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardWitness {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardWitness").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardWitness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardWitness {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardChunkWitness)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardChunkWitness {
    // message fields
    // @@protoc_insertion_point(field:ShardChunkWitness.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:ShardChunkWitness.shard_root)
    pub shard_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ShardChunkWitness.shard_hash)
    pub shard_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardChunkWitness.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardChunkWitness {
    fn default() -> &'a ShardChunkWitness {
        <ShardChunkWitness as ::protobuf::Message>::default_instance()
    }
}

impl ShardChunkWitness {
    pub fn new() -> ShardChunkWitness {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &ShardChunkWitness| { &m.height },
            |m: &mut ShardChunkWitness| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_root",
            |m: &ShardChunkWitness| { &m.shard_root },
            |m: &mut ShardChunkWitness| { &mut m.shard_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_hash",
            |m: &ShardChunkWitness| { &m.shard_hash },
            |m: &mut ShardChunkWitness| { &mut m.shard_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardChunkWitness>(
            "ShardChunkWitness",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardChunkWitness {
    const NAME: &'static str = "ShardChunkWitness";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                18 => {
                    self.shard_root = is.read_bytes()?;
                },
                26 => {
                    self.shard_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.shard_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.shard_root);
        }
        if !self.shard_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.shard_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.shard_root.is_empty() {
            os.write_bytes(2, &self.shard_root)?;
        }
        if !self.shard_hash.is_empty() {
            os.write_bytes(3, &self.shard_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardChunkWitness {
        ShardChunkWitness::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.shard_root.clear();
        self.shard_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardChunkWitness {
        static instance: ShardChunkWitness = ShardChunkWitness {
            height: ::protobuf::MessageField::none(),
            shard_root: ::std::vec::Vec::new(),
            shard_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardChunkWitness {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardChunkWitness").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardChunkWitness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardChunkWitness {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Block)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Block {
    // message fields
    // @@protoc_insertion_point(field:Block.header)
    pub header: ::protobuf::MessageField<BlockHeader>,
    // @@protoc_insertion_point(field:Block.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:Block.shard_witness)
    pub shard_witness: ::protobuf::MessageField<ShardWitness>,
    // @@protoc_insertion_point(field:Block.commits)
    pub commits: ::protobuf::MessageField<Commits>,
    // @@protoc_insertion_point(field:Block.transactions)
    pub transactions: ::std::vec::Vec<Transaction>,
    // @@protoc_insertion_point(field:Block.events)
    pub events: ::std::vec::Vec<BlockEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:Block.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockHeader>(
            "header",
            |m: &Block| { &m.header },
            |m: &mut Block| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &Block| { &m.hash },
            |m: &mut Block| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ShardWitness>(
            "shard_witness",
            |m: &Block| { &m.shard_witness },
            |m: &mut Block| { &mut m.shard_witness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Commits>(
            "commits",
            |m: &Block| { &m.commits },
            |m: &mut Block| { &mut m.commits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactions",
            |m: &Block| { &m.transactions },
            |m: &mut Block| { &mut m.transactions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &Block| { &m.events },
            |m: &mut Block| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Block>(
            "Block",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Block {
    const NAME: &'static str = "Block";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.hash = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shard_witness)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commits)?;
                },
                42 => {
                    self.transactions.push(is.read_message()?);
                },
                50 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if let Some(v) = self.shard_witness.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.commits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if let Some(v) = self.shard_witness.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.commits.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.transactions {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Block {
        Block::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.hash.clear();
        self.shard_witness.clear();
        self.commits.clear();
        self.transactions.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Block {
        static instance: Block = Block {
            header: ::protobuf::MessageField::none(),
            hash: ::std::vec::Vec::new(),
            shard_witness: ::protobuf::MessageField::none(),
            commits: ::protobuf::MessageField::none(),
            transactions: ::std::vec::Vec::new(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Block {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Block").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardHeader {
    // message fields
    // @@protoc_insertion_point(field:ShardHeader.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:ShardHeader.timestamp)
    pub timestamp: u64,
    // @@protoc_insertion_point(field:ShardHeader.parent_hash)
    pub parent_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ShardHeader.shard_root)
    pub shard_root: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardHeader {
    fn default() -> &'a ShardHeader {
        <ShardHeader as ::protobuf::Message>::default_instance()
    }
}

impl ShardHeader {
    pub fn new() -> ShardHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &ShardHeader| { &m.height },
            |m: &mut ShardHeader| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &ShardHeader| { &m.timestamp },
            |m: &mut ShardHeader| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_hash",
            |m: &ShardHeader| { &m.parent_hash },
            |m: &mut ShardHeader| { &mut m.parent_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_root",
            |m: &ShardHeader| { &m.shard_root },
            |m: &mut ShardHeader| { &mut m.shard_root },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardHeader>(
            "ShardHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardHeader {
    const NAME: &'static str = "ShardHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                16 => {
                    self.timestamp = is.read_uint64()?;
                },
                26 => {
                    self.parent_hash = is.read_bytes()?;
                },
                34 => {
                    self.shard_root = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.timestamp);
        }
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.parent_hash);
        }
        if !self.shard_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.shard_root);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if !self.parent_hash.is_empty() {
            os.write_bytes(3, &self.parent_hash)?;
        }
        if !self.shard_root.is_empty() {
            os.write_bytes(4, &self.shard_root)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardHeader {
        ShardHeader::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.timestamp = 0;
        self.parent_hash.clear();
        self.shard_root.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardHeader {
        static instance: ShardHeader = ShardHeader {
            height: ::protobuf::MessageField::none(),
            timestamp: 0,
            parent_hash: ::std::vec::Vec::new(),
            shard_root: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardChunk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardChunk {
    // message fields
    // @@protoc_insertion_point(field:ShardChunk.header)
    pub header: ::protobuf::MessageField<ShardHeader>,
    // @@protoc_insertion_point(field:ShardChunk.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ShardChunk.transactions)
    pub transactions: ::std::vec::Vec<Transaction>,
    // @@protoc_insertion_point(field:ShardChunk.commits)
    pub commits: ::protobuf::MessageField<Commits>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardChunk {
    fn default() -> &'a ShardChunk {
        <ShardChunk as ::protobuf::Message>::default_instance()
    }
}

impl ShardChunk {
    pub fn new() -> ShardChunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ShardHeader>(
            "header",
            |m: &ShardChunk| { &m.header },
            |m: &mut ShardChunk| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &ShardChunk| { &m.hash },
            |m: &mut ShardChunk| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactions",
            |m: &ShardChunk| { &m.transactions },
            |m: &mut ShardChunk| { &mut m.transactions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Commits>(
            "commits",
            |m: &ShardChunk| { &m.commits },
            |m: &mut ShardChunk| { &mut m.commits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardChunk>(
            "ShardChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardChunk {
    const NAME: &'static str = "ShardChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.hash = is.read_bytes()?;
                },
                26 => {
                    self.transactions.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commits)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.commits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        for v in &self.transactions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.commits.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardChunk {
        ShardChunk::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.hash.clear();
        self.transactions.clear();
        self.commits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardChunk {
        static instance: ShardChunk = ShardChunk {
            header: ::protobuf::MessageField::none(),
            hash: ::std::vec::Vec::new(),
            transactions: ::std::vec::Vec::new(),
            commits: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Transaction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Transaction {
    // message fields
    // @@protoc_insertion_point(field:Transaction.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:Transaction.user_messages)
    pub user_messages: ::std::vec::Vec<super::message::Message>,
    // @@protoc_insertion_point(field:Transaction.system_messages)
    pub system_messages: ::std::vec::Vec<ValidatorMessage>,
    // @@protoc_insertion_point(field:Transaction.account_root)
    pub account_root: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:Transaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Transaction| { &m.fid },
            |m: &mut Transaction| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_messages",
            |m: &Transaction| { &m.user_messages },
            |m: &mut Transaction| { &mut m.user_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "system_messages",
            |m: &Transaction| { &m.system_messages },
            |m: &mut Transaction| { &mut m.system_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account_root",
            |m: &Transaction| { &m.account_root },
            |m: &mut Transaction| { &mut m.account_root },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transaction>(
            "Transaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transaction {
    const NAME: &'static str = "Transaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.user_messages.push(is.read_message()?);
                },
                26 => {
                    self.system_messages.push(is.read_message()?);
                },
                34 => {
                    self.account_root = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        for value in &self.user_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.system_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.account_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.account_root);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        for v in &self.user_messages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.system_messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.account_root.is_empty() {
            os.write_bytes(4, &self.account_root)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.user_messages.clear();
        self.system_messages.clear();
        self.account_root.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transaction {
        static instance: Transaction = Transaction {
            fid: 0,
            user_messages: ::std::vec::Vec::new(),
            system_messages: ::std::vec::Vec::new(),
            account_root: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FnameTransfer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FnameTransfer {
    // message fields
    // @@protoc_insertion_point(field:FnameTransfer.id)
    pub id: u64,
    // @@protoc_insertion_point(field:FnameTransfer.from_fid)
    pub from_fid: u64,
    // @@protoc_insertion_point(field:FnameTransfer.proof)
    pub proof: ::protobuf::MessageField<super::username_proof::UserNameProof>,
    // special fields
    // @@protoc_insertion_point(special_field:FnameTransfer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FnameTransfer {
    fn default() -> &'a FnameTransfer {
        <FnameTransfer as ::protobuf::Message>::default_instance()
    }
}

impl FnameTransfer {
    pub fn new() -> FnameTransfer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FnameTransfer| { &m.id },
            |m: &mut FnameTransfer| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from_fid",
            |m: &FnameTransfer| { &m.from_fid },
            |m: &mut FnameTransfer| { &mut m.from_fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::username_proof::UserNameProof>(
            "proof",
            |m: &FnameTransfer| { &m.proof },
            |m: &mut FnameTransfer| { &mut m.proof },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FnameTransfer>(
            "FnameTransfer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FnameTransfer {
    const NAME: &'static str = "FnameTransfer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                16 => {
                    self.from_fid = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if self.from_fid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.from_fid);
        }
        if let Some(v) = self.proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.from_fid != 0 {
            os.write_uint64(2, self.from_fid)?;
        }
        if let Some(v) = self.proof.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FnameTransfer {
        FnameTransfer::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.from_fid = 0;
        self.proof.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FnameTransfer {
        static instance: FnameTransfer = FnameTransfer {
            id: 0,
            from_fid: 0,
            proof: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FnameTransfer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FnameTransfer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FnameTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FnameTransfer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ValidatorMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatorMessage {
    // message fields
    // @@protoc_insertion_point(field:ValidatorMessage.on_chain_event)
    pub on_chain_event: ::protobuf::MessageField<super::onchain_event::OnChainEvent>,
    // @@protoc_insertion_point(field:ValidatorMessage.fname_transfer)
    pub fname_transfer: ::protobuf::MessageField<FnameTransfer>,
    // @@protoc_insertion_point(field:ValidatorMessage.block_event)
    pub block_event: ::protobuf::MessageField<BlockEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:ValidatorMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorMessage {
    fn default() -> &'a ValidatorMessage {
        <ValidatorMessage as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorMessage {
    pub fn new() -> ValidatorMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::onchain_event::OnChainEvent>(
            "on_chain_event",
            |m: &ValidatorMessage| { &m.on_chain_event },
            |m: &mut ValidatorMessage| { &mut m.on_chain_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FnameTransfer>(
            "fname_transfer",
            |m: &ValidatorMessage| { &m.fname_transfer },
            |m: &mut ValidatorMessage| { &mut m.fname_transfer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockEvent>(
            "block_event",
            |m: &ValidatorMessage| { &m.block_event },
            |m: &mut ValidatorMessage| { &mut m.block_event },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorMessage>(
            "ValidatorMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorMessage {
    const NAME: &'static str = "ValidatorMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.on_chain_event)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fname_transfer)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_event)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.on_chain_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fname_transfer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.block_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.on_chain_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.fname_transfer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.block_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorMessage {
        ValidatorMessage::new()
    }

    fn clear(&mut self) {
        self.on_chain_event.clear();
        self.fname_transfer.clear();
        self.block_event.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorMessage {
        static instance: ValidatorMessage = ValidatorMessage {
            on_chain_event: ::protobuf::MessageField::none(),
            fname_transfer: ::protobuf::MessageField::none(),
            block_event: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MempoolMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MempoolMessage {
    // message oneof groups
    pub mempool_message: ::std::option::Option<mempool_message::Mempool_message>,
    // special fields
    // @@protoc_insertion_point(special_field:MempoolMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MempoolMessage {
    fn default() -> &'a MempoolMessage {
        <MempoolMessage as ::protobuf::Message>::default_instance()
    }
}

impl MempoolMessage {
    pub fn new() -> MempoolMessage {
        ::std::default::Default::default()
    }

    // .Message user_message = 1;

    pub fn user_message(&self) -> &super::message::Message {
        match self.mempool_message {
            ::std::option::Option::Some(mempool_message::Mempool_message::UserMessage(ref v)) => v,
            _ => <super::message::Message as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_user_message(&mut self) {
        self.mempool_message = ::std::option::Option::None;
    }

    pub fn has_user_message(&self) -> bool {
        match self.mempool_message {
            ::std::option::Option::Some(mempool_message::Mempool_message::UserMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_message(&mut self, v: super::message::Message) {
        self.mempool_message = ::std::option::Option::Some(mempool_message::Mempool_message::UserMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_message(&mut self) -> &mut super::message::Message {
        if let ::std::option::Option::Some(mempool_message::Mempool_message::UserMessage(_)) = self.mempool_message {
        } else {
            self.mempool_message = ::std::option::Option::Some(mempool_message::Mempool_message::UserMessage(super::message::Message::new()));
        }
        match self.mempool_message {
            ::std::option::Option::Some(mempool_message::Mempool_message::UserMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_message(&mut self) -> super::message::Message {
        if self.has_user_message() {
            match self.mempool_message.take() {
                ::std::option::Option::Some(mempool_message::Mempool_message::UserMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::Message::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::message::Message>(
            "user_message",
            MempoolMessage::has_user_message,
            MempoolMessage::user_message,
            MempoolMessage::mut_user_message,
            MempoolMessage::set_user_message,
        ));
        oneofs.push(mempool_message::Mempool_message::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MempoolMessage>(
            "MempoolMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MempoolMessage {
    const NAME: &'static str = "MempoolMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mempool_message = ::std::option::Option::Some(mempool_message::Mempool_message::UserMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mempool_message {
            match v {
                &mempool_message::Mempool_message::UserMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.mempool_message {
            match v {
                &mempool_message::Mempool_message::UserMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MempoolMessage {
        MempoolMessage::new()
    }

    fn clear(&mut self) {
        self.mempool_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MempoolMessage {
        static instance: MempoolMessage = MempoolMessage {
            mempool_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MempoolMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MempoolMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MempoolMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MempoolMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MempoolMessage`
pub mod mempool_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:MempoolMessage.mempool_message)
    pub enum Mempool_message {
        // @@protoc_insertion_point(oneof_field:MempoolMessage.user_message)
        UserMessage(super::super::message::Message),
    }

    impl ::protobuf::Oneof for Mempool_message {
    }

    impl ::protobuf::OneofFull for Mempool_message {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::MempoolMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("mempool_message").unwrap()).clone()
        }
    }

    impl Mempool_message {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Mempool_message>("mempool_message")
        }
    }
}

// @@protoc_insertion_point(message:StatusMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatusMessage {
    // message fields
    // @@protoc_insertion_point(field:StatusMessage.peer_id)
    pub peer_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:StatusMessage.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:StatusMessage.min_height)
    pub min_height: ::protobuf::MessageField<Height>,
    // special fields
    // @@protoc_insertion_point(special_field:StatusMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusMessage {
    fn default() -> &'a StatusMessage {
        <StatusMessage as ::protobuf::Message>::default_instance()
    }
}

impl StatusMessage {
    pub fn new() -> StatusMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "peer_id",
            |m: &StatusMessage| { &m.peer_id },
            |m: &mut StatusMessage| { &mut m.peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &StatusMessage| { &m.height },
            |m: &mut StatusMessage| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "min_height",
            |m: &StatusMessage| { &m.min_height },
            |m: &mut StatusMessage| { &mut m.min_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusMessage>(
            "StatusMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusMessage {
    const NAME: &'static str = "StatusMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.peer_id = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.min_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.peer_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.peer_id);
        }
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.min_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.peer_id.is_empty() {
            os.write_bytes(1, &self.peer_id)?;
        }
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.min_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusMessage {
        StatusMessage::new()
    }

    fn clear(&mut self) {
        self.peer_id.clear();
        self.height.clear();
        self.min_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusMessage {
        static instance: StatusMessage = StatusMessage {
            peer_id: ::std::vec::Vec::new(),
            height: ::protobuf::MessageField::none(),
            min_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SyncValueRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SyncValueRequest {
    // message fields
    // @@protoc_insertion_point(field:SyncValueRequest.height)
    pub height: ::protobuf::MessageField<Height>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncValueRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncValueRequest {
    fn default() -> &'a SyncValueRequest {
        <SyncValueRequest as ::protobuf::Message>::default_instance()
    }
}

impl SyncValueRequest {
    pub fn new() -> SyncValueRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &SyncValueRequest| { &m.height },
            |m: &mut SyncValueRequest| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncValueRequest>(
            "SyncValueRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncValueRequest {
    const NAME: &'static str = "SyncValueRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncValueRequest {
        SyncValueRequest::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncValueRequest {
        static instance: SyncValueRequest = SyncValueRequest {
            height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncValueRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncValueRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncValueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncValueRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SyncVoteSetRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SyncVoteSetRequest {
    // message fields
    // @@protoc_insertion_point(field:SyncVoteSetRequest.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:SyncVoteSetRequest.round)
    pub round: i64,
    // special fields
    // @@protoc_insertion_point(special_field:SyncVoteSetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncVoteSetRequest {
    fn default() -> &'a SyncVoteSetRequest {
        <SyncVoteSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl SyncVoteSetRequest {
    pub fn new() -> SyncVoteSetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &SyncVoteSetRequest| { &m.height },
            |m: &mut SyncVoteSetRequest| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &SyncVoteSetRequest| { &m.round },
            |m: &mut SyncVoteSetRequest| { &mut m.round },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncVoteSetRequest>(
            "SyncVoteSetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncVoteSetRequest {
    const NAME: &'static str = "SyncVoteSetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                16 => {
                    self.round = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.round);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncVoteSetRequest {
        SyncVoteSetRequest::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncVoteSetRequest {
        static instance: SyncVoteSetRequest = SyncVoteSetRequest {
            height: ::protobuf::MessageField::none(),
            round: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncVoteSetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncVoteSetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncVoteSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncVoteSetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SyncRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SyncRequest {
    // message oneof groups
    pub sync_request: ::std::option::Option<sync_request::Sync_request>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncRequest {
    fn default() -> &'a SyncRequest {
        <SyncRequest as ::protobuf::Message>::default_instance()
    }
}

impl SyncRequest {
    pub fn new() -> SyncRequest {
        ::std::default::Default::default()
    }

    // .SyncValueRequest value = 1;

    pub fn value(&self) -> &SyncValueRequest {
        match self.sync_request {
            ::std::option::Option::Some(sync_request::Sync_request::Value(ref v)) => v,
            _ => <SyncValueRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_value(&mut self) {
        self.sync_request = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        match self.sync_request {
            ::std::option::Option::Some(sync_request::Sync_request::Value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SyncValueRequest) {
        self.sync_request = ::std::option::Option::Some(sync_request::Sync_request::Value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut SyncValueRequest {
        if let ::std::option::Option::Some(sync_request::Sync_request::Value(_)) = self.sync_request {
        } else {
            self.sync_request = ::std::option::Option::Some(sync_request::Sync_request::Value(SyncValueRequest::new()));
        }
        match self.sync_request {
            ::std::option::Option::Some(sync_request::Sync_request::Value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value(&mut self) -> SyncValueRequest {
        if self.has_value() {
            match self.sync_request.take() {
                ::std::option::Option::Some(sync_request::Sync_request::Value(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncValueRequest::new()
        }
    }

    // .SyncVoteSetRequest vote_set = 2;

    pub fn vote_set(&self) -> &SyncVoteSetRequest {
        match self.sync_request {
            ::std::option::Option::Some(sync_request::Sync_request::VoteSet(ref v)) => v,
            _ => <SyncVoteSetRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vote_set(&mut self) {
        self.sync_request = ::std::option::Option::None;
    }

    pub fn has_vote_set(&self) -> bool {
        match self.sync_request {
            ::std::option::Option::Some(sync_request::Sync_request::VoteSet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote_set(&mut self, v: SyncVoteSetRequest) {
        self.sync_request = ::std::option::Option::Some(sync_request::Sync_request::VoteSet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote_set(&mut self) -> &mut SyncVoteSetRequest {
        if let ::std::option::Option::Some(sync_request::Sync_request::VoteSet(_)) = self.sync_request {
        } else {
            self.sync_request = ::std::option::Option::Some(sync_request::Sync_request::VoteSet(SyncVoteSetRequest::new()));
        }
        match self.sync_request {
            ::std::option::Option::Some(sync_request::Sync_request::VoteSet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote_set(&mut self) -> SyncVoteSetRequest {
        if self.has_vote_set() {
            match self.sync_request.take() {
                ::std::option::Option::Some(sync_request::Sync_request::VoteSet(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncVoteSetRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SyncValueRequest>(
            "value",
            SyncRequest::has_value,
            SyncRequest::value,
            SyncRequest::mut_value,
            SyncRequest::set_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SyncVoteSetRequest>(
            "vote_set",
            SyncRequest::has_vote_set,
            SyncRequest::vote_set,
            SyncRequest::mut_vote_set,
            SyncRequest::set_vote_set,
        ));
        oneofs.push(sync_request::Sync_request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncRequest>(
            "SyncRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncRequest {
    const NAME: &'static str = "SyncRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sync_request = ::std::option::Option::Some(sync_request::Sync_request::Value(is.read_message()?));
                },
                18 => {
                    self.sync_request = ::std::option::Option::Some(sync_request::Sync_request::VoteSet(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.sync_request {
            match v {
                &sync_request::Sync_request::Value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sync_request::Sync_request::VoteSet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.sync_request {
            match v {
                &sync_request::Sync_request::Value(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &sync_request::Sync_request::VoteSet(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncRequest {
        SyncRequest::new()
    }

    fn clear(&mut self) {
        self.sync_request = ::std::option::Option::None;
        self.sync_request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncRequest {
        static instance: SyncRequest = SyncRequest {
            sync_request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SyncRequest`
pub mod sync_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SyncRequest.sync_request)
    pub enum Sync_request {
        // @@protoc_insertion_point(oneof_field:SyncRequest.value)
        Value(super::SyncValueRequest),
        // @@protoc_insertion_point(oneof_field:SyncRequest.vote_set)
        VoteSet(super::SyncVoteSetRequest),
    }

    impl ::protobuf::Oneof for Sync_request {
    }

    impl ::protobuf::OneofFull for Sync_request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SyncRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sync_request").unwrap()).clone()
        }
    }

    impl Sync_request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sync_request>("sync_request")
        }
    }
}

// @@protoc_insertion_point(message:SyncValueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SyncValueResponse {
    // message fields
    // @@protoc_insertion_point(field:SyncValueResponse.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:SyncValueResponse.full_value)
    pub full_value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:SyncValueResponse.commits)
    pub commits: ::protobuf::MessageField<Commits>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncValueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncValueResponse {
    fn default() -> &'a SyncValueResponse {
        <SyncValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl SyncValueResponse {
    pub fn new() -> SyncValueResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &SyncValueResponse| { &m.height },
            |m: &mut SyncValueResponse| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "full_value",
            |m: &SyncValueResponse| { &m.full_value },
            |m: &mut SyncValueResponse| { &mut m.full_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Commits>(
            "commits",
            |m: &SyncValueResponse| { &m.commits },
            |m: &mut SyncValueResponse| { &mut m.commits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncValueResponse>(
            "SyncValueResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncValueResponse {
    const NAME: &'static str = "SyncValueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                18 => {
                    self.full_value = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commits)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.full_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.full_value);
        }
        if let Some(v) = self.commits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.full_value.is_empty() {
            os.write_bytes(2, &self.full_value)?;
        }
        if let Some(v) = self.commits.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncValueResponse {
        SyncValueResponse::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.full_value.clear();
        self.commits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncValueResponse {
        static instance: SyncValueResponse = SyncValueResponse {
            height: ::protobuf::MessageField::none(),
            full_value: ::std::vec::Vec::new(),
            commits: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncValueResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncValueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncValueResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SyncVoteSetResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SyncVoteSetResponse {
    // message fields
    // @@protoc_insertion_point(field:SyncVoteSetResponse.height)
    pub height: ::protobuf::MessageField<Height>,
    // @@protoc_insertion_point(field:SyncVoteSetResponse.round)
    pub round: i64,
    // @@protoc_insertion_point(field:SyncVoteSetResponse.votes)
    pub votes: ::std::vec::Vec<Vote>,
    // @@protoc_insertion_point(field:SyncVoteSetResponse.signatures)
    pub signatures: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncVoteSetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncVoteSetResponse {
    fn default() -> &'a SyncVoteSetResponse {
        <SyncVoteSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl SyncVoteSetResponse {
    pub fn new() -> SyncVoteSetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &SyncVoteSetResponse| { &m.height },
            |m: &mut SyncVoteSetResponse| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &SyncVoteSetResponse| { &m.round },
            |m: &mut SyncVoteSetResponse| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "votes",
            |m: &SyncVoteSetResponse| { &m.votes },
            |m: &mut SyncVoteSetResponse| { &mut m.votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &SyncVoteSetResponse| { &m.signatures },
            |m: &mut SyncVoteSetResponse| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncVoteSetResponse>(
            "SyncVoteSetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncVoteSetResponse {
    const NAME: &'static str = "SyncVoteSetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                16 => {
                    self.round = is.read_int64()?;
                },
                26 => {
                    self.votes.push(is.read_message()?);
                },
                34 => {
                    self.signatures.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.round);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.signatures {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.round != 0 {
            os.write_int64(2, self.round)?;
        }
        for v in &self.votes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.signatures {
            os.write_bytes(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncVoteSetResponse {
        SyncVoteSetResponse::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.round = 0;
        self.votes.clear();
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncVoteSetResponse {
        static instance: SyncVoteSetResponse = SyncVoteSetResponse {
            height: ::protobuf::MessageField::none(),
            round: 0,
            votes: ::std::vec::Vec::new(),
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncVoteSetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncVoteSetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncVoteSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncVoteSetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SyncResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SyncResponse {
    // message oneof groups
    pub sync_response: ::std::option::Option<sync_response::Sync_response>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncResponse {
    fn default() -> &'a SyncResponse {
        <SyncResponse as ::protobuf::Message>::default_instance()
    }
}

impl SyncResponse {
    pub fn new() -> SyncResponse {
        ::std::default::Default::default()
    }

    // .SyncValueResponse value = 1;

    pub fn value(&self) -> &SyncValueResponse {
        match self.sync_response {
            ::std::option::Option::Some(sync_response::Sync_response::Value(ref v)) => v,
            _ => <SyncValueResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_value(&mut self) {
        self.sync_response = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        match self.sync_response {
            ::std::option::Option::Some(sync_response::Sync_response::Value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SyncValueResponse) {
        self.sync_response = ::std::option::Option::Some(sync_response::Sync_response::Value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut SyncValueResponse {
        if let ::std::option::Option::Some(sync_response::Sync_response::Value(_)) = self.sync_response {
        } else {
            self.sync_response = ::std::option::Option::Some(sync_response::Sync_response::Value(SyncValueResponse::new()));
        }
        match self.sync_response {
            ::std::option::Option::Some(sync_response::Sync_response::Value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value(&mut self) -> SyncValueResponse {
        if self.has_value() {
            match self.sync_response.take() {
                ::std::option::Option::Some(sync_response::Sync_response::Value(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncValueResponse::new()
        }
    }

    // .SyncVoteSetResponse vote_set = 2;

    pub fn vote_set(&self) -> &SyncVoteSetResponse {
        match self.sync_response {
            ::std::option::Option::Some(sync_response::Sync_response::VoteSet(ref v)) => v,
            _ => <SyncVoteSetResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vote_set(&mut self) {
        self.sync_response = ::std::option::Option::None;
    }

    pub fn has_vote_set(&self) -> bool {
        match self.sync_response {
            ::std::option::Option::Some(sync_response::Sync_response::VoteSet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote_set(&mut self, v: SyncVoteSetResponse) {
        self.sync_response = ::std::option::Option::Some(sync_response::Sync_response::VoteSet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote_set(&mut self) -> &mut SyncVoteSetResponse {
        if let ::std::option::Option::Some(sync_response::Sync_response::VoteSet(_)) = self.sync_response {
        } else {
            self.sync_response = ::std::option::Option::Some(sync_response::Sync_response::VoteSet(SyncVoteSetResponse::new()));
        }
        match self.sync_response {
            ::std::option::Option::Some(sync_response::Sync_response::VoteSet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote_set(&mut self) -> SyncVoteSetResponse {
        if self.has_vote_set() {
            match self.sync_response.take() {
                ::std::option::Option::Some(sync_response::Sync_response::VoteSet(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncVoteSetResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SyncValueResponse>(
            "value",
            SyncResponse::has_value,
            SyncResponse::value,
            SyncResponse::mut_value,
            SyncResponse::set_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SyncVoteSetResponse>(
            "vote_set",
            SyncResponse::has_vote_set,
            SyncResponse::vote_set,
            SyncResponse::mut_vote_set,
            SyncResponse::set_vote_set,
        ));
        oneofs.push(sync_response::Sync_response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncResponse>(
            "SyncResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncResponse {
    const NAME: &'static str = "SyncResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sync_response = ::std::option::Option::Some(sync_response::Sync_response::Value(is.read_message()?));
                },
                18 => {
                    self.sync_response = ::std::option::Option::Some(sync_response::Sync_response::VoteSet(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.sync_response {
            match v {
                &sync_response::Sync_response::Value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sync_response::Sync_response::VoteSet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.sync_response {
            match v {
                &sync_response::Sync_response::Value(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &sync_response::Sync_response::VoteSet(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncResponse {
        SyncResponse::new()
    }

    fn clear(&mut self) {
        self.sync_response = ::std::option::Option::None;
        self.sync_response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncResponse {
        static instance: SyncResponse = SyncResponse {
            sync_response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SyncResponse`
pub mod sync_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SyncResponse.sync_response)
    pub enum Sync_response {
        // @@protoc_insertion_point(oneof_field:SyncResponse.value)
        Value(super::SyncValueResponse),
        // @@protoc_insertion_point(oneof_field:SyncResponse.vote_set)
        VoteSet(super::SyncVoteSetResponse),
    }

    impl ::protobuf::Oneof for Sync_response {
    }

    impl ::protobuf::OneofFull for Sync_response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SyncResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("sync_response").unwrap()).clone()
        }
    }

    impl Sync_response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sync_response>("sync_response")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoteType)
pub enum VoteType {
    // @@protoc_insertion_point(enum_value:VoteType.PREVOTE)
    PREVOTE = 0,
    // @@protoc_insertion_point(enum_value:VoteType.PRECOMMIT)
    PRECOMMIT = 1,
}

impl ::protobuf::Enum for VoteType {
    const NAME: &'static str = "VoteType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoteType> {
        match value {
            0 => ::std::option::Option::Some(VoteType::PREVOTE),
            1 => ::std::option::Option::Some(VoteType::PRECOMMIT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoteType> {
        match str {
            "PREVOTE" => ::std::option::Option::Some(VoteType::PREVOTE),
            "PRECOMMIT" => ::std::option::Option::Some(VoteType::PRECOMMIT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoteType] = &[
        VoteType::PREVOTE,
        VoteType::PRECOMMIT,
    ];
}

impl ::protobuf::EnumFull for VoteType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoteType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VoteType {
    fn default() -> Self {
        VoteType::PREVOTE
    }
}

impl VoteType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoteType>("VoteType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:BlockEventType)
pub enum BlockEventType {
    // @@protoc_insertion_point(enum_value:BlockEventType.BLOCK_EVENT_TYPE_HEARTBEAT)
    BLOCK_EVENT_TYPE_HEARTBEAT = 0,
    // @@protoc_insertion_point(enum_value:BlockEventType.BLOCK_EVENT_TYPE_MERGE_MESSAGE)
    BLOCK_EVENT_TYPE_MERGE_MESSAGE = 1,
}

impl ::protobuf::Enum for BlockEventType {
    const NAME: &'static str = "BlockEventType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockEventType> {
        match value {
            0 => ::std::option::Option::Some(BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT),
            1 => ::std::option::Option::Some(BlockEventType::BLOCK_EVENT_TYPE_MERGE_MESSAGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BlockEventType> {
        match str {
            "BLOCK_EVENT_TYPE_HEARTBEAT" => ::std::option::Option::Some(BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT),
            "BLOCK_EVENT_TYPE_MERGE_MESSAGE" => ::std::option::Option::Some(BlockEventType::BLOCK_EVENT_TYPE_MERGE_MESSAGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BlockEventType] = &[
        BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT,
        BlockEventType::BLOCK_EVENT_TYPE_MERGE_MESSAGE,
    ];
}

impl ::protobuf::EnumFull for BlockEventType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BlockEventType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BlockEventType {
    fn default() -> Self {
        BlockEventType::BLOCK_EVENT_TYPE_HEARTBEAT
    }
}

impl BlockEventType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BlockEventType>("BlockEventType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cblocks.proto\x1a\rmessage.proto\x1a\x14username_proof.proto\x1a\
    \x13onchain_event.proto\"\x9e\x01\n\tValidator\x12\x10\n\x03fid\x18\x01\
    \x20\x01(\x04R\x03fid\x12\x16\n\x06signer\x18\x02\x20\x01(\x0cR\x06signe\
    r\x12\x1f\n\x0brpc_address\x18\x03\x20\x01(\tR\nrpcAddress\x12\x1f\n\x0b\
    shard_index\x18\x04\x20\x01(\rR\nshardIndex\x12%\n\x0ecurrent_height\x18\
    \x05\x20\x01(\x04R\rcurrentHeight\":\n\x0cValidatorSet\x12*\n\nvalidator\
    s\x18\x01\x20\x03(\x0b2\n.ValidatorR\nvalidators\"L\n\x06Height\x12\x1f\
    \n\x0bshard_index\x18\x01\x20\x01(\rR\nshardIndex\x12!\n\x0cblock_number\
    \x18\x02\x20\x01(\x04R\x0bblockNumber\"@\n\tShardHash\x12\x1f\n\x0bshard\
    _index\x18\x01\x20\x01(\rR\nshardIndex\x12\x12\n\x04hash\x18\x02\x20\x01\
    (\x0cR\x04hash\"\x94\x01\n\x04Vote\x12\x1d\n\x04type\x18\x01\x20\x01(\
    \x0e2\t.VoteTypeR\x04type\x12\x1f\n\x06height\x18\x02\x20\x01(\x0b2\x07.\
    HeightR\x06height\x12\x14\n\x05round\x18\x03\x20\x01(\x03R\x05round\x12\
    \x20\n\x05value\x18\x04\x20\x01(\x0b2\n.ShardHashR\x05value\x12\x14\n\
    \x05voter\x18\x05\x20\x01(\x0cR\x05voter\"G\n\x0fCommitSignature\x12\x16\
    \n\x06signer\x18\x01\x20\x01(\x0cR\x06signer\x12\x1c\n\tsignature\x18\
    \x02\x20\x01(\x0cR\tsignature\"\x94\x01\n\x07Commits\x12\x1f\n\x06height\
    \x18\x01\x20\x01(\x0b2\x07.HeightR\x06height\x12\x14\n\x05round\x18\x02\
    \x20\x01(\x03R\x05round\x12\x20\n\x05value\x18\x03\x20\x01(\x0b2\n.Shard\
    HashR\x05value\x120\n\nsignatures\x18\x04\x20\x03(\x0b2\x10.CommitSignat\
    ureR\nsignatures\"\x9c\x01\n\x08Proposal\x12\x1f\n\x06height\x18\x01\x20\
    \x01(\x0b2\x07.HeightR\x06height\x12\x14\n\x05round\x18\x02\x20\x01(\x03\
    R\x05round\x12\x1b\n\tpol_round\x18\x03\x20\x01(\x03R\x08polRound\x12\
    \x1a\n\x08proposer\x18\x04\x20\x01(\x0cR\x08proposer\x12\x20\n\x05value\
    \x18\x05\x20\x01(\x0b2\n.ShardHashR\x05value\"\xb8\x01\n\x0cFullProposal\
    \x12\x1f\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06height\x12\x14\
    \n\x05round\x18\x02\x20\x01(\x03R\x05round\x12\x1a\n\x08proposer\x18\x03\
    \x20\x01(\x0cR\x08proposer\x12\x1e\n\x05block\x18\x04\x20\x01(\x0b2\x06.\
    BlockH\0R\x05block\x12#\n\x05shard\x18\x05\x20\x01(\x0b2\x0b.ShardChunkH\
    \0R\x05shardB\x10\n\x0eproposed_value\"\\\n\x0cDecidedValue\x12\x1e\n\
    \x05block\x18\x02\x20\x01(\x0b2\x06.BlockH\0R\x05block\x12#\n\x05shard\
    \x18\x03\x20\x01(\x0b2\x0b.ShardChunkH\0R\x05shardB\x07\n\x05value\"\\\n\
    \x0fReadNodeMessage\x124\n\rdecided_value\x18\x01\x20\x01(\x0b2\r.Decide\
    dValueH\0R\x0cdecidedValueB\x13\n\x11read_node_message\"\x8b\x01\n\x10Co\
    nsensusMessage\x12\x1b\n\x04vote\x18\x01\x20\x01(\x0b2\x05.VoteH\0R\x04v\
    ote\x12'\n\x08proposal\x18\x02\x20\x01(\x0b2\t.ProposalH\0R\x08proposal\
    \x12\x1c\n\tsignature\x18\x03\x20\x01(\x0cR\tsignatureB\x13\n\x11consens\
    us_message\"\x14\n\x12HeartbeatEventBody\";\n\x15MergeMessageEventBody\
    \x12\"\n\x07message\x18\x01\x20\x01(\x0b2\x08.MessageR\x07message\"\xde\
    \x02\n\x0eBlockEventData\x12\x16\n\x06seqnum\x18\x01\x20\x01(\x04R\x06se\
    qnum\x12#\n\x04type\x18\x02\x20\x01(\x0e2\x0f.BlockEventTypeR\x04type\
    \x12!\n\x0cblock_number\x18\x03\x20\x01(\x04R\x0bblockNumber\x12\x1f\n\
    \x0bevent_index\x18\x04\x20\x01(\x04R\neventIndex\x12'\n\x0fblock_timest\
    amp\x18\x05\x20\x01(\x04R\x0eblockTimestamp\x12G\n\x14heartbeat_event_bo\
    dy\x18\x06\x20\x01(\x0b2\x13.HeartbeatEventBodyH\0R\x12heartbeatEventBod\
    y\x12Q\n\x18merge_message_event_body\x18\x07\x20\x01(\x0b2\x16.MergeMess\
    ageEventBodyH\0R\x15mergeMessageEventBodyB\x06\n\x04body\"E\n\nBlockEven\
    t\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12#\n\x04data\x18\x02\
    \x20\x01(\x0b2\x0f.BlockEventDataR\x04data\"\xa7\x02\n\x0bBlockHeader\
    \x12\x1f\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06height\x12\x1c\
    \n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestamp\x12\x18\n\x07version\x18\
    \x03\x20\x01(\rR\x07version\x12,\n\x08chain_id\x18\x04\x20\x01(\x0e2\x11\
    .FarcasterNetworkR\x07chainId\x120\n\x14shard_witnesses_hash\x18\x05\x20\
    \x01(\x0cR\x12shardWitnessesHash\x12\x1f\n\x0bparent_hash\x18\x06\x20\
    \x01(\x0cR\nparentHash\x12\x1d\n\nstate_root\x18\x07\x20\x01(\x0cR\tstat\
    eRoot\x12\x1f\n\x0bevents_hash\x18\x08\x20\x01(\x0cR\neventsHash\"V\n\
    \x0cShardWitness\x12F\n\x15shard_chunk_witnesses\x18\x01\x20\x03(\x0b2\
    \x12.ShardChunkWitnessR\x13shardChunkWitnesses\"r\n\x11ShardChunkWitness\
    \x12\x1f\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06height\x12\x1d\
    \n\nshard_root\x18\x02\x20\x01(\x0cR\tshardRoot\x12\x1d\n\nshard_hash\
    \x18\x03\x20\x01(\x0cR\tshardHash\"\xf0\x01\n\x05Block\x12$\n\x06header\
    \x18\x01\x20\x01(\x0b2\x0c.BlockHeaderR\x06header\x12\x12\n\x04hash\x18\
    \x02\x20\x01(\x0cR\x04hash\x122\n\rshard_witness\x18\x03\x20\x01(\x0b2\r\
    .ShardWitnessR\x0cshardWitness\x12\"\n\x07commits\x18\x04\x20\x01(\x0b2\
    \x08.CommitsR\x07commits\x120\n\x0ctransactions\x18\x05\x20\x03(\x0b2\
    \x0c.TransactionR\x0ctransactions\x12#\n\x06events\x18\x06\x20\x03(\x0b2\
    \x0b.BlockEventR\x06events\"\x8c\x01\n\x0bShardHeader\x12\x1f\n\x06heigh\
    t\x18\x01\x20\x01(\x0b2\x07.HeightR\x06height\x12\x1c\n\ttimestamp\x18\
    \x02\x20\x01(\x04R\ttimestamp\x12\x1f\n\x0bparent_hash\x18\x03\x20\x01(\
    \x0cR\nparentHash\x12\x1d\n\nshard_root\x18\x04\x20\x01(\x0cR\tshardRoot\
    \"\x9c\x01\n\nShardChunk\x12$\n\x06header\x18\x01\x20\x01(\x0b2\x0c.Shar\
    dHeaderR\x06header\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\x120\
    \n\x0ctransactions\x18\x03\x20\x03(\x0b2\x0c.TransactionR\x0ctransaction\
    s\x12\"\n\x07commits\x18\x04\x20\x01(\x0b2\x08.CommitsR\x07commits\"\xad\
    \x01\n\x0bTransaction\x12\x10\n\x03fid\x18\x01\x20\x01(\x04R\x03fid\x12-\
    \n\ruser_messages\x18\x02\x20\x03(\x0b2\x08.MessageR\x0cuserMessages\x12\
    :\n\x0fsystem_messages\x18\x03\x20\x03(\x0b2\x11.ValidatorMessageR\x0esy\
    stemMessages\x12!\n\x0caccount_root\x18\x04\x20\x01(\x0cR\x0baccountRoot\
    \"`\n\rFnameTransfer\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12\x19\
    \n\x08from_fid\x18\x02\x20\x01(\x04R\x07fromFid\x12$\n\x05proof\x18\x04\
    \x20\x01(\x0b2\x0e.UserNameProofR\x05proof\"\xac\x01\n\x10ValidatorMessa\
    ge\x123\n\x0eon_chain_event\x18\x01\x20\x01(\x0b2\r.OnChainEventR\x0conC\
    hainEvent\x125\n\x0efname_transfer\x18\x02\x20\x01(\x0b2\x0e.FnameTransf\
    erR\rfnameTransfer\x12,\n\x0bblock_event\x18\x03\x20\x01(\x0b2\x0b.Block\
    EventR\nblockEvent\"R\n\x0eMempoolMessage\x12-\n\x0cuser_message\x18\x01\
    \x20\x01(\x0b2\x08.MessageH\0R\x0buserMessageB\x11\n\x0fmempool_message\
    \"q\n\rStatusMessage\x12\x17\n\x07peer_id\x18\x01\x20\x01(\x0cR\x06peerI\
    d\x12\x1f\n\x06height\x18\x02\x20\x01(\x0b2\x07.HeightR\x06height\x12&\n\
    \nmin_height\x18\x03\x20\x01(\x0b2\x07.HeightR\tminHeight\"3\n\x10SyncVa\
    lueRequest\x12\x1f\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06heig\
    ht\"K\n\x12SyncVoteSetRequest\x12\x1f\n\x06height\x18\x01\x20\x01(\x0b2\
    \x07.HeightR\x06height\x12\x14\n\x05round\x18\x02\x20\x01(\x03R\x05round\
    \"z\n\x0bSyncRequest\x12)\n\x05value\x18\x01\x20\x01(\x0b2\x11.SyncValue\
    RequestH\0R\x05value\x120\n\x08vote_set\x18\x02\x20\x01(\x0b2\x13.SyncVo\
    teSetRequestH\0R\x07voteSetB\x0e\n\x0csync_request\"w\n\x11SyncValueResp\
    onse\x12\x1f\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06height\x12\
    \x1d\n\nfull_value\x18\x02\x20\x01(\x0cR\tfullValue\x12\"\n\x07commits\
    \x18\x03\x20\x01(\x0b2\x08.CommitsR\x07commits\"\x89\x01\n\x13SyncVoteSe\
    tResponse\x12\x1f\n\x06height\x18\x01\x20\x01(\x0b2\x07.HeightR\x06heigh\
    t\x12\x14\n\x05round\x18\x02\x20\x01(\x03R\x05round\x12\x1b\n\x05votes\
    \x18\x03\x20\x03(\x0b2\x05.VoteR\x05votes\x12\x1e\n\nsignatures\x18\x04\
    \x20\x03(\x0cR\nsignatures\"~\n\x0cSyncResponse\x12*\n\x05value\x18\x01\
    \x20\x01(\x0b2\x12.SyncValueResponseH\0R\x05value\x121\n\x08vote_set\x18\
    \x02\x20\x01(\x0b2\x14.SyncVoteSetResponseH\0R\x07voteSetB\x0f\n\rsync_r\
    esponse*&\n\x08VoteType\x12\x0b\n\x07PREVOTE\x10\0\x12\r\n\tPRECOMMIT\
    \x10\x01*T\n\x0eBlockEventType\x12\x1e\n\x1aBLOCK_EVENT_TYPE_HEARTBEAT\
    \x10\0\x12\"\n\x1eBLOCK_EVENT_TYPE_MERGE_MESSAGE\x10\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::message::file_descriptor().clone());
            deps.push(super::username_proof::file_descriptor().clone());
            deps.push(super::onchain_event::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(33);
            messages.push(Validator::generated_message_descriptor_data());
            messages.push(ValidatorSet::generated_message_descriptor_data());
            messages.push(Height::generated_message_descriptor_data());
            messages.push(ShardHash::generated_message_descriptor_data());
            messages.push(Vote::generated_message_descriptor_data());
            messages.push(CommitSignature::generated_message_descriptor_data());
            messages.push(Commits::generated_message_descriptor_data());
            messages.push(Proposal::generated_message_descriptor_data());
            messages.push(FullProposal::generated_message_descriptor_data());
            messages.push(DecidedValue::generated_message_descriptor_data());
            messages.push(ReadNodeMessage::generated_message_descriptor_data());
            messages.push(ConsensusMessage::generated_message_descriptor_data());
            messages.push(HeartbeatEventBody::generated_message_descriptor_data());
            messages.push(MergeMessageEventBody::generated_message_descriptor_data());
            messages.push(BlockEventData::generated_message_descriptor_data());
            messages.push(BlockEvent::generated_message_descriptor_data());
            messages.push(BlockHeader::generated_message_descriptor_data());
            messages.push(ShardWitness::generated_message_descriptor_data());
            messages.push(ShardChunkWitness::generated_message_descriptor_data());
            messages.push(Block::generated_message_descriptor_data());
            messages.push(ShardHeader::generated_message_descriptor_data());
            messages.push(ShardChunk::generated_message_descriptor_data());
            messages.push(Transaction::generated_message_descriptor_data());
            messages.push(FnameTransfer::generated_message_descriptor_data());
            messages.push(ValidatorMessage::generated_message_descriptor_data());
            messages.push(MempoolMessage::generated_message_descriptor_data());
            messages.push(StatusMessage::generated_message_descriptor_data());
            messages.push(SyncValueRequest::generated_message_descriptor_data());
            messages.push(SyncVoteSetRequest::generated_message_descriptor_data());
            messages.push(SyncRequest::generated_message_descriptor_data());
            messages.push(SyncValueResponse::generated_message_descriptor_data());
            messages.push(SyncVoteSetResponse::generated_message_descriptor_data());
            messages.push(SyncResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(VoteType::generated_enum_descriptor_data());
            enums.push(BlockEventType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
