#![allow(clippy::all)]
#![allow(clippy::pedantic)]
#![allow(clippy::nursery)]
#![allow(unused_lifetimes)]
#![allow(elided_lifetimes_in_paths)]
#![allow(unused_parens)]
#![allow(unknown_lints)]
#![allow(renamed_and_removed_lints)]
#![allow(warnings)]

// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gossip.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:ContactInfoBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContactInfoBody {
    // message fields
    // @@protoc_insertion_point(field:ContactInfoBody.gossip_address)
    pub gossip_address: ::std::string::String,
    // @@protoc_insertion_point(field:ContactInfoBody.peer_id)
    pub peer_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ContactInfoBody.snapchain_version)
    pub snapchain_version: ::std::string::String,
    // @@protoc_insertion_point(field:ContactInfoBody.network)
    pub network: ::protobuf::EnumOrUnknown<super::message::FarcasterNetwork>,
    // @@protoc_insertion_point(field:ContactInfoBody.timestamp)
    pub timestamp: u64,
    // @@protoc_insertion_point(field:ContactInfoBody.announce_rpc_address)
    pub announce_rpc_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ContactInfoBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContactInfoBody {
    fn default() -> &'a ContactInfoBody {
        <ContactInfoBody as ::protobuf::Message>::default_instance()
    }
}

impl ContactInfoBody {
    pub fn new() -> ContactInfoBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gossip_address",
            |m: &ContactInfoBody| { &m.gossip_address },
            |m: &mut ContactInfoBody| { &mut m.gossip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "peer_id",
            |m: &ContactInfoBody| { &m.peer_id },
            |m: &mut ContactInfoBody| { &mut m.peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "snapchain_version",
            |m: &ContactInfoBody| { &m.snapchain_version },
            |m: &mut ContactInfoBody| { &mut m.snapchain_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "network",
            |m: &ContactInfoBody| { &m.network },
            |m: &mut ContactInfoBody| { &mut m.network },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &ContactInfoBody| { &m.timestamp },
            |m: &mut ContactInfoBody| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "announce_rpc_address",
            |m: &ContactInfoBody| { &m.announce_rpc_address },
            |m: &mut ContactInfoBody| { &mut m.announce_rpc_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContactInfoBody>(
            "ContactInfoBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContactInfoBody {
    const NAME: &'static str = "ContactInfoBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gossip_address = is.read_string()?;
                },
                18 => {
                    self.peer_id = is.read_bytes()?;
                },
                26 => {
                    self.snapchain_version = is.read_string()?;
                },
                32 => {
                    self.network = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.timestamp = is.read_uint64()?;
                },
                50 => {
                    self.announce_rpc_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.gossip_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.gossip_address);
        }
        if !self.peer_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.peer_id);
        }
        if !self.snapchain_version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.snapchain_version);
        }
        if self.network != ::protobuf::EnumOrUnknown::new(super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE) {
            my_size += ::protobuf::rt::int32_size(4, self.network.value());
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.timestamp);
        }
        if !self.announce_rpc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.announce_rpc_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.gossip_address.is_empty() {
            os.write_string(1, &self.gossip_address)?;
        }
        if !self.peer_id.is_empty() {
            os.write_bytes(2, &self.peer_id)?;
        }
        if !self.snapchain_version.is_empty() {
            os.write_string(3, &self.snapchain_version)?;
        }
        if self.network != ::protobuf::EnumOrUnknown::new(super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.network))?;
        }
        if self.timestamp != 0 {
            os.write_uint64(5, self.timestamp)?;
        }
        if !self.announce_rpc_address.is_empty() {
            os.write_string(6, &self.announce_rpc_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContactInfoBody {
        ContactInfoBody::new()
    }

    fn clear(&mut self) {
        self.gossip_address.clear();
        self.peer_id.clear();
        self.snapchain_version.clear();
        self.network = ::protobuf::EnumOrUnknown::new(super::message::FarcasterNetwork::FARCASTER_NETWORK_NONE);
        self.timestamp = 0;
        self.announce_rpc_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContactInfoBody {
        static instance: ContactInfoBody = ContactInfoBody {
            gossip_address: ::std::string::String::new(),
            peer_id: ::std::vec::Vec::new(),
            snapchain_version: ::std::string::String::new(),
            network: ::protobuf::EnumOrUnknown::from_i32(0),
            timestamp: 0,
            announce_rpc_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContactInfoBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContactInfoBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContactInfoBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactInfoBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ContactInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContactInfo {
    // message fields
    // @@protoc_insertion_point(field:ContactInfo.body)
    pub body: ::protobuf::MessageField<ContactInfoBody>,
    // special fields
    // @@protoc_insertion_point(special_field:ContactInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContactInfo {
    fn default() -> &'a ContactInfo {
        <ContactInfo as ::protobuf::Message>::default_instance()
    }
}

impl ContactInfo {
    pub fn new() -> ContactInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContactInfoBody>(
            "body",
            |m: &ContactInfo| { &m.body },
            |m: &mut ContactInfo| { &mut m.body },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContactInfo>(
            "ContactInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContactInfo {
    const NAME: &'static str = "ContactInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.body)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.body.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContactInfo {
        ContactInfo::new()
    }

    fn clear(&mut self) {
        self.body.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContactInfo {
        static instance: ContactInfo = ContactInfo {
            body: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContactInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContactInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContactInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GossipMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GossipMessage {
    // message oneof groups
    pub gossip_message: ::std::option::Option<gossip_message::Gossip_message>,
    // special fields
    // @@protoc_insertion_point(special_field:GossipMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GossipMessage {
    fn default() -> &'a GossipMessage {
        <GossipMessage as ::protobuf::Message>::default_instance()
    }
}

impl GossipMessage {
    pub fn new() -> GossipMessage {
        ::std::default::Default::default()
    }

    // .ConsensusMessage consensus = 1;

    pub fn consensus(&self) -> &super::blocks::ConsensusMessage {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::Consensus(ref v)) => v,
            _ => <super::blocks::ConsensusMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_consensus(&mut self) {
        self.gossip_message = ::std::option::Option::None;
    }

    pub fn has_consensus(&self) -> bool {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::Consensus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_consensus(&mut self, v: super::blocks::ConsensusMessage) {
        self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::Consensus(v))
    }

    // Mutable pointer to the field.
    pub fn mut_consensus(&mut self) -> &mut super::blocks::ConsensusMessage {
        if let ::std::option::Option::Some(gossip_message::Gossip_message::Consensus(_)) = self.gossip_message {
        } else {
            self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::Consensus(super::blocks::ConsensusMessage::new()));
        }
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::Consensus(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_consensus(&mut self) -> super::blocks::ConsensusMessage {
        if self.has_consensus() {
            match self.gossip_message.take() {
                ::std::option::Option::Some(gossip_message::Gossip_message::Consensus(v)) => v,
                _ => panic!(),
            }
        } else {
            super::blocks::ConsensusMessage::new()
        }
    }

    // .FullProposal full_proposal = 2;

    pub fn full_proposal(&self) -> &super::blocks::FullProposal {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::FullProposal(ref v)) => v,
            _ => <super::blocks::FullProposal as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_full_proposal(&mut self) {
        self.gossip_message = ::std::option::Option::None;
    }

    pub fn has_full_proposal(&self) -> bool {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::FullProposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_full_proposal(&mut self, v: super::blocks::FullProposal) {
        self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::FullProposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_full_proposal(&mut self) -> &mut super::blocks::FullProposal {
        if let ::std::option::Option::Some(gossip_message::Gossip_message::FullProposal(_)) = self.gossip_message {
        } else {
            self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::FullProposal(super::blocks::FullProposal::new()));
        }
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::FullProposal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_full_proposal(&mut self) -> super::blocks::FullProposal {
        if self.has_full_proposal() {
            match self.gossip_message.take() {
                ::std::option::Option::Some(gossip_message::Gossip_message::FullProposal(v)) => v,
                _ => panic!(),
            }
        } else {
            super::blocks::FullProposal::new()
        }
    }

    // .MempoolMessage mempool_message = 3;

    pub fn mempool_message(&self) -> &super::blocks::MempoolMessage {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::MempoolMessage(ref v)) => v,
            _ => <super::blocks::MempoolMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mempool_message(&mut self) {
        self.gossip_message = ::std::option::Option::None;
    }

    pub fn has_mempool_message(&self) -> bool {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::MempoolMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mempool_message(&mut self, v: super::blocks::MempoolMessage) {
        self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::MempoolMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mempool_message(&mut self) -> &mut super::blocks::MempoolMessage {
        if let ::std::option::Option::Some(gossip_message::Gossip_message::MempoolMessage(_)) = self.gossip_message {
        } else {
            self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::MempoolMessage(super::blocks::MempoolMessage::new()));
        }
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::MempoolMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mempool_message(&mut self) -> super::blocks::MempoolMessage {
        if self.has_mempool_message() {
            match self.gossip_message.take() {
                ::std::option::Option::Some(gossip_message::Gossip_message::MempoolMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            super::blocks::MempoolMessage::new()
        }
    }

    // .StatusMessage status = 4;

    pub fn status(&self) -> &super::blocks::StatusMessage {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::Status(ref v)) => v,
            _ => <super::blocks::StatusMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_status(&mut self) {
        self.gossip_message = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::Status(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::blocks::StatusMessage) {
        self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::Status(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut super::blocks::StatusMessage {
        if let ::std::option::Option::Some(gossip_message::Gossip_message::Status(_)) = self.gossip_message {
        } else {
            self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::Status(super::blocks::StatusMessage::new()));
        }
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::Status(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status(&mut self) -> super::blocks::StatusMessage {
        if self.has_status() {
            match self.gossip_message.take() {
                ::std::option::Option::Some(gossip_message::Gossip_message::Status(v)) => v,
                _ => panic!(),
            }
        } else {
            super::blocks::StatusMessage::new()
        }
    }

    // .ReadNodeMessage read_node_message = 5;

    pub fn read_node_message(&self) -> &super::blocks::ReadNodeMessage {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::ReadNodeMessage(ref v)) => v,
            _ => <super::blocks::ReadNodeMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_read_node_message(&mut self) {
        self.gossip_message = ::std::option::Option::None;
    }

    pub fn has_read_node_message(&self) -> bool {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::ReadNodeMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_node_message(&mut self, v: super::blocks::ReadNodeMessage) {
        self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::ReadNodeMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_node_message(&mut self) -> &mut super::blocks::ReadNodeMessage {
        if let ::std::option::Option::Some(gossip_message::Gossip_message::ReadNodeMessage(_)) = self.gossip_message {
        } else {
            self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::ReadNodeMessage(super::blocks::ReadNodeMessage::new()));
        }
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::ReadNodeMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_node_message(&mut self) -> super::blocks::ReadNodeMessage {
        if self.has_read_node_message() {
            match self.gossip_message.take() {
                ::std::option::Option::Some(gossip_message::Gossip_message::ReadNodeMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            super::blocks::ReadNodeMessage::new()
        }
    }

    // .ContactInfo contact_info_message = 6;

    pub fn contact_info_message(&self) -> &ContactInfo {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::ContactInfoMessage(ref v)) => v,
            _ => <ContactInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_contact_info_message(&mut self) {
        self.gossip_message = ::std::option::Option::None;
    }

    pub fn has_contact_info_message(&self) -> bool {
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::ContactInfoMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contact_info_message(&mut self, v: ContactInfo) {
        self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::ContactInfoMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contact_info_message(&mut self) -> &mut ContactInfo {
        if let ::std::option::Option::Some(gossip_message::Gossip_message::ContactInfoMessage(_)) = self.gossip_message {
        } else {
            self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::ContactInfoMessage(ContactInfo::new()));
        }
        match self.gossip_message {
            ::std::option::Option::Some(gossip_message::Gossip_message::ContactInfoMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contact_info_message(&mut self) -> ContactInfo {
        if self.has_contact_info_message() {
            match self.gossip_message.take() {
                ::std::option::Option::Some(gossip_message::Gossip_message::ContactInfoMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ContactInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::blocks::ConsensusMessage>(
            "consensus",
            GossipMessage::has_consensus,
            GossipMessage::consensus,
            GossipMessage::mut_consensus,
            GossipMessage::set_consensus,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::blocks::FullProposal>(
            "full_proposal",
            GossipMessage::has_full_proposal,
            GossipMessage::full_proposal,
            GossipMessage::mut_full_proposal,
            GossipMessage::set_full_proposal,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::blocks::MempoolMessage>(
            "mempool_message",
            GossipMessage::has_mempool_message,
            GossipMessage::mempool_message,
            GossipMessage::mut_mempool_message,
            GossipMessage::set_mempool_message,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::blocks::StatusMessage>(
            "status",
            GossipMessage::has_status,
            GossipMessage::status,
            GossipMessage::mut_status,
            GossipMessage::set_status,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::blocks::ReadNodeMessage>(
            "read_node_message",
            GossipMessage::has_read_node_message,
            GossipMessage::read_node_message,
            GossipMessage::mut_read_node_message,
            GossipMessage::set_read_node_message,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ContactInfo>(
            "contact_info_message",
            GossipMessage::has_contact_info_message,
            GossipMessage::contact_info_message,
            GossipMessage::mut_contact_info_message,
            GossipMessage::set_contact_info_message,
        ));
        oneofs.push(gossip_message::Gossip_message::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GossipMessage>(
            "GossipMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GossipMessage {
    const NAME: &'static str = "GossipMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::Consensus(is.read_message()?));
                },
                18 => {
                    self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::FullProposal(is.read_message()?));
                },
                26 => {
                    self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::MempoolMessage(is.read_message()?));
                },
                34 => {
                    self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::Status(is.read_message()?));
                },
                42 => {
                    self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::ReadNodeMessage(is.read_message()?));
                },
                50 => {
                    self.gossip_message = ::std::option::Option::Some(gossip_message::Gossip_message::ContactInfoMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.gossip_message {
            match v {
                &gossip_message::Gossip_message::Consensus(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &gossip_message::Gossip_message::FullProposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &gossip_message::Gossip_message::MempoolMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &gossip_message::Gossip_message::Status(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &gossip_message::Gossip_message::ReadNodeMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &gossip_message::Gossip_message::ContactInfoMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.gossip_message {
            match v {
                &gossip_message::Gossip_message::Consensus(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &gossip_message::Gossip_message::FullProposal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &gossip_message::Gossip_message::MempoolMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &gossip_message::Gossip_message::Status(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &gossip_message::Gossip_message::ReadNodeMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &gossip_message::Gossip_message::ContactInfoMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GossipMessage {
        GossipMessage::new()
    }

    fn clear(&mut self) {
        self.gossip_message = ::std::option::Option::None;
        self.gossip_message = ::std::option::Option::None;
        self.gossip_message = ::std::option::Option::None;
        self.gossip_message = ::std::option::Option::None;
        self.gossip_message = ::std::option::Option::None;
        self.gossip_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GossipMessage {
        static instance: GossipMessage = GossipMessage {
            gossip_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GossipMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GossipMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GossipMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GossipMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GossipMessage`
pub mod gossip_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:GossipMessage.gossip_message)
    pub enum Gossip_message {
        // @@protoc_insertion_point(oneof_field:GossipMessage.consensus)
        Consensus(super::super::blocks::ConsensusMessage),
        // @@protoc_insertion_point(oneof_field:GossipMessage.full_proposal)
        FullProposal(super::super::blocks::FullProposal),
        // @@protoc_insertion_point(oneof_field:GossipMessage.mempool_message)
        MempoolMessage(super::super::blocks::MempoolMessage),
        // @@protoc_insertion_point(oneof_field:GossipMessage.status)
        Status(super::super::blocks::StatusMessage),
        // @@protoc_insertion_point(oneof_field:GossipMessage.read_node_message)
        ReadNodeMessage(super::super::blocks::ReadNodeMessage),
        // @@protoc_insertion_point(oneof_field:GossipMessage.contact_info_message)
        ContactInfoMessage(super::ContactInfo),
    }

    impl ::protobuf::Oneof for Gossip_message {
    }

    impl ::protobuf::OneofFull for Gossip_message {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::GossipMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("gossip_message").unwrap()).clone()
        }
    }

    impl Gossip_message {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Gossip_message>("gossip_message")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cgossip.proto\x1a\rmessage.proto\x1a\x0cblocks.proto\"\xfb\x01\n\
    \x0fContactInfoBody\x12%\n\x0egossip_address\x18\x01\x20\x01(\tR\rgossip\
    Address\x12\x17\n\x07peer_id\x18\x02\x20\x01(\x0cR\x06peerId\x12+\n\x11s\
    napchain_version\x18\x03\x20\x01(\tR\x10snapchainVersion\x12+\n\x07netwo\
    rk\x18\x04\x20\x01(\x0e2\x11.FarcasterNetworkR\x07network\x12\x1c\n\ttim\
    estamp\x18\x05\x20\x01(\x04R\ttimestamp\x120\n\x14announce_rpc_address\
    \x18\x06\x20\x01(\tR\x12announceRpcAddress\"3\n\x0bContactInfo\x12$\n\
    \x04body\x18\x01\x20\x01(\x0b2\x10.ContactInfoBodyR\x04body\"\xf2\x02\n\
    \rGossipMessage\x121\n\tconsensus\x18\x01\x20\x01(\x0b2\x11.ConsensusMes\
    sageH\0R\tconsensus\x124\n\rfull_proposal\x18\x02\x20\x01(\x0b2\r.FullPr\
    oposalH\0R\x0cfullProposal\x12:\n\x0fmempool_message\x18\x03\x20\x01(\
    \x0b2\x0f.MempoolMessageH\0R\x0emempoolMessage\x12(\n\x06status\x18\x04\
    \x20\x01(\x0b2\x0e.StatusMessageH\0R\x06status\x12>\n\x11read_node_messa\
    ge\x18\x05\x20\x01(\x0b2\x10.ReadNodeMessageH\0R\x0freadNodeMessage\x12@\
    \n\x14contact_info_message\x18\x06\x20\x01(\x0b2\x0c.ContactInfoH\0R\x12\
    contactInfoMessageB\x10\n\x0egossip_messageb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::message::file_descriptor().clone());
            deps.push(super::blocks::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(3);
            messages.push(ContactInfoBody::generated_message_descriptor_data());
            messages.push(ContactInfo::generated_message_descriptor_data());
            messages.push(GossipMessage::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
