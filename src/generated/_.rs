// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserNameProof {
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub name: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "5")]
    pub fid: u64,
    #[prost(enumeration = "UserNameType", tag = "6")]
    pub r#type: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserNameType {
    UsernameTypeNone = 0,
    UsernameTypeFname = 1,
    UsernameTypeEnsL1 = 2,
    UsernameTypeBasename = 3,
}
impl UserNameType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::UsernameTypeNone => "USERNAME_TYPE_NONE",
            Self::UsernameTypeFname => "USERNAME_TYPE_FNAME",
            Self::UsernameTypeEnsL1 => "USERNAME_TYPE_ENS_L1",
            Self::UsernameTypeBasename => "USERNAME_TYPE_BASENAME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USERNAME_TYPE_NONE" => Some(Self::UsernameTypeNone),
            "USERNAME_TYPE_FNAME" => Some(Self::UsernameTypeFname),
            "USERNAME_TYPE_ENS_L1" => Some(Self::UsernameTypeEnsL1),
            "USERNAME_TYPE_BASENAME" => Some(Self::UsernameTypeBasename),
            _ => None,
        }
    }
}
/// *
/// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
/// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    /// Contents of the message
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<MessageData>,
    /// Hash digest of data
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash scheme that produced the hash digest
    #[prost(enumeration = "HashScheme", tag = "3")]
    pub hash_scheme: i32,
    /// Signature of the hash digest
    #[prost(bytes = "vec", tag = "4")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// Signature scheme that produced the signature
    #[prost(enumeration = "SignatureScheme", tag = "5")]
    pub signature_scheme: i32,
    /// Public key or address of the key pair that produced the signature
    #[prost(bytes = "vec", tag = "6")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    /// MessageData serialized to bytes if using protobuf serialization other than ts-proto
    #[prost(bytes = "vec", optional, tag = "7")]
    pub data_bytes: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// *
/// A MessageData object contains properties common to all messages and wraps a body object which
/// contains properties specific to the MessageType.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageData {
    /// Type of message contained in the body
    #[prost(enumeration = "MessageType", tag = "1")]
    pub r#type: i32,
    /// Farcaster ID of the user producing the message
    #[prost(uint64, tag = "2")]
    pub fid: u64,
    /// Farcaster epoch timestamp in seconds
    #[prost(uint32, tag = "3")]
    pub timestamp: u32,
    /// Farcaster network the message is intended for
    #[prost(enumeration = "FarcasterNetwork", tag = "4")]
    pub network: i32,
    #[prost(
        oneof = "message_data::Body",
        tags = "5, 6, 7, 9, 10, 12, 14, 15, 16, 17, 18"
    )]
    pub body: ::core::option::Option<message_data::Body>,
}
/// Nested message and enum types in `MessageData`.
pub mod message_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Body {
        #[prost(message, tag = "5")]
        CastAddBody(super::CastAddBody),
        #[prost(message, tag = "6")]
        CastRemoveBody(super::CastRemoveBody),
        #[prost(message, tag = "7")]
        ReactionBody(super::ReactionBody),
        #[prost(message, tag = "9")]
        VerificationAddAddressBody(super::VerificationAddAddressBody),
        #[prost(message, tag = "10")]
        VerificationRemoveBody(super::VerificationRemoveBody),
        /// SignerAddBody signer_add_body = 11; // Deprecated
        #[prost(message, tag = "12")]
        UserDataBody(super::UserDataBody),
        /// SignerRemoveBody signer_remove_body = 13; // Deprecated
        #[prost(message, tag = "14")]
        LinkBody(super::LinkBody),
        #[prost(message, tag = "15")]
        UsernameProofBody(super::UserNameProof),
        #[prost(message, tag = "16")]
        FrameActionBody(super::FrameActionBody),
        /// Compaction messages
        #[prost(message, tag = "17")]
        LinkCompactStateBody(super::LinkCompactStateBody),
        #[prost(message, tag = "18")]
        LendStorageBody(super::LendStorageBody),
    }
}
/// * Adds metadata about a user
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserDataBody {
    /// Type of metadata
    #[prost(enumeration = "UserDataType", tag = "1")]
    pub r#type: i32,
    /// Value of the metadata
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Embed {
    #[prost(oneof = "embed::Embed", tags = "1, 2")]
    pub embed: ::core::option::Option<embed::Embed>,
}
/// Nested message and enum types in `Embed`.
pub mod embed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Embed {
        #[prost(string, tag = "1")]
        Url(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        CastId(super::CastId),
    }
}
/// * Adds a new Cast
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CastAddBody {
    /// URLs to be embedded in the cast
    #[prost(string, repeated, tag = "1")]
    pub embeds_deprecated: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Fids mentioned in the cast
    #[prost(uint64, repeated, tag = "2")]
    pub mentions: ::prost::alloc::vec::Vec<u64>,
    /// Text of the cast
    #[prost(string, tag = "4")]
    pub text: ::prost::alloc::string::String,
    /// Positions of the mentions in the text
    #[prost(uint32, repeated, tag = "5")]
    pub mentions_positions: ::prost::alloc::vec::Vec<u32>,
    /// URLs or cast ids to be embedded in the cast
    #[prost(message, repeated, tag = "6")]
    pub embeds: ::prost::alloc::vec::Vec<Embed>,
    /// Type of cast
    #[prost(enumeration = "CastType", tag = "8")]
    pub r#type: i32,
    #[prost(oneof = "cast_add_body::Parent", tags = "3, 7")]
    pub parent: ::core::option::Option<cast_add_body::Parent>,
}
/// Nested message and enum types in `CastAddBody`.
pub mod cast_add_body {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Parent {
        /// Parent cast of the cast
        #[prost(message, tag = "3")]
        ParentCastId(super::CastId),
        /// Parent URL
        #[prost(string, tag = "7")]
        ParentUrl(::prost::alloc::string::String),
    }
}
/// * Removes an existing Cast
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CastRemoveBody {
    /// Hash of the cast to remove
    #[prost(bytes = "vec", tag = "1")]
    pub target_hash: ::prost::alloc::vec::Vec<u8>,
}
/// * Identifier used to look up a Cast
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CastId {
    /// Fid of the user who created the cast
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    /// Hash of the cast
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
/// * Adds or removes a Reaction from a Cast
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactionBody {
    /// Type of reaction
    #[prost(enumeration = "ReactionType", tag = "1")]
    pub r#type: i32,
    #[prost(oneof = "reaction_body::Target", tags = "2, 3")]
    pub target: ::core::option::Option<reaction_body::Target>,
}
/// Nested message and enum types in `ReactionBody`.
pub mod reaction_body {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        /// CastId of the Cast to react to
        #[prost(message, tag = "2")]
        TargetCastId(super::CastId),
        /// URL to react to
        #[prost(string, tag = "3")]
        TargetUrl(::prost::alloc::string::String),
    }
}
/// * Adds a Verification of ownership of an Address based on Protocol
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerificationAddAddressBody {
    /// Address being verified for a given Protocol
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// Signature produced by the user's address for a given Protocol
    #[prost(bytes = "vec", tag = "2")]
    pub claim_signature: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the latest Ethereum block when the signature was produced
    #[prost(bytes = "vec", tag = "3")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    /// Type of verification. 0 = EOA, 1 = contract
    #[prost(uint32, tag = "4")]
    pub verification_type: u32,
    /// 0 for EOA verifications, 1 or 10 for contract verifications
    #[prost(uint32, tag = "5")]
    pub chain_id: u32,
    /// Protocol of the Verification
    #[prost(enumeration = "Protocol", tag = "7")]
    pub protocol: i32,
}
/// * Removes a Verification of a given protocol
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerificationRemoveBody {
    /// Address of the Verification to remove
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// Protocol of the Verification to remove
    #[prost(enumeration = "Protocol", tag = "2")]
    pub protocol: i32,
}
/// * Adds or removes a Link
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkBody {
    /// Type of link, <= 8 characters
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// User-defined timestamp that preserves original timestamp when message.data.timestamp needs to be updated for compaction
    #[prost(uint32, optional, tag = "2")]
    pub display_timestamp: ::core::option::Option<u32>,
    #[prost(oneof = "link_body::Target", tags = "3")]
    pub target: ::core::option::Option<link_body::Target>,
}
/// Nested message and enum types in `LinkBody`.
pub mod link_body {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        /// The fid the link relates to
        #[prost(uint64, tag = "3")]
        TargetFid(u64),
    }
}
/// * A Compaction message for the Link Store
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkCompactStateBody {
    /// Type of link, <= 8 characters
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(uint64, repeated, tag = "2")]
    pub target_fids: ::prost::alloc::vec::Vec<u64>,
}
/// * A Farcaster Frame action
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameActionBody {
    /// URL of the Frame triggering the action
    #[prost(bytes = "vec", tag = "1")]
    pub url: ::prost::alloc::vec::Vec<u8>,
    /// The index of the button pressed (1-4)
    #[prost(uint32, tag = "2")]
    pub button_index: u32,
    /// The cast which contained the frame url
    #[prost(message, optional, tag = "3")]
    pub cast_id: ::core::option::Option<CastId>,
    /// Text input from the user, if present
    #[prost(bytes = "vec", tag = "4")]
    pub input_text: ::prost::alloc::vec::Vec<u8>,
    /// Serialized frame state value
    #[prost(bytes = "vec", tag = "5")]
    pub state: ::prost::alloc::vec::Vec<u8>,
    /// Chain-specific transaction ID for tx actions
    #[prost(bytes = "vec", tag = "6")]
    pub transaction_id: ::prost::alloc::vec::Vec<u8>,
    /// Chain-specific address for tx actions
    #[prost(bytes = "vec", tag = "7")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LendStorageBody {
    #[prost(uint64, tag = "1")]
    pub to_fid: u64,
    #[prost(uint64, tag = "2")]
    pub num_units: u64,
    #[prost(enumeration = "StorageUnitType", tag = "3")]
    pub unit_type: i32,
}
/// * Type of hashing scheme used to produce a digest of MessageData
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashScheme {
    None = 0,
    /// Default scheme for hashing MessageData
    Blake3 = 1,
}
impl HashScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "HASH_SCHEME_NONE",
            Self::Blake3 => "HASH_SCHEME_BLAKE3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HASH_SCHEME_NONE" => Some(Self::None),
            "HASH_SCHEME_BLAKE3" => Some(Self::Blake3),
            _ => None,
        }
    }
}
/// * Type of signature scheme used to sign the Message hash
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    None = 0,
    /// Ed25519 signature (default)
    Ed25519 = 1,
    /// ECDSA signature using EIP-712 scheme
    Eip712 = 2,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SIGNATURE_SCHEME_NONE",
            Self::Ed25519 => "SIGNATURE_SCHEME_ED25519",
            Self::Eip712 => "SIGNATURE_SCHEME_EIP712",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNATURE_SCHEME_NONE" => Some(Self::None),
            "SIGNATURE_SCHEME_ED25519" => Some(Self::Ed25519),
            "SIGNATURE_SCHEME_EIP712" => Some(Self::Eip712),
            _ => None,
        }
    }
}
/// * Type of the MessageBody
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageType {
    None = 0,
    /// Add a new Cast
    CastAdd = 1,
    /// Remove an existing Cast
    CastRemove = 2,
    /// Add a Reaction to a Cast
    ReactionAdd = 3,
    /// Remove a Reaction from a Cast
    ReactionRemove = 4,
    /// Add a new Link
    LinkAdd = 5,
    /// Remove an existing Link
    LinkRemove = 6,
    /// Add a Verification of an Ethereum Address
    VerificationAddEthAddress = 7,
    /// Remove a Verification
    VerificationRemove = 8,
    ///   Deprecated
    ///   MESSAGE_TYPE_SIGNER_ADD = 9; // Add a new Ed25519 key pair that signs messages for a user
    ///   MESSAGE_TYPE_SIGNER_REMOVE = 10; // Remove an Ed25519 key pair that signs messages for a user
    ///
    /// Add metadata about a user
    UserDataAdd = 11,
    /// Add or replace a username proof
    UsernameProof = 12,
    /// A Farcaster Frame action
    FrameAction = 13,
    /// Link Compaction State Message
    LinkCompactState = 14,
    LendStorage = 15,
}
impl MessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MESSAGE_TYPE_NONE",
            Self::CastAdd => "MESSAGE_TYPE_CAST_ADD",
            Self::CastRemove => "MESSAGE_TYPE_CAST_REMOVE",
            Self::ReactionAdd => "MESSAGE_TYPE_REACTION_ADD",
            Self::ReactionRemove => "MESSAGE_TYPE_REACTION_REMOVE",
            Self::LinkAdd => "MESSAGE_TYPE_LINK_ADD",
            Self::LinkRemove => "MESSAGE_TYPE_LINK_REMOVE",
            Self::VerificationAddEthAddress => {
                "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS"
            }
            Self::VerificationRemove => "MESSAGE_TYPE_VERIFICATION_REMOVE",
            Self::UserDataAdd => "MESSAGE_TYPE_USER_DATA_ADD",
            Self::UsernameProof => "MESSAGE_TYPE_USERNAME_PROOF",
            Self::FrameAction => "MESSAGE_TYPE_FRAME_ACTION",
            Self::LinkCompactState => "MESSAGE_TYPE_LINK_COMPACT_STATE",
            Self::LendStorage => "MESSAGE_TYPE_LEND_STORAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE_TYPE_NONE" => Some(Self::None),
            "MESSAGE_TYPE_CAST_ADD" => Some(Self::CastAdd),
            "MESSAGE_TYPE_CAST_REMOVE" => Some(Self::CastRemove),
            "MESSAGE_TYPE_REACTION_ADD" => Some(Self::ReactionAdd),
            "MESSAGE_TYPE_REACTION_REMOVE" => Some(Self::ReactionRemove),
            "MESSAGE_TYPE_LINK_ADD" => Some(Self::LinkAdd),
            "MESSAGE_TYPE_LINK_REMOVE" => Some(Self::LinkRemove),
            "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS" => {
                Some(Self::VerificationAddEthAddress)
            }
            "MESSAGE_TYPE_VERIFICATION_REMOVE" => Some(Self::VerificationRemove),
            "MESSAGE_TYPE_USER_DATA_ADD" => Some(Self::UserDataAdd),
            "MESSAGE_TYPE_USERNAME_PROOF" => Some(Self::UsernameProof),
            "MESSAGE_TYPE_FRAME_ACTION" => Some(Self::FrameAction),
            "MESSAGE_TYPE_LINK_COMPACT_STATE" => Some(Self::LinkCompactState),
            "MESSAGE_TYPE_LEND_STORAGE" => Some(Self::LendStorage),
            _ => None,
        }
    }
}
/// * Farcaster network the message is intended for
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FarcasterNetwork {
    None = 0,
    /// Public primary network
    Mainnet = 1,
    /// Public test network
    Testnet = 2,
    /// Private test network
    Devnet = 3,
}
impl FarcasterNetwork {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "FARCASTER_NETWORK_NONE",
            Self::Mainnet => "FARCASTER_NETWORK_MAINNET",
            Self::Testnet => "FARCASTER_NETWORK_TESTNET",
            Self::Devnet => "FARCASTER_NETWORK_DEVNET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FARCASTER_NETWORK_NONE" => Some(Self::None),
            "FARCASTER_NETWORK_MAINNET" => Some(Self::Mainnet),
            "FARCASTER_NETWORK_TESTNET" => Some(Self::Testnet),
            "FARCASTER_NETWORK_DEVNET" => Some(Self::Devnet),
            _ => None,
        }
    }
}
/// * Type of UserData
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserDataType {
    None = 0,
    /// Profile Picture for the user
    Pfp = 1,
    /// Display Name for the user
    Display = 2,
    /// Bio for the user
    Bio = 3,
    /// URL of the user
    Url = 5,
    /// Preferred Name for the user
    Username = 6,
    /// Current location for the user
    Location = 7,
    /// Username of user on twitter
    Twitter = 8,
    /// Username of user on github
    Github = 9,
    /// Banner image for the user
    Banner = 10,
    /// Primary address for the user on Ethereum
    UserDataPrimaryAddressEthereum = 11,
    /// Primary address for the user on Solana
    UserDataPrimaryAddressSolana = 12,
    /// Profile token in CAIP-19 format
    ProfileToken = 13,
}
impl UserDataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "USER_DATA_TYPE_NONE",
            Self::Pfp => "USER_DATA_TYPE_PFP",
            Self::Display => "USER_DATA_TYPE_DISPLAY",
            Self::Bio => "USER_DATA_TYPE_BIO",
            Self::Url => "USER_DATA_TYPE_URL",
            Self::Username => "USER_DATA_TYPE_USERNAME",
            Self::Location => "USER_DATA_TYPE_LOCATION",
            Self::Twitter => "USER_DATA_TYPE_TWITTER",
            Self::Github => "USER_DATA_TYPE_GITHUB",
            Self::Banner => "USER_DATA_TYPE_BANNER",
            Self::UserDataPrimaryAddressEthereum => {
                "USER_DATA_PRIMARY_ADDRESS_ETHEREUM"
            }
            Self::UserDataPrimaryAddressSolana => {
                "USER_DATA_PRIMARY_ADDRESS_SOLANA"
            }
            Self::ProfileToken => "USER_DATA_TYPE_PROFILE_TOKEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_DATA_TYPE_NONE" => Some(Self::None),
            "USER_DATA_TYPE_PFP" => Some(Self::Pfp),
            "USER_DATA_TYPE_DISPLAY" => Some(Self::Display),
            "USER_DATA_TYPE_BIO" => Some(Self::Bio),
            "USER_DATA_TYPE_URL" => Some(Self::Url),
            "USER_DATA_TYPE_USERNAME" => Some(Self::Username),
            "USER_DATA_TYPE_LOCATION" => Some(Self::Location),
            "USER_DATA_TYPE_TWITTER" => Some(Self::Twitter),
            "USER_DATA_TYPE_GITHUB" => Some(Self::Github),
            "USER_DATA_TYPE_BANNER" => Some(Self::Banner),
            "USER_DATA_PRIMARY_ADDRESS_ETHEREUM" => {
                Some(Self::UserDataPrimaryAddressEthereum)
            }
            "USER_DATA_PRIMARY_ADDRESS_SOLANA" => {
                Some(Self::UserDataPrimaryAddressSolana)
            }
            "USER_DATA_TYPE_PROFILE_TOKEN" => Some(Self::ProfileToken),
            _ => None,
        }
    }
}
/// * Type of cast
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CastType {
    Cast = 0,
    LongCast = 1,
    TenKCast = 2,
}
impl CastType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::Cast => "CAST",
            Self::LongCast => "LONG_CAST",
            Self::TenKCast => "TEN_K_CAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CAST" => Some(Self::Cast),
            "LONG_CAST" => Some(Self::LongCast),
            "TEN_K_CAST" => Some(Self::TenKCast),
            _ => None,
        }
    }
}
/// * Type of Reaction
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReactionType {
    None = 0,
    /// Like the target cast
    Like = 1,
    /// Share target cast to the user's audience
    Recast = 2,
}
impl ReactionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "REACTION_TYPE_NONE",
            Self::Like => "REACTION_TYPE_LIKE",
            Self::Recast => "REACTION_TYPE_RECAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REACTION_TYPE_NONE" => Some(Self::None),
            "REACTION_TYPE_LIKE" => Some(Self::Like),
            "REACTION_TYPE_RECAST" => Some(Self::Recast),
            _ => None,
        }
    }
}
/// * Type of Protocol to disambiguate verification addresses
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Protocol {
    Ethereum = 0,
    Solana = 1,
}
impl Protocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ethereum => "PROTOCOL_ETHEREUM",
            Self::Solana => "PROTOCOL_SOLANA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOCOL_ETHEREUM" => Some(Self::Ethereum),
            "PROTOCOL_SOLANA" => Some(Self::Solana),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageUnitType {
    UnitTypeLegacy = 0,
    UnitType2024 = 1,
    UnitType2025 = 2,
}
impl StorageUnitType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnitTypeLegacy => "UNIT_TYPE_LEGACY",
            Self::UnitType2024 => "UNIT_TYPE_2024",
            Self::UnitType2025 => "UNIT_TYPE_2025",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNIT_TYPE_LEGACY" => Some(Self::UnitTypeLegacy),
            "UNIT_TYPE_2024" => Some(Self::UnitType2024),
            "UNIT_TYPE_2025" => Some(Self::UnitType2025),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnChainEvent {
    #[prost(enumeration = "OnChainEventType", tag = "1")]
    pub r#type: i32,
    #[prost(uint32, tag = "2")]
    pub chain_id: u32,
    #[prost(uint32, tag = "3")]
    pub block_number: u32,
    #[prost(bytes = "vec", tag = "4")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "5")]
    pub block_timestamp: u64,
    #[prost(bytes = "vec", tag = "6")]
    pub transaction_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "7")]
    pub log_index: u32,
    #[prost(uint64, tag = "8")]
    pub fid: u64,
    #[prost(uint32, tag = "13")]
    pub tx_index: u32,
    #[prost(uint32, tag = "14")]
    pub version: u32,
    #[prost(oneof = "on_chain_event::Body", tags = "9, 10, 11, 12, 15")]
    pub body: ::core::option::Option<on_chain_event::Body>,
}
/// Nested message and enum types in `OnChainEvent`.
pub mod on_chain_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Body {
        #[prost(message, tag = "9")]
        SignerEventBody(super::SignerEventBody),
        #[prost(message, tag = "10")]
        SignerMigratedEventBody(super::SignerMigratedEventBody),
        #[prost(message, tag = "11")]
        IdRegisterEventBody(super::IdRegisterEventBody),
        #[prost(message, tag = "12")]
        StorageRentEventBody(super::StorageRentEventBody),
        #[prost(message, tag = "15")]
        TierPurchaseEventBody(super::TierPurchaseBody),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TierPurchaseBody {
    #[prost(enumeration = "TierType", tag = "1")]
    pub tier_type: i32,
    #[prost(uint64, tag = "2")]
    pub for_days: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub payer: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignerEventBody {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub key_type: u32,
    #[prost(enumeration = "SignerEventType", tag = "3")]
    pub event_type: i32,
    #[prost(bytes = "vec", tag = "4")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "5")]
    pub metadata_type: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignerMigratedEventBody {
    #[prost(uint32, tag = "1")]
    pub migrated_at: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdRegisterEventBody {
    #[prost(bytes = "vec", tag = "1")]
    pub to: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "IdRegisterEventType", tag = "2")]
    pub event_type: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub from: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub recovery_address: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageRentEventBody {
    #[prost(bytes = "vec", tag = "1")]
    pub payer: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub units: u32,
    #[prost(uint32, tag = "3")]
    pub expiry: u32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OnChainEventType {
    EventTypeNone = 0,
    EventTypeSigner = 1,
    EventTypeSignerMigrated = 2,
    EventTypeIdRegister = 3,
    EventTypeStorageRent = 4,
    EventTypeTierPurchase = 5,
}
impl OnChainEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::EventTypeNone => "EVENT_TYPE_NONE",
            Self::EventTypeSigner => "EVENT_TYPE_SIGNER",
            Self::EventTypeSignerMigrated => "EVENT_TYPE_SIGNER_MIGRATED",
            Self::EventTypeIdRegister => "EVENT_TYPE_ID_REGISTER",
            Self::EventTypeStorageRent => "EVENT_TYPE_STORAGE_RENT",
            Self::EventTypeTierPurchase => "EVENT_TYPE_TIER_PURCHASE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TYPE_NONE" => Some(Self::EventTypeNone),
            "EVENT_TYPE_SIGNER" => Some(Self::EventTypeSigner),
            "EVENT_TYPE_SIGNER_MIGRATED" => Some(Self::EventTypeSignerMigrated),
            "EVENT_TYPE_ID_REGISTER" => Some(Self::EventTypeIdRegister),
            "EVENT_TYPE_STORAGE_RENT" => Some(Self::EventTypeStorageRent),
            "EVENT_TYPE_TIER_PURCHASE" => Some(Self::EventTypeTierPurchase),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TierType {
    None = 0,
    Pro = 1,
}
impl TierType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "None",
            Self::Pro => "Pro",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "None" => Some(Self::None),
            "Pro" => Some(Self::Pro),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignerEventType {
    None = 0,
    Add = 1,
    Remove = 2,
    AdminReset = 3,
}
impl SignerEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SIGNER_EVENT_TYPE_NONE",
            Self::Add => "SIGNER_EVENT_TYPE_ADD",
            Self::Remove => "SIGNER_EVENT_TYPE_REMOVE",
            Self::AdminReset => "SIGNER_EVENT_TYPE_ADMIN_RESET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNER_EVENT_TYPE_NONE" => Some(Self::None),
            "SIGNER_EVENT_TYPE_ADD" => Some(Self::Add),
            "SIGNER_EVENT_TYPE_REMOVE" => Some(Self::Remove),
            "SIGNER_EVENT_TYPE_ADMIN_RESET" => Some(Self::AdminReset),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IdRegisterEventType {
    None = 0,
    Register = 1,
    Transfer = 2,
    ChangeRecovery = 3,
}
impl IdRegisterEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ID_REGISTER_EVENT_TYPE_NONE",
            Self::Register => "ID_REGISTER_EVENT_TYPE_REGISTER",
            Self::Transfer => "ID_REGISTER_EVENT_TYPE_TRANSFER",
            Self::ChangeRecovery => {
                "ID_REGISTER_EVENT_TYPE_CHANGE_RECOVERY"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ID_REGISTER_EVENT_TYPE_NONE" => Some(Self::None),
            "ID_REGISTER_EVENT_TYPE_REGISTER" => Some(Self::Register),
            "ID_REGISTER_EVENT_TYPE_TRANSFER" => Some(Self::Transfer),
            "ID_REGISTER_EVENT_TYPE_CHANGE_RECOVERY" => Some(Self::ChangeRecovery),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Validator {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub rpc_address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub shard_index: u32,
    #[prost(uint64, tag = "5")]
    pub current_height: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorSet {
    #[prost(message, repeated, tag = "1")]
    pub validators: ::prost::alloc::vec::Vec<Validator>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Height {
    #[prost(uint32, tag = "1")]
    pub shard_index: u32,
    #[prost(uint64, tag = "2")]
    pub block_number: u64,
}
/// Uniquely identifies a hash within a shard
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardHash {
    #[prost(uint32, tag = "1")]
    pub shard_index: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vote {
    #[prost(enumeration = "VoteType", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub height: ::core::option::Option<Height>,
    #[prost(int64, tag = "3")]
    pub round: i64,
    #[prost(message, optional, tag = "4")]
    pub value: ::core::option::Option<ShardHash>,
    #[prost(bytes = "vec", tag = "5")]
    pub voter: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitSignature {
    #[prost(bytes = "vec", tag = "1")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Commits {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(int64, tag = "2")]
    pub round: i64,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<ShardHash>,
    #[prost(message, repeated, tag = "4")]
    pub signatures: ::prost::alloc::vec::Vec<CommitSignature>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Proposal {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(int64, tag = "2")]
    pub round: i64,
    #[prost(int64, tag = "3")]
    pub pol_round: i64,
    #[prost(bytes = "vec", tag = "4")]
    pub proposer: ::prost::alloc::vec::Vec<u8>,
    ///   repeated Transaction transactions = 4;  // Transactions for the shard level proposals (submitted by shard leader)
    ///   repeated ShardHeader shard_headers = 5; // shard headers for the block level proposal (submitted by the block leader)
    #[prost(message, optional, tag = "5")]
    pub value: ::core::option::Option<ShardHash>,
}
/// TODO: This probably needs a signature? Should we use ConsensusMessage?
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FullProposal {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(int64, tag = "2")]
    pub round: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub proposer: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "full_proposal::ProposedValue", tags = "4, 5")]
    pub proposed_value: ::core::option::Option<full_proposal::ProposedValue>,
}
/// Nested message and enum types in `FullProposal`.
pub mod full_proposal {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ProposedValue {
        #[prost(message, tag = "4")]
        Block(super::Block),
        #[prost(message, tag = "5")]
        Shard(super::ShardChunk),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecidedValue {
    #[prost(oneof = "decided_value::Value", tags = "2, 3")]
    pub value: ::core::option::Option<decided_value::Value>,
}
/// Nested message and enum types in `DecidedValue`.
pub mod decided_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "2")]
        Block(super::Block),
        #[prost(message, tag = "3")]
        Shard(super::ShardChunk),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadNodeMessage {
    #[prost(oneof = "read_node_message::ReadNodeMessage", tags = "1")]
    pub read_node_message: ::core::option::Option<read_node_message::ReadNodeMessage>,
}
/// Nested message and enum types in `ReadNodeMessage`.
pub mod read_node_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ReadNodeMessage {
        #[prost(message, tag = "1")]
        DecidedValue(super::DecidedValue),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusMessage {
    #[prost(bytes = "vec", tag = "3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "consensus_message::ConsensusMessage", tags = "1, 2")]
    pub consensus_message: ::core::option::Option<consensus_message::ConsensusMessage>,
}
/// Nested message and enum types in `ConsensusMessage`.
pub mod consensus_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsensusMessage {
        #[prost(message, tag = "1")]
        Vote(super::Vote),
        #[prost(message, tag = "2")]
        Proposal(super::Proposal),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatEventBody {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeMessageEventBody {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockEventData {
    #[prost(uint64, tag = "1")]
    pub seqnum: u64,
    #[prost(enumeration = "BlockEventType", tag = "2")]
    pub r#type: i32,
    #[prost(uint64, tag = "3")]
    pub block_number: u64,
    #[prost(uint64, tag = "4")]
    pub event_index: u64,
    #[prost(uint64, tag = "5")]
    pub block_timestamp: u64,
    #[prost(oneof = "block_event_data::Body", tags = "6, 7")]
    pub body: ::core::option::Option<block_event_data::Body>,
}
/// Nested message and enum types in `BlockEventData`.
pub mod block_event_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Body {
        #[prost(message, tag = "6")]
        HeartbeatEventBody(super::HeartbeatEventBody),
        #[prost(message, tag = "7")]
        MergeMessageEventBody(super::MergeMessageEventBody),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockEvent {
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<BlockEventData>,
}
/// Block types
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
    #[prost(uint32, tag = "3")]
    pub version: u32,
    #[prost(enumeration = "FarcasterNetwork", tag = "4")]
    pub chain_id: i32,
    #[prost(bytes = "vec", tag = "5")]
    pub shard_witnesses_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub parent_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "7")]
    pub state_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub events_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardWitness {
    #[prost(message, repeated, tag = "1")]
    pub shard_chunk_witnesses: ::prost::alloc::vec::Vec<ShardChunkWitness>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardChunkWitness {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(bytes = "vec", tag = "2")]
    pub shard_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub shard_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub shard_witness: ::core::option::Option<ShardWitness>,
    #[prost(message, optional, tag = "4")]
    pub commits: ::core::option::Option<Commits>,
    #[prost(message, repeated, tag = "5")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
    #[prost(message, repeated, tag = "6")]
    pub events: ::prost::alloc::vec::Vec<BlockEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardHeader {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub parent_hash: ::prost::alloc::vec::Vec<u8>,
    /// State root for the shard after applying the transactions for the height
    #[prost(bytes = "vec", tag = "4")]
    pub shard_root: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardChunk {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<ShardHeader>,
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
    #[prost(message, optional, tag = "4")]
    pub commits: ::core::option::Option<Commits>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(message, repeated, tag = "2")]
    pub user_messages: ::prost::alloc::vec::Vec<Message>,
    #[prost(message, repeated, tag = "3")]
    pub system_messages: ::prost::alloc::vec::Vec<ValidatorMessage>,
    /// State root for the account after applying the transaction for the fid
    #[prost(bytes = "vec", tag = "4")]
    pub account_root: ::prost::alloc::vec::Vec<u8>,
}
/// Fname transfers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FnameTransfer {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(uint64, tag = "2")]
    pub from_fid: u64,
    #[prost(message, optional, tag = "4")]
    pub proof: ::core::option::Option<UserNameProof>,
}
/// Validator initiated prunes/revokes etc
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorMessage {
    #[prost(message, optional, tag = "1")]
    pub on_chain_event: ::core::option::Option<OnChainEvent>,
    #[prost(message, optional, tag = "2")]
    pub fname_transfer: ::core::option::Option<FnameTransfer>,
    #[prost(message, optional, tag = "3")]
    pub block_event: ::core::option::Option<BlockEvent>,
}
/// Gossip related messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MempoolMessage {
    #[prost(oneof = "mempool_message::MempoolMessage", tags = "1")]
    pub mempool_message: ::core::option::Option<mempool_message::MempoolMessage>,
}
/// Nested message and enum types in `MempoolMessage`.
pub mod mempool_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MempoolMessage {
        #[prost(message, tag = "1")]
        UserMessage(super::Message),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusMessage {
    #[prost(bytes = "vec", tag = "1")]
    pub peer_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub height: ::core::option::Option<Height>,
    #[prost(message, optional, tag = "3")]
    pub min_height: ::core::option::Option<Height>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncValueRequest {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncVoteSetRequest {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(int64, tag = "2")]
    pub round: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncRequest {
    #[prost(oneof = "sync_request::SyncRequest", tags = "1, 2")]
    pub sync_request: ::core::option::Option<sync_request::SyncRequest>,
}
/// Nested message and enum types in `SyncRequest`.
pub mod sync_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SyncRequest {
        #[prost(message, tag = "1")]
        Value(super::SyncValueRequest),
        #[prost(message, tag = "2")]
        VoteSet(super::SyncVoteSetRequest),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncValueResponse {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(bytes = "vec", tag = "2")]
    pub full_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub commits: ::core::option::Option<Commits>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncVoteSetResponse {
    #[prost(message, optional, tag = "1")]
    pub height: ::core::option::Option<Height>,
    #[prost(int64, tag = "2")]
    pub round: i64,
    #[prost(message, repeated, tag = "3")]
    pub votes: ::prost::alloc::vec::Vec<Vote>,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncResponse {
    #[prost(oneof = "sync_response::SyncResponse", tags = "1, 2")]
    pub sync_response: ::core::option::Option<sync_response::SyncResponse>,
}
/// Nested message and enum types in `SyncResponse`.
pub mod sync_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SyncResponse {
        #[prost(message, tag = "1")]
        Value(super::SyncValueResponse),
        #[prost(message, tag = "2")]
        VoteSet(super::SyncVoteSetResponse),
    }
}
/// Consensus messages
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VoteType {
    Prevote = 0,
    Precommit = 1,
}
impl VoteType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::Prevote => "PREVOTE",
            Self::Precommit => "PRECOMMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PREVOTE" => Some(Self::Prevote),
            "PRECOMMIT" => Some(Self::Precommit),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlockEventType {
    Heartbeat = 0,
    MergeMessage = 1,
}
impl BlockEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::Heartbeat => "BLOCK_EVENT_TYPE_HEARTBEAT",
            Self::MergeMessage => "BLOCK_EVENT_TYPE_MERGE_MESSAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLOCK_EVENT_TYPE_HEARTBEAT" => Some(Self::Heartbeat),
            "BLOCK_EVENT_TYPE_MERGE_MESSAGE" => Some(Self::MergeMessage),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeMessageBody {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
    #[prost(message, repeated, tag = "2")]
    pub deleted_messages: ::prost::alloc::vec::Vec<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeFailureBody {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PruneMessageBody {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeMessageBody {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockConfirmedBody {
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
    #[prost(uint32, tag = "2")]
    pub shard_index: u32,
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
    #[prost(bytes = "vec", tag = "4")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "5")]
    pub total_events: u64,
    #[prost(map = "int32, uint64", tag = "6")]
    pub event_counts_by_type: ::std::collections::HashMap<i32, u64>,
    #[prost(uint64, tag = "7")]
    pub max_block_event_seqnum: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeOnChainEventBody {
    #[prost(message, optional, tag = "1")]
    pub on_chain_event: ::core::option::Option<OnChainEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeUserNameProofBody {
    #[prost(message, optional, tag = "1")]
    pub username_proof: ::core::option::Option<UserNameProof>,
    #[prost(message, optional, tag = "2")]
    pub deleted_username_proof: ::core::option::Option<UserNameProof>,
    #[prost(message, optional, tag = "3")]
    pub username_proof_message: ::core::option::Option<Message>,
    #[prost(message, optional, tag = "4")]
    pub deleted_username_proof_message: ::core::option::Option<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HubEvent {
    #[prost(enumeration = "HubEventType", tag = "1")]
    pub r#type: i32,
    #[prost(uint64, tag = "2")]
    pub id: u64,
    #[prost(uint64, tag = "12")]
    pub block_number: u64,
    #[prost(uint32, tag = "14")]
    pub shard_index: u32,
    #[prost(uint64, tag = "15")]
    pub timestamp: u64,
    #[prost(oneof = "hub_event::Body", tags = "3, 4, 5, 8, 11, 13, 16")]
    pub body: ::core::option::Option<hub_event::Body>,
}
/// Nested message and enum types in `HubEvent`.
pub mod hub_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Body {
        #[prost(message, tag = "3")]
        MergeMessageBody(super::MergeMessageBody),
        #[prost(message, tag = "4")]
        PruneMessageBody(super::PruneMessageBody),
        #[prost(message, tag = "5")]
        RevokeMessageBody(super::RevokeMessageBody),
        ///     Deprecated
        ///     MergeIdRegistryEventBody merge_id_registry_event_body = 6;
        ///     MergeNameRegistryEventBody merge_name_registry_event_body = 7;
        #[prost(message, tag = "8")]
        MergeUsernameProofBody(super::MergeUserNameProofBody),
        ///     Deprecated
        ///     MergeRentRegistryEventBody merge_rent_registry_event_body = 9;
        ///     MergeStorageAdminRegistryEventBody merge_storage_admin_registry_event_body = 10;
        #[prost(message, tag = "11")]
        MergeOnChainEventBody(super::MergeOnChainEventBody),
        #[prost(message, tag = "13")]
        MergeFailure(super::MergeFailureBody),
        #[prost(message, tag = "16")]
        BlockConfirmedBody(super::BlockConfirmedBody),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HubEventType {
    None = 0,
    MergeMessage = 1,
    PruneMessage = 2,
    RevokeMessage = 3,
    /// Deprecated
    ///   HUB_EVENT_TYPE_MERGE_ID_REGISTRY_EVENT = 4;
    ///   HUB_EVENT_TYPE_MERGE_NAME_REGISTRY_EVENT = 5;
    MergeUsernameProof = 6,
    /// Deprecated
    ///   HUB_EVENT_TYPE_MERGE_RENT_REGISTRY_EVENT = 7;
    ///   HUB_EVENT_TYPE_MERGE_STORAGE_ADMIN_REGISTRY_EVENT = 8;
    MergeOnChainEvent = 9,
    MergeFailure = 10,
    BlockConfirmed = 11,
}
impl HubEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "HUB_EVENT_TYPE_NONE",
            Self::MergeMessage => "HUB_EVENT_TYPE_MERGE_MESSAGE",
            Self::PruneMessage => "HUB_EVENT_TYPE_PRUNE_MESSAGE",
            Self::RevokeMessage => "HUB_EVENT_TYPE_REVOKE_MESSAGE",
            Self::MergeUsernameProof => "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF",
            Self::MergeOnChainEvent => "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT",
            Self::MergeFailure => "HUB_EVENT_TYPE_MERGE_FAILURE",
            Self::BlockConfirmed => "HUB_EVENT_TYPE_BLOCK_CONFIRMED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HUB_EVENT_TYPE_NONE" => Some(Self::None),
            "HUB_EVENT_TYPE_MERGE_MESSAGE" => Some(Self::MergeMessage),
            "HUB_EVENT_TYPE_PRUNE_MESSAGE" => Some(Self::PruneMessage),
            "HUB_EVENT_TYPE_REVOKE_MESSAGE" => Some(Self::RevokeMessage),
            "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF" => Some(Self::MergeUsernameProof),
            "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT" => Some(Self::MergeOnChainEvent),
            "HUB_EVENT_TYPE_MERGE_FAILURE" => Some(Self::MergeFailure),
            "HUB_EVENT_TYPE_BLOCK_CONFIRMED" => Some(Self::BlockConfirmed),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactInfoBody {
    #[prost(string, tag = "1")]
    pub gossip_address: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub peer_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub snapchain_version: ::prost::alloc::string::String,
    #[prost(enumeration = "FarcasterNetwork", tag = "4")]
    pub network: i32,
    #[prost(uint64, tag = "5")]
    pub timestamp: u64,
    #[prost(string, tag = "6")]
    pub announce_rpc_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactInfo {
    #[prost(message, optional, tag = "1")]
    pub body: ::core::option::Option<ContactInfoBody>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GossipMessage {
    #[prost(oneof = "gossip_message::GossipMessage", tags = "1, 2, 3, 4, 5, 6")]
    pub gossip_message: ::core::option::Option<gossip_message::GossipMessage>,
}
/// Nested message and enum types in `GossipMessage`.
pub mod gossip_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GossipMessage {
        #[prost(message, tag = "1")]
        Consensus(super::ConsensusMessage),
        #[prost(message, tag = "2")]
        FullProposal(super::FullProposal),
        #[prost(message, tag = "3")]
        MempoolMessage(super::MempoolMessage),
        #[prost(message, tag = "4")]
        Status(super::StatusMessage),
        #[prost(message, tag = "5")]
        ReadNodeMessage(super::ReadNodeMessage),
        #[prost(message, tag = "6")]
        ContactInfoMessage(super::ContactInfo),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlocksRequest {
    #[prost(uint32, tag = "1")]
    pub shard_id: u32,
    #[prost(uint64, tag = "2")]
    pub start_block_number: u64,
    #[prost(uint64, optional, tag = "3")]
    pub stop_block_number: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardChunksRequest {
    #[prost(uint32, tag = "1")]
    pub shard_id: u32,
    #[prost(uint64, tag = "2")]
    pub start_block_number: u64,
    #[prost(uint64, optional, tag = "3")]
    pub stop_block_number: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardChunksResponse {
    #[prost(message, repeated, tag = "1")]
    pub shard_chunks: ::prost::alloc::vec::Vec<ShardChunk>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRequest {
    #[prost(enumeration = "HubEventType", repeated, tag = "1")]
    pub event_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub from_id: ::core::option::Option<u64>,
    ///   optional uint32 total_shards = 3; // Not required for snapchain
    #[prost(uint32, optional, tag = "4")]
    pub shard_index: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbStats {
    #[prost(uint64, tag = "1")]
    pub num_messages: u64,
    #[prost(uint64, tag = "2")]
    pub num_fid_registrations: u64,
    #[prost(uint64, tag = "4")]
    pub approx_size: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardInfo {
    #[prost(uint32, tag = "1")]
    pub shard_id: u32,
    #[prost(uint64, tag = "2")]
    pub max_height: u64,
    #[prost(uint64, tag = "3")]
    pub num_messages: u64,
    #[prost(uint64, tag = "4")]
    pub num_fid_registrations: u64,
    #[prost(uint64, tag = "5")]
    pub approx_size: u64,
    #[prost(uint64, tag = "6")]
    pub block_delay: u64,
    #[prost(uint64, tag = "7")]
    pub mempool_size: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {}
/// Response Types for the Sync RPC Methods
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub db_stats: ::core::option::Option<DbStats>,
    #[prost(string, tag = "6")]
    pub peer_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "8")]
    pub num_shards: u32,
    #[prost(message, repeated, tag = "9")]
    pub shard_infos: ::prost::alloc::vec::Vec<ShardInfo>,
    #[prost(uint64, tag = "10")]
    pub next_engine_version_timestamp: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRequest {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(uint32, tag = "5")]
    pub shard_index: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FidRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "4")]
    pub reverse: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FidTimestampRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "4")]
    pub reverse: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "5")]
    pub start_timestamp: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub stop_timestamp: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FidsRequest {
    #[prost(uint32, optional, tag = "1")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3")]
    pub reverse: ::core::option::Option<bool>,
    #[prost(uint32, tag = "4")]
    pub shard_id: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FidsResponse {
    #[prost(uint64, repeated, tag = "1")]
    pub fids: ::prost::alloc::vec::Vec<u64>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CastsByParentRequest {
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "4")]
    pub reverse: ::core::option::Option<bool>,
    #[prost(oneof = "casts_by_parent_request::Parent", tags = "1, 5")]
    pub parent: ::core::option::Option<casts_by_parent_request::Parent>,
}
/// Nested message and enum types in `CastsByParentRequest`.
pub mod casts_by_parent_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Parent {
        #[prost(message, tag = "1")]
        ParentCastId(super::CastId),
        #[prost(string, tag = "5")]
        ParentUrl(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactionRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(enumeration = "ReactionType", tag = "2")]
    pub reaction_type: i32,
    #[prost(oneof = "reaction_request::Target", tags = "3, 4")]
    pub target: ::core::option::Option<reaction_request::Target>,
}
/// Nested message and enum types in `ReactionRequest`.
pub mod reaction_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(message, tag = "3")]
        TargetCastId(super::CastId),
        #[prost(string, tag = "4")]
        TargetUrl(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactionsByFidRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(enumeration = "ReactionType", optional, tag = "2")]
    pub reaction_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "5")]
    pub reverse: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactionsByTargetRequest {
    #[prost(enumeration = "ReactionType", optional, tag = "2")]
    pub reaction_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "5")]
    pub reverse: ::core::option::Option<bool>,
    #[prost(oneof = "reactions_by_target_request::Target", tags = "1, 6")]
    pub target: ::core::option::Option<reactions_by_target_request::Target>,
}
/// Nested message and enum types in `ReactionsByTargetRequest`.
pub mod reactions_by_target_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(message, tag = "1")]
        TargetCastId(super::CastId),
        #[prost(string, tag = "6")]
        TargetUrl(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserDataRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(enumeration = "UserDataType", tag = "2")]
    pub user_data_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnChainEventRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(enumeration = "OnChainEventType", tag = "2")]
    pub event_type: i32,
    #[prost(uint32, optional, tag = "3")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "5")]
    pub reverse: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnChainEventResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<OnChainEvent>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TierDetails {
    #[prost(enumeration = "TierType", tag = "1")]
    pub tier_type: i32,
    #[prost(uint64, tag = "2")]
    pub expires_at: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageLimitsResponse {
    #[prost(message, repeated, tag = "1")]
    pub limits: ::prost::alloc::vec::Vec<StorageLimit>,
    #[prost(uint32, tag = "2")]
    pub units: u32,
    #[prost(message, repeated, tag = "3")]
    pub unit_details: ::prost::alloc::vec::Vec<StorageUnitDetails>,
    #[prost(message, repeated, tag = "4")]
    pub tier_subscriptions: ::prost::alloc::vec::Vec<TierDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageUnitDetails {
    #[prost(enumeration = "StorageUnitType", tag = "1")]
    pub unit_type: i32,
    #[prost(uint32, tag = "2")]
    pub unit_size: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageLimit {
    #[prost(enumeration = "StoreType", tag = "1")]
    pub store_type: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(uint64, tag = "4")]
    pub used: u64,
    #[prost(uint64, tag = "5")]
    pub earliest_timestamp: u64,
    #[prost(bytes = "vec", tag = "6")]
    pub earliest_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsernameProofRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub name: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsernameProofsResponse {
    #[prost(message, repeated, tag = "1")]
    pub proofs: ::prost::alloc::vec::Vec<UserNameProof>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationResponse {
    #[prost(bool, tag = "1")]
    pub valid: bool,
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerificationRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignerRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(string, tag = "2")]
    pub link_type: ::prost::alloc::string::String,
    #[prost(oneof = "link_request::Target", tags = "3")]
    pub target: ::core::option::Option<link_request::Target>,
}
/// Nested message and enum types in `LinkRequest`.
pub mod link_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(uint64, tag = "3")]
        TargetFid(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinksByFidRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(string, optional, tag = "2")]
    pub link_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "5")]
    pub reverse: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinksByTargetRequest {
    #[prost(string, optional, tag = "2")]
    pub link_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "5")]
    pub reverse: ::core::option::Option<bool>,
    #[prost(oneof = "links_by_target_request::Target", tags = "1")]
    pub target: ::core::option::Option<links_by_target_request::Target>,
}
/// Nested message and enum types in `LinksByTargetRequest`.
pub mod links_by_target_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(uint64, tag = "1")]
        TargetFid(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdRegistryEventByAddressRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitBulkMessagesRequest {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageError {
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub err_code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkMessageResponse {
    #[prost(oneof = "bulk_message_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<bulk_message_response::Response>,
}
/// Nested message and enum types in `BulkMessageResponse`.
pub mod bulk_message_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Message(super::Message),
        #[prost(message, tag = "2")]
        MessageError(super::MessageError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitBulkMessagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<BulkMessageResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrieNodeMetadataRequest {
    #[prost(uint32, tag = "1")]
    pub shard_id: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub prefix: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrieNodeMetadataResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub prefix: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub num_messages: u64,
    #[prost(string, tag = "3")]
    pub hash: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub children: ::prost::alloc::vec::Vec<TrieNodeMetadataResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventsRequest {
    #[prost(uint64, tag = "1")]
    pub start_id: u64,
    #[prost(uint32, optional, tag = "2")]
    pub shard_index: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub stop_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub page_size: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "6")]
    pub reverse: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<HubEvent>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FidAddressTypeRequest {
    #[prost(uint64, tag = "1")]
    pub fid: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FidAddressTypeResponse {
    #[prost(bool, tag = "1")]
    pub is_custody: bool,
    #[prost(bool, tag = "2")]
    pub is_auth: bool,
    #[prost(bool, tag = "3")]
    pub is_verified: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectedPeersRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectedPeersResponse {
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<ContactInfoBody>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StoreType {
    None = 0,
    Casts = 1,
    Links = 2,
    Reactions = 3,
    UserData = 4,
    Verifications = 5,
    UsernameProofs = 6,
    StorageLends = 7,
}
impl StoreType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    #[must_use] 
    pub const fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "STORE_TYPE_NONE",
            Self::Casts => "STORE_TYPE_CASTS",
            Self::Links => "STORE_TYPE_LINKS",
            Self::Reactions => "STORE_TYPE_REACTIONS",
            Self::UserData => "STORE_TYPE_USER_DATA",
            Self::Verifications => "STORE_TYPE_VERIFICATIONS",
            Self::UsernameProofs => "STORE_TYPE_USERNAME_PROOFS",
            Self::StorageLends => "STORE_TYPE_STORAGE_LENDS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    #[must_use] 
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORE_TYPE_NONE" => Some(Self::None),
            "STORE_TYPE_CASTS" => Some(Self::Casts),
            "STORE_TYPE_LINKS" => Some(Self::Links),
            "STORE_TYPE_REACTIONS" => Some(Self::Reactions),
            "STORE_TYPE_USER_DATA" => Some(Self::UserData),
            "STORE_TYPE_VERIFICATIONS" => Some(Self::Verifications),
            "STORE_TYPE_USERNAME_PROOFS" => Some(Self::UsernameProofs),
            "STORE_TYPE_STORAGE_LENDS" => Some(Self::StorageLends),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod hub_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::{StdError, Body, Bytes, http, InterceptedService, CompressionEncoding, GrpcMethod};
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct HubServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl HubServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> HubServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HubServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            HubServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Write API
        pub async fn submit_message(
            &mut self,
            request: impl tonic::IntoRequest<super::Message>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/SubmitMessage");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "SubmitMessage"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_bulk_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitBulkMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitBulkMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/SubmitBulkMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "SubmitBulkMessages"));
            self.inner.unary(req, path, codec).await
        }
        /// Validation Methods
        pub async fn validate_message(
            &mut self,
            request: impl tonic::IntoRequest<super::Message>,
        ) -> std::result::Result<
            tonic::Response<super::ValidationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/ValidateMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "ValidateMessage"));
            self.inner.unary(req, path, codec).await
        }
        /// Block API
        pub async fn get_blocks(
            &mut self,
            request: impl tonic::IntoRequest<super::BlocksRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Block>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetBlocks");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetBlocks"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_shard_chunks(
            &mut self,
            request: impl tonic::IntoRequest<super::ShardChunksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShardChunksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetShardChunks",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetShardChunks"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetInfo");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_fids(
            &mut self,
            request: impl tonic::IntoRequest<super::FidsRequest>,
        ) -> std::result::Result<tonic::Response<super::FidsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetFids");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetFids"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_connected_peers(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectedPeersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConnectedPeersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetConnectedPeers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetConnectedPeers"));
            self.inner.unary(req, path, codec).await
        }
        /// Events
        pub async fn subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HubEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/Subscribe");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "Subscribe"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_event(
            &mut self,
            request: impl tonic::IntoRequest<super::EventRequest>,
        ) -> std::result::Result<tonic::Response<super::HubEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetEvent");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetEvent"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_events(
            &mut self,
            request: impl tonic::IntoRequest<super::EventsRequest>,
        ) -> std::result::Result<tonic::Response<super::EventsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetEvents");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetEvents"));
            self.inner.unary(req, path, codec).await
        }
        /// Casts
        pub async fn get_cast(
            &mut self,
            request: impl tonic::IntoRequest<super::CastId>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetCast");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetCast"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_casts_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetCastsByFid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetCastsByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_casts_by_parent(
            &mut self,
            request: impl tonic::IntoRequest<super::CastsByParentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetCastsByParent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetCastsByParent"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_casts_by_mention(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetCastsByMention",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetCastsByMention"));
            self.inner.unary(req, path, codec).await
        }
        /// Reactions
        pub async fn get_reaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ReactionRequest>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetReaction");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetReaction"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_reactions_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::ReactionsByFidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetReactionsByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetReactionsByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_reactions_by_cast(
            &mut self,
            request: impl tonic::IntoRequest<super::ReactionsByTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetReactionsByCast",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetReactionsByCast"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_reactions_by_target(
            &mut self,
            request: impl tonic::IntoRequest<super::ReactionsByTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetReactionsByTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetReactionsByTarget"));
            self.inner.unary(req, path, codec).await
        }
        /// User Data
        pub async fn get_user_data(
            &mut self,
            request: impl tonic::IntoRequest<super::UserDataRequest>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetUserData");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetUserData"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_user_data_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetUserDataByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetUserDataByFid"));
            self.inner.unary(req, path, codec).await
        }
        /// Username Proof
        pub async fn get_username_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::UsernameProofRequest>,
        ) -> std::result::Result<tonic::Response<super::UserNameProof>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetUsernameProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetUsernameProof"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_user_name_proofs_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UsernameProofsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetUserNameProofsByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetUserNameProofsByFid"));
            self.inner.unary(req, path, codec).await
        }
        /// Verifications
        pub async fn get_verification(
            &mut self,
            request: impl tonic::IntoRequest<super::VerificationRequest>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetVerification",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetVerification"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_verifications_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetVerificationsByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetVerificationsByFid"));
            self.inner.unary(req, path, codec).await
        }
        /// OnChain Events
        pub async fn get_on_chain_signer(
            &mut self,
            request: impl tonic::IntoRequest<super::SignerRequest>,
        ) -> std::result::Result<tonic::Response<super::OnChainEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetOnChainSigner",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetOnChainSigner"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_on_chain_signers_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OnChainEventResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetOnChainSignersByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetOnChainSignersByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_on_chain_events(
            &mut self,
            request: impl tonic::IntoRequest<super::OnChainEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OnChainEventResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetOnChainEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetOnChainEvents"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_id_registry_on_chain_event(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<tonic::Response<super::OnChainEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetIdRegistryOnChainEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetIdRegistryOnChainEvent"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_id_registry_on_chain_event_by_address(
            &mut self,
            request: impl tonic::IntoRequest<super::IdRegistryEventByAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::OnChainEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetIdRegistryOnChainEventByAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("HubService", "GetIdRegistryOnChainEventByAddress"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_current_storage_limits_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StorageLimitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetCurrentStorageLimitsByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetCurrentStorageLimitsByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_fid_address_type(
            &mut self,
            request: impl tonic::IntoRequest<super::FidAddressTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FidAddressTypeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetFidAddressType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetFidAddressType"));
            self.inner.unary(req, path, codec).await
        }
        /// Links
        pub async fn get_link(
            &mut self,
            request: impl tonic::IntoRequest<super::LinkRequest>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetLink");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetLink"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_links_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::LinksByFidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/HubService/GetLinksByFid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("HubService", "GetLinksByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_links_by_target(
            &mut self,
            request: impl tonic::IntoRequest<super::LinksByTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetLinksByTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetLinksByTarget"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_link_compact_state_message_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetLinkCompactStateMessageByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("HubService", "GetLinkCompactStateMessageByFid"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bulk Methods
        pub async fn get_all_cast_messages_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetAllCastMessagesByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetAllCastMessagesByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_all_reaction_messages_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetAllReactionMessagesByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetAllReactionMessagesByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_all_verification_messages_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetAllVerificationMessagesByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("HubService", "GetAllVerificationMessagesByFid"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_all_user_data_messages_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetAllUserDataMessagesByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetAllUserDataMessagesByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_all_link_messages_by_fid(
            &mut self,
            request: impl tonic::IntoRequest<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetAllLinkMessagesByFid",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetAllLinkMessagesByFid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_trie_metadata_by_prefix(
            &mut self,
            request: impl tonic::IntoRequest<super::TrieNodeMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TrieNodeMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/HubService/GetTrieMetadataByPrefix",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("HubService", "GetTrieMetadataByPrefix"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod hub_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::{async_trait, EnabledCompressionEncodings, Arc, InterceptedService, CompressionEncoding, http, Body, StdError, BoxFuture, Context, Poll, empty_body};
    /// Generated trait containing gRPC methods that should be implemented for use with HubServiceServer.
    #[async_trait]
    pub trait HubService: Send + Sync + 'static {
        /// Write API
        async fn submit_message(
            &self,
            request: tonic::Request<super::Message>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status>;
        async fn submit_bulk_messages(
            &self,
            request: tonic::Request<super::SubmitBulkMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitBulkMessagesResponse>,
            tonic::Status,
        >;
        /// Validation Methods
        async fn validate_message(
            &self,
            request: tonic::Request<super::Message>,
        ) -> std::result::Result<
            tonic::Response<super::ValidationResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetBlocks method.
        type GetBlocksStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Block, tonic::Status>,
            >
            + Send
            + 'static;
        /// Block API
        async fn get_blocks(
            &self,
            request: tonic::Request<super::BlocksRequest>,
        ) -> std::result::Result<tonic::Response<Self::GetBlocksStream>, tonic::Status>;
        async fn get_shard_chunks(
            &self,
            request: tonic::Request<super::ShardChunksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShardChunksResponse>,
            tonic::Status,
        >;
        async fn get_info(
            &self,
            request: tonic::Request<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status>;
        async fn get_fids(
            &self,
            request: tonic::Request<super::FidsRequest>,
        ) -> std::result::Result<tonic::Response<super::FidsResponse>, tonic::Status>;
        async fn get_connected_peers(
            &self,
            request: tonic::Request<super::GetConnectedPeersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConnectedPeersResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the Subscribe method.
        type SubscribeStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::HubEvent, tonic::Status>,
            >
            + Send
            + 'static;
        /// Events
        async fn subscribe(
            &self,
            request: tonic::Request<super::SubscribeRequest>,
        ) -> std::result::Result<tonic::Response<Self::SubscribeStream>, tonic::Status>;
        async fn get_event(
            &self,
            request: tonic::Request<super::EventRequest>,
        ) -> std::result::Result<tonic::Response<super::HubEvent>, tonic::Status>;
        async fn get_events(
            &self,
            request: tonic::Request<super::EventsRequest>,
        ) -> std::result::Result<tonic::Response<super::EventsResponse>, tonic::Status>;
        /// Casts
        async fn get_cast(
            &self,
            request: tonic::Request<super::CastId>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status>;
        async fn get_casts_by_fid(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_casts_by_parent(
            &self,
            request: tonic::Request<super::CastsByParentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_casts_by_mention(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        /// Reactions
        async fn get_reaction(
            &self,
            request: tonic::Request<super::ReactionRequest>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status>;
        async fn get_reactions_by_fid(
            &self,
            request: tonic::Request<super::ReactionsByFidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_reactions_by_cast(
            &self,
            request: tonic::Request<super::ReactionsByTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_reactions_by_target(
            &self,
            request: tonic::Request<super::ReactionsByTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        /// User Data
        async fn get_user_data(
            &self,
            request: tonic::Request<super::UserDataRequest>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status>;
        async fn get_user_data_by_fid(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        /// Username Proof
        async fn get_username_proof(
            &self,
            request: tonic::Request<super::UsernameProofRequest>,
        ) -> std::result::Result<tonic::Response<super::UserNameProof>, tonic::Status>;
        async fn get_user_name_proofs_by_fid(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UsernameProofsResponse>,
            tonic::Status,
        >;
        /// Verifications
        async fn get_verification(
            &self,
            request: tonic::Request<super::VerificationRequest>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status>;
        async fn get_verifications_by_fid(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        /// OnChain Events
        async fn get_on_chain_signer(
            &self,
            request: tonic::Request<super::SignerRequest>,
        ) -> std::result::Result<tonic::Response<super::OnChainEvent>, tonic::Status>;
        async fn get_on_chain_signers_by_fid(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OnChainEventResponse>,
            tonic::Status,
        >;
        async fn get_on_chain_events(
            &self,
            request: tonic::Request<super::OnChainEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OnChainEventResponse>,
            tonic::Status,
        >;
        async fn get_id_registry_on_chain_event(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<tonic::Response<super::OnChainEvent>, tonic::Status>;
        async fn get_id_registry_on_chain_event_by_address(
            &self,
            request: tonic::Request<super::IdRegistryEventByAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::OnChainEvent>, tonic::Status>;
        async fn get_current_storage_limits_by_fid(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StorageLimitsResponse>,
            tonic::Status,
        >;
        async fn get_fid_address_type(
            &self,
            request: tonic::Request<super::FidAddressTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FidAddressTypeResponse>,
            tonic::Status,
        >;
        /// Links
        async fn get_link(
            &self,
            request: tonic::Request<super::LinkRequest>,
        ) -> std::result::Result<tonic::Response<super::Message>, tonic::Status>;
        async fn get_links_by_fid(
            &self,
            request: tonic::Request<super::LinksByFidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_links_by_target(
            &self,
            request: tonic::Request<super::LinksByTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_link_compact_state_message_by_fid(
            &self,
            request: tonic::Request<super::FidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        /// Bulk Methods
        async fn get_all_cast_messages_by_fid(
            &self,
            request: tonic::Request<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_all_reaction_messages_by_fid(
            &self,
            request: tonic::Request<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_all_verification_messages_by_fid(
            &self,
            request: tonic::Request<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_all_user_data_messages_by_fid(
            &self,
            request: tonic::Request<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_all_link_messages_by_fid(
            &self,
            request: tonic::Request<super::FidTimestampRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MessagesResponse>,
            tonic::Status,
        >;
        async fn get_trie_metadata_by_prefix(
            &self,
            request: tonic::Request<super::TrieNodeMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TrieNodeMetadataResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct HubServiceServer<T: HubService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: HubService> HubServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub const fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub const fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for HubServiceServer<T>
    where
        T: HubService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/HubService/SubmitMessage" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitMessageSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::Message>
                    for SubmitMessageSvc<T> {
                        type Response = super::Message;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Message>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::submit_message(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SubmitMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/SubmitBulkMessages" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitBulkMessagesSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::SubmitBulkMessagesRequest>
                    for SubmitBulkMessagesSvc<T> {
                        type Response = super::SubmitBulkMessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitBulkMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::submit_bulk_messages(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SubmitBulkMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/ValidateMessage" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateMessageSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::Message>
                    for ValidateMessageSvc<T> {
                        type Response = super::ValidationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Message>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::validate_message(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ValidateMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetBlocks" => {
                    #[allow(non_camel_case_types)]
                    struct GetBlocksSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::ServerStreamingService<super::BlocksRequest>
                    for GetBlocksSvc<T> {
                        type Response = super::Block;
                        type ResponseStream = T::GetBlocksStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BlocksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_blocks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetBlocksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetShardChunks" => {
                    #[allow(non_camel_case_types)]
                    struct GetShardChunksSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::ShardChunksRequest>
                    for GetShardChunksSvc<T> {
                        type Response = super::ShardChunksResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShardChunksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_shard_chunks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetShardChunksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetInfoSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::GetInfoRequest>
                    for GetInfoSvc<T> {
                        type Response = super::GetInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetFids" => {
                    #[allow(non_camel_case_types)]
                    struct GetFidsSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidsRequest>
                    for GetFidsSvc<T> {
                        type Response = super::FidsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_fids(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetFidsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetConnectedPeers" => {
                    #[allow(non_camel_case_types)]
                    struct GetConnectedPeersSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::GetConnectedPeersRequest>
                    for GetConnectedPeersSvc<T> {
                        type Response = super::GetConnectedPeersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConnectedPeersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_connected_peers(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetConnectedPeersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/Subscribe" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::ServerStreamingService<super::SubscribeRequest>
                    for SubscribeSvc<T> {
                        type Response = super::HubEvent;
                        type ResponseStream = T::SubscribeStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::subscribe(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SubscribeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetEvent" => {
                    #[allow(non_camel_case_types)]
                    struct GetEventSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::EventRequest>
                    for GetEventSvc<T> {
                        type Response = super::HubEvent;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EventRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_event(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetEventSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetEvents" => {
                    #[allow(non_camel_case_types)]
                    struct GetEventsSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::EventsRequest>
                    for GetEventsSvc<T> {
                        type Response = super::EventsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EventsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_events(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetEventsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetCast" => {
                    #[allow(non_camel_case_types)]
                    struct GetCastSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::CastId>
                    for GetCastSvc<T> {
                        type Response = super::Message;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CastId>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_cast(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetCastSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetCastsByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetCastsByFidSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetCastsByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_casts_by_fid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetCastsByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetCastsByParent" => {
                    #[allow(non_camel_case_types)]
                    struct GetCastsByParentSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::CastsByParentRequest>
                    for GetCastsByParentSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CastsByParentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_casts_by_parent(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetCastsByParentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetCastsByMention" => {
                    #[allow(non_camel_case_types)]
                    struct GetCastsByMentionSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetCastsByMentionSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_casts_by_mention(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetCastsByMentionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetReaction" => {
                    #[allow(non_camel_case_types)]
                    struct GetReactionSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::ReactionRequest>
                    for GetReactionSvc<T> {
                        type Response = super::Message;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_reaction(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetReactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetReactionsByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetReactionsByFidSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::ReactionsByFidRequest>
                    for GetReactionsByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReactionsByFidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_reactions_by_fid(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetReactionsByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetReactionsByCast" => {
                    #[allow(non_camel_case_types)]
                    struct GetReactionsByCastSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::ReactionsByTargetRequest>
                    for GetReactionsByCastSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReactionsByTargetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_reactions_by_cast(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetReactionsByCastSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetReactionsByTarget" => {
                    #[allow(non_camel_case_types)]
                    struct GetReactionsByTargetSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::ReactionsByTargetRequest>
                    for GetReactionsByTargetSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReactionsByTargetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_reactions_by_target(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetReactionsByTargetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetUserData" => {
                    #[allow(non_camel_case_types)]
                    struct GetUserDataSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::UserDataRequest>
                    for GetUserDataSvc<T> {
                        type Response = super::Message;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UserDataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_user_data(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetUserDataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetUserDataByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetUserDataByFidSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetUserDataByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_user_data_by_fid(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetUserDataByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetUsernameProof" => {
                    #[allow(non_camel_case_types)]
                    struct GetUsernameProofSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::UsernameProofRequest>
                    for GetUsernameProofSvc<T> {
                        type Response = super::UserNameProof;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UsernameProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_username_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetUsernameProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetUserNameProofsByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetUserNameProofsByFidSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetUserNameProofsByFidSvc<T> {
                        type Response = super::UsernameProofsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_user_name_proofs_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetUserNameProofsByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetVerification" => {
                    #[allow(non_camel_case_types)]
                    struct GetVerificationSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::VerificationRequest>
                    for GetVerificationSvc<T> {
                        type Response = super::Message;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerificationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_verification(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetVerificationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetVerificationsByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetVerificationsByFidSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetVerificationsByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_verifications_by_fid(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetVerificationsByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetOnChainSigner" => {
                    #[allow(non_camel_case_types)]
                    struct GetOnChainSignerSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::SignerRequest>
                    for GetOnChainSignerSvc<T> {
                        type Response = super::OnChainEvent;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_on_chain_signer(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetOnChainSignerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetOnChainSignersByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetOnChainSignersByFidSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetOnChainSignersByFidSvc<T> {
                        type Response = super::OnChainEventResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_on_chain_signers_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetOnChainSignersByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetOnChainEvents" => {
                    #[allow(non_camel_case_types)]
                    struct GetOnChainEventsSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::OnChainEventRequest>
                    for GetOnChainEventsSvc<T> {
                        type Response = super::OnChainEventResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OnChainEventRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_on_chain_events(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetOnChainEventsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetIdRegistryOnChainEvent" => {
                    #[allow(non_camel_case_types)]
                    struct GetIdRegistryOnChainEventSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetIdRegistryOnChainEventSvc<T> {
                        type Response = super::OnChainEvent;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_id_registry_on_chain_event(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetIdRegistryOnChainEventSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetIdRegistryOnChainEventByAddress" => {
                    #[allow(non_camel_case_types)]
                    struct GetIdRegistryOnChainEventByAddressSvc<T: HubService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::IdRegistryEventByAddressRequest>
                    for GetIdRegistryOnChainEventByAddressSvc<T> {
                        type Response = super::OnChainEvent;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::IdRegistryEventByAddressRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_id_registry_on_chain_event_by_address(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetIdRegistryOnChainEventByAddressSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetCurrentStorageLimitsByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetCurrentStorageLimitsByFidSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetCurrentStorageLimitsByFidSvc<T> {
                        type Response = super::StorageLimitsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_current_storage_limits_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetCurrentStorageLimitsByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetFidAddressType" => {
                    #[allow(non_camel_case_types)]
                    struct GetFidAddressTypeSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::FidAddressTypeRequest>
                    for GetFidAddressTypeSvc<T> {
                        type Response = super::FidAddressTypeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidAddressTypeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_fid_address_type(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetFidAddressTypeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetLink" => {
                    #[allow(non_camel_case_types)]
                    struct GetLinkSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::LinkRequest>
                    for GetLinkSvc<T> {
                        type Response = super::Message;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_link(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetLinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetLinksByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetLinksByFidSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::LinksByFidRequest>
                    for GetLinksByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinksByFidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_links_by_fid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetLinksByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetLinksByTarget" => {
                    #[allow(non_camel_case_types)]
                    struct GetLinksByTargetSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::LinksByTargetRequest>
                    for GetLinksByTargetSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinksByTargetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_links_by_target(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetLinksByTargetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetLinkCompactStateMessageByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetLinkCompactStateMessageByFidSvc<T: HubService>(pub Arc<T>);
                    impl<T: HubService> tonic::server::UnaryService<super::FidRequest>
                    for GetLinkCompactStateMessageByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_link_compact_state_message_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetLinkCompactStateMessageByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetAllCastMessagesByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllCastMessagesByFidSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::FidTimestampRequest>
                    for GetAllCastMessagesByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidTimestampRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_all_cast_messages_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetAllCastMessagesByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetAllReactionMessagesByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllReactionMessagesByFidSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::FidTimestampRequest>
                    for GetAllReactionMessagesByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidTimestampRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_all_reaction_messages_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetAllReactionMessagesByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetAllVerificationMessagesByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllVerificationMessagesByFidSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::FidTimestampRequest>
                    for GetAllVerificationMessagesByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidTimestampRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_all_verification_messages_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetAllVerificationMessagesByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetAllUserDataMessagesByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllUserDataMessagesByFidSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::FidTimestampRequest>
                    for GetAllUserDataMessagesByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidTimestampRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_all_user_data_messages_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetAllUserDataMessagesByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetAllLinkMessagesByFid" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllLinkMessagesByFidSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::FidTimestampRequest>
                    for GetAllLinkMessagesByFidSvc<T> {
                        type Response = super::MessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FidTimestampRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_all_link_messages_by_fid(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetAllLinkMessagesByFidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/HubService/GetTrieMetadataByPrefix" => {
                    #[allow(non_camel_case_types)]
                    struct GetTrieMetadataByPrefixSvc<T: HubService>(pub Arc<T>);
                    impl<
                        T: HubService,
                    > tonic::server::UnaryService<super::TrieNodeMetadataRequest>
                    for GetTrieMetadataByPrefixSvc<T> {
                        type Response = super::TrieNodeMetadataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TrieNodeMetadataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HubService>::get_trie_metadata_by_prefix(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetTrieMetadataByPrefixSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: HubService> Clone for HubServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: HubService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: HubService> tonic::server::NamedService for HubServiceServer<T> {
        const NAME: &'static str = "HubService";
    }
}
