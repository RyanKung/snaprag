#![cfg_attr(rustfmt, rustfmt::skip)]
#![allow(clippy::all)]
#![allow(clippy::pedantic)]
#![allow(clippy::nursery)]
#![allow(unused_lifetimes)]
#![allow(elided_lifetimes_in_paths)]
#![allow(unused_parens)]
#![allow(unknown_lints)]
#![allow(renamed_and_removed_lints)]
#![allow(warnings)]

// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `replication.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:GetShardSnapshotMetadataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetShardSnapshotMetadataRequest {
    // message fields
    // @@protoc_insertion_point(field:GetShardSnapshotMetadataRequest.shard_id)
    pub shard_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:GetShardSnapshotMetadataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetShardSnapshotMetadataRequest {
    fn default() -> &'a GetShardSnapshotMetadataRequest {
        <GetShardSnapshotMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetShardSnapshotMetadataRequest {
    pub fn new() -> GetShardSnapshotMetadataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &GetShardSnapshotMetadataRequest| { &m.shard_id },
            |m: &mut GetShardSnapshotMetadataRequest| { &mut m.shard_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetShardSnapshotMetadataRequest>(
            "GetShardSnapshotMetadataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetShardSnapshotMetadataRequest {
    const NAME: &'static str = "GetShardSnapshotMetadataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetShardSnapshotMetadataRequest {
        GetShardSnapshotMetadataRequest::new()
    }

    fn clear(&mut self) {
        self.shard_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetShardSnapshotMetadataRequest {
        static instance: GetShardSnapshotMetadataRequest = GetShardSnapshotMetadataRequest {
            shard_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetShardSnapshotMetadataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetShardSnapshotMetadataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetShardSnapshotMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetShardSnapshotMetadataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardSnapshotMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardSnapshotMetadata {
    // message fields
    // @@protoc_insertion_point(field:ShardSnapshotMetadata.shard_id)
    pub shard_id: u32,
    // @@protoc_insertion_point(field:ShardSnapshotMetadata.height)
    pub height: u64,
    // @@protoc_insertion_point(field:ShardSnapshotMetadata.timestamp)
    pub timestamp: u64,
    // @@protoc_insertion_point(field:ShardSnapshotMetadata.shard_chunk)
    pub shard_chunk: ::protobuf::MessageField<super::blocks::ShardChunk>,
    // @@protoc_insertion_point(field:ShardSnapshotMetadata.block)
    pub block: ::protobuf::MessageField<super::blocks::Block>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardSnapshotMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardSnapshotMetadata {
    fn default() -> &'a ShardSnapshotMetadata {
        <ShardSnapshotMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ShardSnapshotMetadata {
    pub fn new() -> ShardSnapshotMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &ShardSnapshotMetadata| { &m.shard_id },
            |m: &mut ShardSnapshotMetadata| { &mut m.shard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &ShardSnapshotMetadata| { &m.height },
            |m: &mut ShardSnapshotMetadata| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &ShardSnapshotMetadata| { &m.timestamp },
            |m: &mut ShardSnapshotMetadata| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::blocks::ShardChunk>(
            "shard_chunk",
            |m: &ShardSnapshotMetadata| { &m.shard_chunk },
            |m: &mut ShardSnapshotMetadata| { &mut m.shard_chunk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::blocks::Block>(
            "block",
            |m: &ShardSnapshotMetadata| { &m.block },
            |m: &mut ShardSnapshotMetadata| { &mut m.block },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardSnapshotMetadata>(
            "ShardSnapshotMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardSnapshotMetadata {
    const NAME: &'static str = "ShardSnapshotMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_id = is.read_uint32()?;
                },
                16 => {
                    self.height = is.read_uint64()?;
                },
                24 => {
                    self.timestamp = is.read_uint64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shard_chunk)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_id);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.height);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.timestamp);
        }
        if let Some(v) = self.shard_chunk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.height != 0 {
            os.write_uint64(2, self.height)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(3, self.timestamp)?;
        }
        if let Some(v) = self.shard_chunk.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardSnapshotMetadata {
        ShardSnapshotMetadata::new()
    }

    fn clear(&mut self) {
        self.shard_id = 0;
        self.height = 0;
        self.timestamp = 0;
        self.shard_chunk.clear();
        self.block.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardSnapshotMetadata {
        static instance: ShardSnapshotMetadata = ShardSnapshotMetadata {
            shard_id: 0,
            height: 0,
            timestamp: 0,
            shard_chunk: ::protobuf::MessageField::none(),
            block: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardSnapshotMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardSnapshotMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardSnapshotMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardSnapshotMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetShardSnapshotMetadataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetShardSnapshotMetadataResponse {
    // message fields
    // @@protoc_insertion_point(field:GetShardSnapshotMetadataResponse.snapshots)
    pub snapshots: ::std::vec::Vec<ShardSnapshotMetadata>,
    // special fields
    // @@protoc_insertion_point(special_field:GetShardSnapshotMetadataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetShardSnapshotMetadataResponse {
    fn default() -> &'a GetShardSnapshotMetadataResponse {
        <GetShardSnapshotMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetShardSnapshotMetadataResponse {
    pub fn new() -> GetShardSnapshotMetadataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshots",
            |m: &GetShardSnapshotMetadataResponse| { &m.snapshots },
            |m: &mut GetShardSnapshotMetadataResponse| { &mut m.snapshots },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetShardSnapshotMetadataResponse>(
            "GetShardSnapshotMetadataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetShardSnapshotMetadataResponse {
    const NAME: &'static str = "GetShardSnapshotMetadataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshots.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.snapshots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.snapshots {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetShardSnapshotMetadataResponse {
        GetShardSnapshotMetadataResponse::new()
    }

    fn clear(&mut self) {
        self.snapshots.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetShardSnapshotMetadataResponse {
        static instance: GetShardSnapshotMetadataResponse = GetShardSnapshotMetadataResponse {
            snapshots: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetShardSnapshotMetadataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetShardSnapshotMetadataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetShardSnapshotMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetShardSnapshotMetadataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetShardTransactionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetShardTransactionsRequest {
    // message fields
    // @@protoc_insertion_point(field:GetShardTransactionsRequest.shard_id)
    pub shard_id: u32,
    // @@protoc_insertion_point(field:GetShardTransactionsRequest.height)
    pub height: u64,
    // @@protoc_insertion_point(field:GetShardTransactionsRequest.trie_virtual_shard)
    pub trie_virtual_shard: u32,
    // @@protoc_insertion_point(field:GetShardTransactionsRequest.page_token)
    pub page_token: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:GetShardTransactionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetShardTransactionsRequest {
    fn default() -> &'a GetShardTransactionsRequest {
        <GetShardTransactionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetShardTransactionsRequest {
    pub fn new() -> GetShardTransactionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &GetShardTransactionsRequest| { &m.shard_id },
            |m: &mut GetShardTransactionsRequest| { &mut m.shard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &GetShardTransactionsRequest| { &m.height },
            |m: &mut GetShardTransactionsRequest| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trie_virtual_shard",
            |m: &GetShardTransactionsRequest| { &m.trie_virtual_shard },
            |m: &mut GetShardTransactionsRequest| { &mut m.trie_virtual_shard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &GetShardTransactionsRequest| { &m.page_token },
            |m: &mut GetShardTransactionsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetShardTransactionsRequest>(
            "GetShardTransactionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetShardTransactionsRequest {
    const NAME: &'static str = "GetShardTransactionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_id = is.read_uint32()?;
                },
                16 => {
                    self.height = is.read_uint64()?;
                },
                24 => {
                    self.trie_virtual_shard = is.read_uint32()?;
                },
                34 => {
                    self.page_token = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_id);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.height);
        }
        if self.trie_virtual_shard != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.trie_virtual_shard);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.height != 0 {
            os.write_uint64(2, self.height)?;
        }
        if self.trie_virtual_shard != 0 {
            os.write_uint32(3, self.trie_virtual_shard)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetShardTransactionsRequest {
        GetShardTransactionsRequest::new()
    }

    fn clear(&mut self) {
        self.shard_id = 0;
        self.height = 0;
        self.trie_virtual_shard = 0;
        self.page_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetShardTransactionsRequest {
        static instance: GetShardTransactionsRequest = GetShardTransactionsRequest {
            shard_id: 0,
            height: 0,
            trie_virtual_shard: 0,
            page_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetShardTransactionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetShardTransactionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetShardTransactionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetShardTransactionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetShardTransactionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetShardTransactionsResponse {
    // message fields
    // @@protoc_insertion_point(field:GetShardTransactionsResponse.trie_messages)
    pub trie_messages: ::std::vec::Vec<ShardTrieEntryWithMessage>,
    // @@protoc_insertion_point(field:GetShardTransactionsResponse.fid_account_roots)
    pub fid_account_roots: ::std::vec::Vec<FidAccountRootHash>,
    // @@protoc_insertion_point(field:GetShardTransactionsResponse.next_page_token)
    pub next_page_token: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:GetShardTransactionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetShardTransactionsResponse {
    fn default() -> &'a GetShardTransactionsResponse {
        <GetShardTransactionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetShardTransactionsResponse {
    pub fn new() -> GetShardTransactionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "trie_messages",
            |m: &GetShardTransactionsResponse| { &m.trie_messages },
            |m: &mut GetShardTransactionsResponse| { &mut m.trie_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fid_account_roots",
            |m: &GetShardTransactionsResponse| { &m.fid_account_roots },
            |m: &mut GetShardTransactionsResponse| { &mut m.fid_account_roots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next_page_token",
            |m: &GetShardTransactionsResponse| { &m.next_page_token },
            |m: &mut GetShardTransactionsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetShardTransactionsResponse>(
            "GetShardTransactionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetShardTransactionsResponse {
    const NAME: &'static str = "GetShardTransactionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trie_messages.push(is.read_message()?);
                },
                18 => {
                    self.fid_account_roots.push(is.read_message()?);
                },
                26 => {
                    self.next_page_token = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.trie_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fid_account_roots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.next_page_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.trie_messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.fid_account_roots {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.next_page_token.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetShardTransactionsResponse {
        GetShardTransactionsResponse::new()
    }

    fn clear(&mut self) {
        self.trie_messages.clear();
        self.fid_account_roots.clear();
        self.next_page_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetShardTransactionsResponse {
        static instance: GetShardTransactionsResponse = GetShardTransactionsResponse {
            trie_messages: ::std::vec::Vec::new(),
            fid_account_roots: ::std::vec::Vec::new(),
            next_page_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetShardTransactionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetShardTransactionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetShardTransactionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetShardTransactionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardTrieEntryWithMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardTrieEntryWithMessage {
    // message fields
    // @@protoc_insertion_point(field:ShardTrieEntryWithMessage.trie_key)
    pub trie_key: ::std::vec::Vec<u8>,
    // message oneof groups
    pub trie_message: ::std::option::Option<shard_trie_entry_with_message::Trie_message>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardTrieEntryWithMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardTrieEntryWithMessage {
    fn default() -> &'a ShardTrieEntryWithMessage {
        <ShardTrieEntryWithMessage as ::protobuf::Message>::default_instance()
    }
}

impl ShardTrieEntryWithMessage {
    pub fn new() -> ShardTrieEntryWithMessage {
        ::std::default::Default::default()
    }

    // .Message user_message = 2;

    pub fn user_message(&self) -> &super::message::Message {
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::UserMessage(ref v)) => v,
            _ => <super::message::Message as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_user_message(&mut self) {
        self.trie_message = ::std::option::Option::None;
    }

    pub fn has_user_message(&self) -> bool {
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::UserMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_message(&mut self, v: super::message::Message) {
        self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::UserMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_message(&mut self) -> &mut super::message::Message {
        if let ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::UserMessage(_)) = self.trie_message {
        } else {
            self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::UserMessage(super::message::Message::new()));
        }
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::UserMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_message(&mut self) -> super::message::Message {
        if self.has_user_message() {
            match self.trie_message.take() {
                ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::UserMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::Message::new()
        }
    }

    // .OnChainEvent on_chain_event = 3;

    pub fn on_chain_event(&self) -> &super::onchain_event::OnChainEvent {
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::OnChainEvent(ref v)) => v,
            _ => <super::onchain_event::OnChainEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_on_chain_event(&mut self) {
        self.trie_message = ::std::option::Option::None;
    }

    pub fn has_on_chain_event(&self) -> bool {
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::OnChainEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_on_chain_event(&mut self, v: super::onchain_event::OnChainEvent) {
        self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::OnChainEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_on_chain_event(&mut self) -> &mut super::onchain_event::OnChainEvent {
        if let ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::OnChainEvent(_)) = self.trie_message {
        } else {
            self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::OnChainEvent(super::onchain_event::OnChainEvent::new()));
        }
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::OnChainEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_on_chain_event(&mut self) -> super::onchain_event::OnChainEvent {
        if self.has_on_chain_event() {
            match self.trie_message.take() {
                ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::OnChainEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            super::onchain_event::OnChainEvent::new()
        }
    }

    // .FnameTransfer fname_transfer = 4;

    pub fn fname_transfer(&self) -> &super::blocks::FnameTransfer {
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::FnameTransfer(ref v)) => v,
            _ => <super::blocks::FnameTransfer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fname_transfer(&mut self) {
        self.trie_message = ::std::option::Option::None;
    }

    pub fn has_fname_transfer(&self) -> bool {
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::FnameTransfer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fname_transfer(&mut self, v: super::blocks::FnameTransfer) {
        self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::FnameTransfer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fname_transfer(&mut self) -> &mut super::blocks::FnameTransfer {
        if let ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::FnameTransfer(_)) = self.trie_message {
        } else {
            self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::FnameTransfer(super::blocks::FnameTransfer::new()));
        }
        match self.trie_message {
            ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::FnameTransfer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fname_transfer(&mut self) -> super::blocks::FnameTransfer {
        if self.has_fname_transfer() {
            match self.trie_message.take() {
                ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::FnameTransfer(v)) => v,
                _ => panic!(),
            }
        } else {
            super::blocks::FnameTransfer::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trie_key",
            |m: &ShardTrieEntryWithMessage| { &m.trie_key },
            |m: &mut ShardTrieEntryWithMessage| { &mut m.trie_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::message::Message>(
            "user_message",
            ShardTrieEntryWithMessage::has_user_message,
            ShardTrieEntryWithMessage::user_message,
            ShardTrieEntryWithMessage::mut_user_message,
            ShardTrieEntryWithMessage::set_user_message,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::onchain_event::OnChainEvent>(
            "on_chain_event",
            ShardTrieEntryWithMessage::has_on_chain_event,
            ShardTrieEntryWithMessage::on_chain_event,
            ShardTrieEntryWithMessage::mut_on_chain_event,
            ShardTrieEntryWithMessage::set_on_chain_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::blocks::FnameTransfer>(
            "fname_transfer",
            ShardTrieEntryWithMessage::has_fname_transfer,
            ShardTrieEntryWithMessage::fname_transfer,
            ShardTrieEntryWithMessage::mut_fname_transfer,
            ShardTrieEntryWithMessage::set_fname_transfer,
        ));
        oneofs.push(shard_trie_entry_with_message::Trie_message::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardTrieEntryWithMessage>(
            "ShardTrieEntryWithMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardTrieEntryWithMessage {
    const NAME: &'static str = "ShardTrieEntryWithMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trie_key = is.read_bytes()?;
                },
                18 => {
                    self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::UserMessage(is.read_message()?));
                },
                26 => {
                    self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::OnChainEvent(is.read_message()?));
                },
                34 => {
                    self.trie_message = ::std::option::Option::Some(shard_trie_entry_with_message::Trie_message::FnameTransfer(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.trie_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.trie_key);
        }
        if let ::std::option::Option::Some(ref v) = self.trie_message {
            match v {
                &shard_trie_entry_with_message::Trie_message::UserMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &shard_trie_entry_with_message::Trie_message::OnChainEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &shard_trie_entry_with_message::Trie_message::FnameTransfer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.trie_key.is_empty() {
            os.write_bytes(1, &self.trie_key)?;
        }
        if let ::std::option::Option::Some(ref v) = self.trie_message {
            match v {
                &shard_trie_entry_with_message::Trie_message::UserMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &shard_trie_entry_with_message::Trie_message::OnChainEvent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &shard_trie_entry_with_message::Trie_message::FnameTransfer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardTrieEntryWithMessage {
        ShardTrieEntryWithMessage::new()
    }

    fn clear(&mut self) {
        self.trie_key.clear();
        self.trie_message = ::std::option::Option::None;
        self.trie_message = ::std::option::Option::None;
        self.trie_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardTrieEntryWithMessage {
        static instance: ShardTrieEntryWithMessage = ShardTrieEntryWithMessage {
            trie_key: ::std::vec::Vec::new(),
            trie_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardTrieEntryWithMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardTrieEntryWithMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardTrieEntryWithMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardTrieEntryWithMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ShardTrieEntryWithMessage`
pub mod shard_trie_entry_with_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ShardTrieEntryWithMessage.trie_message)
    pub enum Trie_message {
        // @@protoc_insertion_point(oneof_field:ShardTrieEntryWithMessage.user_message)
        UserMessage(super::super::message::Message),
        // @@protoc_insertion_point(oneof_field:ShardTrieEntryWithMessage.on_chain_event)
        OnChainEvent(super::super::onchain_event::OnChainEvent),
        // @@protoc_insertion_point(oneof_field:ShardTrieEntryWithMessage.fname_transfer)
        FnameTransfer(super::super::blocks::FnameTransfer),
    }

    impl ::protobuf::Oneof for Trie_message {
    }

    impl ::protobuf::OneofFull for Trie_message {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ShardTrieEntryWithMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("trie_message").unwrap()).clone()
        }
    }

    impl Trie_message {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Trie_message>("trie_message")
        }
    }
}

// @@protoc_insertion_point(message:FidAccountRootHash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidAccountRootHash {
    // message fields
    // @@protoc_insertion_point(field:FidAccountRootHash.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:FidAccountRootHash.account_root_hash)
    pub account_root_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:FidAccountRootHash.num_messages)
    pub num_messages: u64,
    // special fields
    // @@protoc_insertion_point(special_field:FidAccountRootHash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidAccountRootHash {
    fn default() -> &'a FidAccountRootHash {
        <FidAccountRootHash as ::protobuf::Message>::default_instance()
    }
}

impl FidAccountRootHash {
    pub fn new() -> FidAccountRootHash {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &FidAccountRootHash| { &m.fid },
            |m: &mut FidAccountRootHash| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account_root_hash",
            |m: &FidAccountRootHash| { &m.account_root_hash },
            |m: &mut FidAccountRootHash| { &mut m.account_root_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_messages",
            |m: &FidAccountRootHash| { &m.num_messages },
            |m: &mut FidAccountRootHash| { &mut m.num_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FidAccountRootHash>(
            "FidAccountRootHash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FidAccountRootHash {
    const NAME: &'static str = "FidAccountRootHash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.account_root_hash = is.read_bytes()?;
                },
                24 => {
                    self.num_messages = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if !self.account_root_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.account_root_hash);
        }
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.num_messages);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.account_root_hash.is_empty() {
            os.write_bytes(2, &self.account_root_hash)?;
        }
        if self.num_messages != 0 {
            os.write_uint64(3, self.num_messages)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidAccountRootHash {
        FidAccountRootHash::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.account_root_hash.clear();
        self.num_messages = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidAccountRootHash {
        static instance: FidAccountRootHash = FidAccountRootHash {
            fid: 0,
            account_root_hash: ::std::vec::Vec::new(),
            num_messages: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FidAccountRootHash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FidAccountRootHash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FidAccountRootHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidAccountRootHash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ReplicationTriePartStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicationTriePartStatus {
    // message fields
    // @@protoc_insertion_point(field:ReplicationTriePartStatus.shard_id)
    pub shard_id: u32,
    // @@protoc_insertion_point(field:ReplicationTriePartStatus.height)
    pub height: u64,
    // @@protoc_insertion_point(field:ReplicationTriePartStatus.virtual_trie_shard)
    pub virtual_trie_shard: u32,
    // @@protoc_insertion_point(field:ReplicationTriePartStatus.next_page_token)
    pub next_page_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ReplicationTriePartStatus.last_response)
    pub last_response: u32,
    // @@protoc_insertion_point(field:ReplicationTriePartStatus.last_fid)
    pub last_fid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ReplicationTriePartStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicationTriePartStatus {
    fn default() -> &'a ReplicationTriePartStatus {
        <ReplicationTriePartStatus as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationTriePartStatus {
    pub fn new() -> ReplicationTriePartStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &ReplicationTriePartStatus| { &m.shard_id },
            |m: &mut ReplicationTriePartStatus| { &mut m.shard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &ReplicationTriePartStatus| { &m.height },
            |m: &mut ReplicationTriePartStatus| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "virtual_trie_shard",
            |m: &ReplicationTriePartStatus| { &m.virtual_trie_shard },
            |m: &mut ReplicationTriePartStatus| { &mut m.virtual_trie_shard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next_page_token",
            |m: &ReplicationTriePartStatus| { &m.next_page_token },
            |m: &mut ReplicationTriePartStatus| { &mut m.next_page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_response",
            |m: &ReplicationTriePartStatus| { &m.last_response },
            |m: &mut ReplicationTriePartStatus| { &mut m.last_response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_fid",
            |m: &ReplicationTriePartStatus| { &m.last_fid },
            |m: &mut ReplicationTriePartStatus| { &mut m.last_fid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicationTriePartStatus>(
            "ReplicationTriePartStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicationTriePartStatus {
    const NAME: &'static str = "ReplicationTriePartStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_id = is.read_uint32()?;
                },
                16 => {
                    self.height = is.read_uint64()?;
                },
                24 => {
                    self.virtual_trie_shard = is.read_uint32()?;
                },
                34 => {
                    self.next_page_token = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.last_response = is.read_uint32()?;
                },
                48 => {
                    self.last_fid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_id);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.height);
        }
        if self.virtual_trie_shard != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.virtual_trie_shard);
        }
        if let Some(v) = self.next_page_token.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if self.last_response != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.last_response);
        }
        if let Some(v) = self.last_fid {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.height != 0 {
            os.write_uint64(2, self.height)?;
        }
        if self.virtual_trie_shard != 0 {
            os.write_uint32(3, self.virtual_trie_shard)?;
        }
        if let Some(v) = self.next_page_token.as_ref() {
            os.write_string(4, v)?;
        }
        if self.last_response != 0 {
            os.write_uint32(5, self.last_response)?;
        }
        if let Some(v) = self.last_fid {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicationTriePartStatus {
        ReplicationTriePartStatus::new()
    }

    fn clear(&mut self) {
        self.shard_id = 0;
        self.height = 0;
        self.virtual_trie_shard = 0;
        self.next_page_token = ::std::option::Option::None;
        self.last_response = 0;
        self.last_fid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicationTriePartStatus {
        static instance: ReplicationTriePartStatus = ReplicationTriePartStatus {
            shard_id: 0,
            height: 0,
            virtual_trie_shard: 0,
            next_page_token: ::std::option::Option::None,
            last_response: 0,
            last_fid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicationTriePartStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicationTriePartStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicationTriePartStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationTriePartStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11replication.proto\x1a\rmessage.proto\x1a\x13onchain_event.proto\
    \x1a\x0cblocks.proto\"<\n\x1fGetShardSnapshotMetadataRequest\x12\x19\n\
    \x08shard_id\x18\x01\x20\x01(\rR\x07shardId\"\xd8\x01\n\x15ShardSnapshot\
    Metadata\x12\x19\n\x08shard_id\x18\x01\x20\x01(\rR\x07shardId\x12\x16\n\
    \x06height\x18\x02\x20\x01(\x04R\x06height\x12\x1c\n\ttimestamp\x18\x03\
    \x20\x01(\x04R\ttimestamp\x121\n\x0bshard_chunk\x18\x05\x20\x01(\x0b2\
    \x0b.ShardChunkH\0R\nshardChunk\x88\x01\x01\x12!\n\x05block\x18\x06\x20\
    \x01(\x0b2\x06.BlockH\x01R\x05block\x88\x01\x01B\x0e\n\x0c_shard_chunkB\
    \x08\n\x06_block\"X\n\x20GetShardSnapshotMetadataResponse\x124\n\tsnapsh\
    ots\x18\x01\x20\x03(\x0b2\x16.ShardSnapshotMetadataR\tsnapshots\"\xb1\
    \x01\n\x1bGetShardTransactionsRequest\x12\x19\n\x08shard_id\x18\x01\x20\
    \x01(\rR\x07shardId\x12\x16\n\x06height\x18\x02\x20\x01(\x04R\x06height\
    \x12,\n\x12trie_virtual_shard\x18\x03\x20\x01(\rR\x10trieVirtualShard\
    \x12\"\n\npage_token\x18\x04\x20\x01(\tH\0R\tpageToken\x88\x01\x01B\r\n\
    \x0b_page_token\"\xe1\x01\n\x1cGetShardTransactionsResponse\x12?\n\rtrie\
    _messages\x18\x01\x20\x03(\x0b2\x1a.ShardTrieEntryWithMessageR\x0ctrieMe\
    ssages\x12?\n\x11fid_account_roots\x18\x02\x20\x03(\x0b2\x13.FidAccountR\
    ootHashR\x0ffidAccountRoots\x12+\n\x0fnext_page_token\x18\x03\x20\x01(\t\
    H\0R\rnextPageToken\x88\x01\x01B\x12\n\x10_next_page_token\"\xe5\x01\n\
    \x19ShardTrieEntryWithMessage\x12\x19\n\x08trie_key\x18\x01\x20\x01(\x0c\
    R\x07trieKey\x12-\n\x0cuser_message\x18\x02\x20\x01(\x0b2\x08.MessageH\0\
    R\x0buserMessage\x125\n\x0eon_chain_event\x18\x03\x20\x01(\x0b2\r.OnChai\
    nEventH\0R\x0conChainEvent\x127\n\x0efname_transfer\x18\x04\x20\x01(\x0b\
    2\x0e.FnameTransferH\0R\rfnameTransferB\x0e\n\x0ctrie_message\"u\n\x12Fi\
    dAccountRootHash\x12\x10\n\x03fid\x18\x01\x20\x01(\x04R\x03fid\x12*\n\
    \x11account_root_hash\x18\x02\x20\x01(\x0cR\x0faccountRootHash\x12!\n\
    \x0cnum_messages\x18\x03\x20\x01(\x04R\x0bnumMessages\"\x8f\x02\n\x19Rep\
    licationTriePartStatus\x12\x19\n\x08shard_id\x18\x01\x20\x01(\rR\x07shar\
    dId\x12\x16\n\x06height\x18\x02\x20\x01(\x04R\x06height\x12,\n\x12virtua\
    l_trie_shard\x18\x03\x20\x01(\rR\x10virtualTrieShard\x12+\n\x0fnext_page\
    _token\x18\x04\x20\x01(\tH\0R\rnextPageToken\x88\x01\x01\x12#\n\rlast_re\
    sponse\x18\x05\x20\x01(\rR\x0clastResponse\x12\x1e\n\x08last_fid\x18\x06\
    \x20\x01(\x04H\x01R\x07lastFid\x88\x01\x01B\x12\n\x10_next_page_tokenB\
    \x0b\n\t_last_fid2\xca\x01\n\x12ReplicationService\x12_\n\x18GetShardSna\
    pshotMetadata\x12\x20.GetShardSnapshotMetadataRequest\x1a!.GetShardSnaps\
    hotMetadataResponse\x12S\n\x14GetShardTransactions\x12\x1c.GetShardTrans\
    actionsRequest\x1a\x1d.GetShardTransactionsResponseb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::message::file_descriptor().clone());
            deps.push(super::onchain_event::file_descriptor().clone());
            deps.push(super::blocks::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(GetShardSnapshotMetadataRequest::generated_message_descriptor_data());
            messages.push(ShardSnapshotMetadata::generated_message_descriptor_data());
            messages.push(GetShardSnapshotMetadataResponse::generated_message_descriptor_data());
            messages.push(GetShardTransactionsRequest::generated_message_descriptor_data());
            messages.push(GetShardTransactionsResponse::generated_message_descriptor_data());
            messages.push(ShardTrieEntryWithMessage::generated_message_descriptor_data());
            messages.push(FidAccountRootHash::generated_message_descriptor_data());
            messages.push(ReplicationTriePartStatus::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
