#![allow(clippy::all)]
#![allow(clippy::pedantic)]
#![allow(clippy::nursery)]
#![allow(unused_lifetimes)]
#![allow(elided_lifetimes_in_paths)]
#![allow(unused_parens)]
#![allow(unknown_lints)]
#![allow(renamed_and_removed_lints)]
#![allow(warnings)]

// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `request_response.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct BlocksRequest {
    // message fields
    pub shard_id: u32,
    pub start_block_number: u64,
    pub stop_block_number: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlocksRequest {
    fn default() -> &'a BlocksRequest {
        <BlocksRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlocksRequest {
    pub fn new() -> BlocksRequest {
        ::std::default::Default::default()
    }

    // uint32 shard_id = 1;


    pub fn get_shard_id(&self) -> u32 {
        self.shard_id
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: u32) {
        self.shard_id = v;
    }

    // uint64 start_block_number = 2;


    pub fn get_start_block_number(&self) -> u64 {
        self.start_block_number
    }
    pub fn clear_start_block_number(&mut self) {
        self.start_block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_block_number(&mut self, v: u64) {
        self.start_block_number = v;
    }

    // uint64 stop_block_number = 3;


    pub fn get_stop_block_number(&self) -> u64 {
        self.stop_block_number
    }
    pub fn clear_stop_block_number(&mut self) {
        self.stop_block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_stop_block_number(&mut self, v: u64) {
        self.stop_block_number = v;
    }
}

impl ::protobuf::Message for BlocksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_block_number = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stop_block_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shard_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_block_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stop_block_number != 0 {
            my_size += ::protobuf::rt::value_size(3, self.stop_block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.start_block_number != 0 {
            os.write_uint64(2, self.start_block_number)?;
        }
        if self.stop_block_number != 0 {
            os.write_uint64(3, self.stop_block_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlocksRequest {
        BlocksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_id",
                |m: &BlocksRequest| { &m.shard_id },
                |m: &mut BlocksRequest| { &mut m.shard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start_block_number",
                |m: &BlocksRequest| { &m.start_block_number },
                |m: &mut BlocksRequest| { &mut m.start_block_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "stop_block_number",
                |m: &BlocksRequest| { &m.stop_block_number },
                |m: &mut BlocksRequest| { &mut m.stop_block_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlocksRequest>(
                "BlocksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlocksRequest {
        static instance: ::protobuf::rt::LazyV2<BlocksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlocksRequest::new)
    }
}

impl ::protobuf::Clear for BlocksRequest {
    fn clear(&mut self) {
        self.shard_id = 0;
        self.start_block_number = 0;
        self.stop_block_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlocksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlocksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardChunksRequest {
    // message fields
    pub shard_id: u32,
    pub start_block_number: u64,
    pub stop_block_number: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardChunksRequest {
    fn default() -> &'a ShardChunksRequest {
        <ShardChunksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ShardChunksRequest {
    pub fn new() -> ShardChunksRequest {
        ::std::default::Default::default()
    }

    // uint32 shard_id = 1;


    pub fn get_shard_id(&self) -> u32 {
        self.shard_id
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: u32) {
        self.shard_id = v;
    }

    // uint64 start_block_number = 2;


    pub fn get_start_block_number(&self) -> u64 {
        self.start_block_number
    }
    pub fn clear_start_block_number(&mut self) {
        self.start_block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_block_number(&mut self, v: u64) {
        self.start_block_number = v;
    }

    // uint64 stop_block_number = 3;


    pub fn get_stop_block_number(&self) -> u64 {
        self.stop_block_number
    }
    pub fn clear_stop_block_number(&mut self) {
        self.stop_block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_stop_block_number(&mut self, v: u64) {
        self.stop_block_number = v;
    }
}

impl ::protobuf::Message for ShardChunksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_block_number = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stop_block_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shard_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_block_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stop_block_number != 0 {
            my_size += ::protobuf::rt::value_size(3, self.stop_block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.start_block_number != 0 {
            os.write_uint64(2, self.start_block_number)?;
        }
        if self.stop_block_number != 0 {
            os.write_uint64(3, self.stop_block_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardChunksRequest {
        ShardChunksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_id",
                |m: &ShardChunksRequest| { &m.shard_id },
                |m: &mut ShardChunksRequest| { &mut m.shard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start_block_number",
                |m: &ShardChunksRequest| { &m.start_block_number },
                |m: &mut ShardChunksRequest| { &mut m.start_block_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "stop_block_number",
                |m: &ShardChunksRequest| { &m.stop_block_number },
                |m: &mut ShardChunksRequest| { &mut m.stop_block_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShardChunksRequest>(
                "ShardChunksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShardChunksRequest {
        static instance: ::protobuf::rt::LazyV2<ShardChunksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShardChunksRequest::new)
    }
}

impl ::protobuf::Clear for ShardChunksRequest {
    fn clear(&mut self) {
        self.shard_id = 0;
        self.start_block_number = 0;
        self.stop_block_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardChunksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardChunksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardChunksResponse {
    // message fields
    pub shard_chunks: ::protobuf::RepeatedField<super::blocks::ShardChunk>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardChunksResponse {
    fn default() -> &'a ShardChunksResponse {
        <ShardChunksResponse as ::protobuf::Message>::default_instance()
    }
}

impl ShardChunksResponse {
    pub fn new() -> ShardChunksResponse {
        ::std::default::Default::default()
    }

    // repeated .ShardChunk shard_chunks = 1;


    pub fn get_shard_chunks(&self) -> &[super::blocks::ShardChunk] {
        &self.shard_chunks
    }
    pub fn clear_shard_chunks(&mut self) {
        self.shard_chunks.clear();
    }

    // Param is passed by value, moved
    pub fn set_shard_chunks(&mut self, v: ::protobuf::RepeatedField<super::blocks::ShardChunk>) {
        self.shard_chunks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shard_chunks(&mut self) -> &mut ::protobuf::RepeatedField<super::blocks::ShardChunk> {
        &mut self.shard_chunks
    }

    // Take field
    pub fn take_shard_chunks(&mut self) -> ::protobuf::RepeatedField<super::blocks::ShardChunk> {
        ::std::mem::replace(&mut self.shard_chunks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ShardChunksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.shard_chunks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shard_chunks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.shard_chunks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.shard_chunks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardChunksResponse {
        ShardChunksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::blocks::ShardChunk>>(
                "shard_chunks",
                |m: &ShardChunksResponse| { &m.shard_chunks },
                |m: &mut ShardChunksResponse| { &mut m.shard_chunks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShardChunksResponse>(
                "ShardChunksResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShardChunksResponse {
        static instance: ::protobuf::rt::LazyV2<ShardChunksResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShardChunksResponse::new)
    }
}

impl ::protobuf::Clear for ShardChunksResponse {
    fn clear(&mut self) {
        self.shard_chunks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardChunksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardChunksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeRequest {
    // message fields
    pub event_types: ::std::vec::Vec<super::hub_event::HubEventType>,
    pub from_id: u64,
    pub shard_index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeRequest {
    fn default() -> &'a SubscribeRequest {
        <SubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeRequest {
    pub fn new() -> SubscribeRequest {
        ::std::default::Default::default()
    }

    // repeated .HubEventType event_types = 1;


    pub fn get_event_types(&self) -> &[super::hub_event::HubEventType] {
        &self.event_types
    }
    pub fn clear_event_types(&mut self) {
        self.event_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_types(&mut self, v: ::std::vec::Vec<super::hub_event::HubEventType>) {
        self.event_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_types(&mut self) -> &mut ::std::vec::Vec<super::hub_event::HubEventType> {
        &mut self.event_types
    }

    // Take field
    pub fn take_event_types(&mut self) -> ::std::vec::Vec<super::hub_event::HubEventType> {
        ::std::mem::replace(&mut self.event_types, ::std::vec::Vec::new())
    }

    // uint64 from_id = 2;


    pub fn get_from_id(&self) -> u64 {
        self.from_id
    }
    pub fn clear_from_id(&mut self) {
        self.from_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_id(&mut self, v: u64) {
        self.from_id = v;
    }

    // uint32 shard_index = 4;


    pub fn get_shard_index(&self) -> u32 {
        self.shard_index
    }
    pub fn clear_shard_index(&mut self) {
        self.shard_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_index(&mut self, v: u32) {
        self.shard_index = v;
    }
}

impl ::protobuf::Message for SubscribeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.event_types, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.from_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.event_types {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        if self.from_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.from_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.shard_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.event_types {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.from_id != 0 {
            os.write_uint64(2, self.from_id)?;
        }
        if self.shard_index != 0 {
            os.write_uint32(4, self.shard_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeRequest {
        SubscribeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hub_event::HubEventType>>(
                "event_types",
                |m: &SubscribeRequest| { &m.event_types },
                |m: &mut SubscribeRequest| { &mut m.event_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "from_id",
                |m: &SubscribeRequest| { &m.from_id },
                |m: &mut SubscribeRequest| { &mut m.from_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_index",
                |m: &SubscribeRequest| { &m.shard_index },
                |m: &mut SubscribeRequest| { &mut m.shard_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeRequest>(
                "SubscribeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeRequest {
    fn clear(&mut self) {
        self.event_types.clear();
        self.from_id = 0;
        self.shard_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DbStats {
    // message fields
    pub num_messages: u64,
    pub num_fid_registrations: u64,
    pub approx_size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DbStats {
    fn default() -> &'a DbStats {
        <DbStats as ::protobuf::Message>::default_instance()
    }
}

impl DbStats {
    pub fn new() -> DbStats {
        ::std::default::Default::default()
    }

    // uint64 num_messages = 1;


    pub fn get_num_messages(&self) -> u64 {
        self.num_messages
    }
    pub fn clear_num_messages(&mut self) {
        self.num_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: u64) {
        self.num_messages = v;
    }

    // uint64 num_fid_registrations = 2;


    pub fn get_num_fid_registrations(&self) -> u64 {
        self.num_fid_registrations
    }
    pub fn clear_num_fid_registrations(&mut self) {
        self.num_fid_registrations = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_fid_registrations(&mut self, v: u64) {
        self.num_fid_registrations = v;
    }

    // uint64 approx_size = 4;


    pub fn get_approx_size(&self) -> u64 {
        self.approx_size
    }
    pub fn clear_approx_size(&mut self) {
        self.approx_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_approx_size(&mut self, v: u64) {
        self.approx_size = v;
    }
}

impl ::protobuf::Message for DbStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_messages = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_fid_registrations = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.approx_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_fid_registrations != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_fid_registrations, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.approx_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.approx_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_messages != 0 {
            os.write_uint64(1, self.num_messages)?;
        }
        if self.num_fid_registrations != 0 {
            os.write_uint64(2, self.num_fid_registrations)?;
        }
        if self.approx_size != 0 {
            os.write_uint64(4, self.approx_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DbStats {
        DbStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_messages",
                |m: &DbStats| { &m.num_messages },
                |m: &mut DbStats| { &mut m.num_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_fid_registrations",
                |m: &DbStats| { &m.num_fid_registrations },
                |m: &mut DbStats| { &mut m.num_fid_registrations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "approx_size",
                |m: &DbStats| { &m.approx_size },
                |m: &mut DbStats| { &mut m.approx_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DbStats>(
                "DbStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DbStats {
        static instance: ::protobuf::rt::LazyV2<DbStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DbStats::new)
    }
}

impl ::protobuf::Clear for DbStats {
    fn clear(&mut self) {
        self.num_messages = 0;
        self.num_fid_registrations = 0;
        self.approx_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DbStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DbStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardInfo {
    // message fields
    pub shard_id: u32,
    pub max_height: u64,
    pub num_messages: u64,
    pub num_fid_registrations: u64,
    pub approx_size: u64,
    pub block_delay: u64,
    pub mempool_size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardInfo {
    fn default() -> &'a ShardInfo {
        <ShardInfo as ::protobuf::Message>::default_instance()
    }
}

impl ShardInfo {
    pub fn new() -> ShardInfo {
        ::std::default::Default::default()
    }

    // uint32 shard_id = 1;


    pub fn get_shard_id(&self) -> u32 {
        self.shard_id
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: u32) {
        self.shard_id = v;
    }

    // uint64 max_height = 2;


    pub fn get_max_height(&self) -> u64 {
        self.max_height
    }
    pub fn clear_max_height(&mut self) {
        self.max_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_height(&mut self, v: u64) {
        self.max_height = v;
    }

    // uint64 num_messages = 3;


    pub fn get_num_messages(&self) -> u64 {
        self.num_messages
    }
    pub fn clear_num_messages(&mut self) {
        self.num_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: u64) {
        self.num_messages = v;
    }

    // uint64 num_fid_registrations = 4;


    pub fn get_num_fid_registrations(&self) -> u64 {
        self.num_fid_registrations
    }
    pub fn clear_num_fid_registrations(&mut self) {
        self.num_fid_registrations = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_fid_registrations(&mut self, v: u64) {
        self.num_fid_registrations = v;
    }

    // uint64 approx_size = 5;


    pub fn get_approx_size(&self) -> u64 {
        self.approx_size
    }
    pub fn clear_approx_size(&mut self) {
        self.approx_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_approx_size(&mut self, v: u64) {
        self.approx_size = v;
    }

    // uint64 block_delay = 6;


    pub fn get_block_delay(&self) -> u64 {
        self.block_delay
    }
    pub fn clear_block_delay(&mut self) {
        self.block_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_delay(&mut self, v: u64) {
        self.block_delay = v;
    }

    // uint64 mempool_size = 7;


    pub fn get_mempool_size(&self) -> u64 {
        self.mempool_size
    }
    pub fn clear_mempool_size(&mut self) {
        self.mempool_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_mempool_size(&mut self, v: u64) {
        self.mempool_size = v;
    }
}

impl ::protobuf::Message for ShardInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_messages = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_fid_registrations = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.approx_size = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_delay = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mempool_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shard_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_fid_registrations != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_fid_registrations, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.approx_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.approx_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_delay != 0 {
            my_size += ::protobuf::rt::value_size(6, self.block_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mempool_size != 0 {
            my_size += ::protobuf::rt::value_size(7, self.mempool_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.max_height != 0 {
            os.write_uint64(2, self.max_height)?;
        }
        if self.num_messages != 0 {
            os.write_uint64(3, self.num_messages)?;
        }
        if self.num_fid_registrations != 0 {
            os.write_uint64(4, self.num_fid_registrations)?;
        }
        if self.approx_size != 0 {
            os.write_uint64(5, self.approx_size)?;
        }
        if self.block_delay != 0 {
            os.write_uint64(6, self.block_delay)?;
        }
        if self.mempool_size != 0 {
            os.write_uint64(7, self.mempool_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardInfo {
        ShardInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_id",
                |m: &ShardInfo| { &m.shard_id },
                |m: &mut ShardInfo| { &mut m.shard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_height",
                |m: &ShardInfo| { &m.max_height },
                |m: &mut ShardInfo| { &mut m.max_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_messages",
                |m: &ShardInfo| { &m.num_messages },
                |m: &mut ShardInfo| { &mut m.num_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_fid_registrations",
                |m: &ShardInfo| { &m.num_fid_registrations },
                |m: &mut ShardInfo| { &mut m.num_fid_registrations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "approx_size",
                |m: &ShardInfo| { &m.approx_size },
                |m: &mut ShardInfo| { &mut m.approx_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_delay",
                |m: &ShardInfo| { &m.block_delay },
                |m: &mut ShardInfo| { &mut m.block_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "mempool_size",
                |m: &ShardInfo| { &m.mempool_size },
                |m: &mut ShardInfo| { &mut m.mempool_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShardInfo>(
                "ShardInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShardInfo {
        static instance: ::protobuf::rt::LazyV2<ShardInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShardInfo::new)
    }
}

impl ::protobuf::Clear for ShardInfo {
    fn clear(&mut self) {
        self.shard_id = 0;
        self.max_height = 0;
        self.num_messages = 0;
        self.num_fid_registrations = 0;
        self.approx_size = 0;
        self.block_delay = 0;
        self.mempool_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoRequest {
    fn default() -> &'a GetInfoRequest {
        <GetInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoRequest {
    pub fn new() -> GetInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoRequest {
        GetInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInfoRequest>(
                "GetInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoResponse {
    // message fields
    pub version: ::std::string::String,
    pub db_stats: ::protobuf::SingularPtrField<DbStats>,
    pub peerId: ::std::string::String,
    pub num_shards: u32,
    pub shard_infos: ::protobuf::RepeatedField<ShardInfo>,
    pub next_engine_version_timestamp: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoResponse {
    fn default() -> &'a GetInfoResponse {
        <GetInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoResponse {
    pub fn new() -> GetInfoResponse {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // .DbStats db_stats = 5;


    pub fn get_db_stats(&self) -> &DbStats {
        self.db_stats.as_ref().unwrap_or_else(|| <DbStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_db_stats(&mut self) {
        self.db_stats.clear();
    }

    pub fn has_db_stats(&self) -> bool {
        self.db_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_db_stats(&mut self, v: DbStats) {
        self.db_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_db_stats(&mut self) -> &mut DbStats {
        if self.db_stats.is_none() {
            self.db_stats.set_default();
        }
        self.db_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_db_stats(&mut self) -> DbStats {
        self.db_stats.take().unwrap_or_else(|| DbStats::new())
    }

    // string peerId = 6;


    pub fn get_peerId(&self) -> &str {
        &self.peerId
    }
    pub fn clear_peerId(&mut self) {
        self.peerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerId(&mut self, v: ::std::string::String) {
        self.peerId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peerId(&mut self) -> &mut ::std::string::String {
        &mut self.peerId
    }

    // Take field
    pub fn take_peerId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peerId, ::std::string::String::new())
    }

    // uint32 num_shards = 8;


    pub fn get_num_shards(&self) -> u32 {
        self.num_shards
    }
    pub fn clear_num_shards(&mut self) {
        self.num_shards = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_shards(&mut self, v: u32) {
        self.num_shards = v;
    }

    // repeated .ShardInfo shard_infos = 9;


    pub fn get_shard_infos(&self) -> &[ShardInfo] {
        &self.shard_infos
    }
    pub fn clear_shard_infos(&mut self) {
        self.shard_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_shard_infos(&mut self, v: ::protobuf::RepeatedField<ShardInfo>) {
        self.shard_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shard_infos(&mut self) -> &mut ::protobuf::RepeatedField<ShardInfo> {
        &mut self.shard_infos
    }

    // Take field
    pub fn take_shard_infos(&mut self) -> ::protobuf::RepeatedField<ShardInfo> {
        ::std::mem::replace(&mut self.shard_infos, ::protobuf::RepeatedField::new())
    }

    // uint64 next_engine_version_timestamp = 10;


    pub fn get_next_engine_version_timestamp(&self) -> u64 {
        self.next_engine_version_timestamp
    }
    pub fn clear_next_engine_version_timestamp(&mut self) {
        self.next_engine_version_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_engine_version_timestamp(&mut self, v: u64) {
        self.next_engine_version_timestamp = v;
    }
}

impl ::protobuf::Message for GetInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.db_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shard_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.db_stats)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peerId)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_shards = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shard_infos)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.next_engine_version_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if let Some(ref v) = self.db_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.peerId.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.peerId);
        }
        if self.num_shards != 0 {
            my_size += ::protobuf::rt::value_size(8, self.num_shards, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.shard_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.next_engine_version_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(10, self.next_engine_version_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if let Some(ref v) = self.db_stats.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.peerId.is_empty() {
            os.write_string(6, &self.peerId)?;
        }
        if self.num_shards != 0 {
            os.write_uint32(8, self.num_shards)?;
        }
        for v in &self.shard_infos {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.next_engine_version_timestamp != 0 {
            os.write_uint64(10, self.next_engine_version_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoResponse {
        GetInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &GetInfoResponse| { &m.version },
                |m: &mut GetInfoResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DbStats>>(
                "db_stats",
                |m: &GetInfoResponse| { &m.db_stats },
                |m: &mut GetInfoResponse| { &mut m.db_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerId",
                |m: &GetInfoResponse| { &m.peerId },
                |m: &mut GetInfoResponse| { &mut m.peerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_shards",
                |m: &GetInfoResponse| { &m.num_shards },
                |m: &mut GetInfoResponse| { &mut m.num_shards },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShardInfo>>(
                "shard_infos",
                |m: &GetInfoResponse| { &m.shard_infos },
                |m: &mut GetInfoResponse| { &mut m.shard_infos },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "next_engine_version_timestamp",
                |m: &GetInfoResponse| { &m.next_engine_version_timestamp },
                |m: &mut GetInfoResponse| { &mut m.next_engine_version_timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInfoResponse>(
                "GetInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetInfoResponse {
    fn clear(&mut self) {
        self.version.clear();
        self.db_stats.clear();
        self.peerId.clear();
        self.num_shards = 0;
        self.shard_infos.clear();
        self.next_engine_version_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventRequest {
    // message fields
    pub id: u64,
    pub shard_index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventRequest {
    fn default() -> &'a EventRequest {
        <EventRequest as ::protobuf::Message>::default_instance()
    }
}

impl EventRequest {
    pub fn new() -> EventRequest {
        ::std::default::Default::default()
    }

    // uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // uint32 shard_index = 5;


    pub fn get_shard_index(&self) -> u32 {
        self.shard_index
    }
    pub fn clear_shard_index(&mut self) {
        self.shard_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_index(&mut self, v: u32) {
        self.shard_index = v;
    }
}

impl ::protobuf::Message for EventRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::value_size(5, self.shard_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.shard_index != 0 {
            os.write_uint32(5, self.shard_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventRequest {
        EventRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &EventRequest| { &m.id },
                |m: &mut EventRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_index",
                |m: &EventRequest| { &m.shard_index },
                |m: &mut EventRequest| { &mut m.shard_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventRequest>(
                "EventRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventRequest {
        static instance: ::protobuf::rt::LazyV2<EventRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventRequest::new)
    }
}

impl ::protobuf::Clear for EventRequest {
    fn clear(&mut self) {
        self.id = 0;
        self.shard_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidRequest {
    // message fields
    pub fid: u64,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidRequest {
    fn default() -> &'a FidRequest {
        <FidRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidRequest {
    pub fn new() -> FidRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // uint32 page_size = 2;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 3;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 4;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for FidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.page_size != 0 {
            os.write_uint32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(3, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(4, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidRequest {
        FidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &FidRequest| { &m.fid },
                |m: &mut FidRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &FidRequest| { &m.page_size },
                |m: &mut FidRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &FidRequest| { &m.page_token },
                |m: &mut FidRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &FidRequest| { &m.reverse },
                |m: &mut FidRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidRequest>(
                "FidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidRequest {
        static instance: ::protobuf::rt::LazyV2<FidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidRequest::new)
    }
}

impl ::protobuf::Clear for FidRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidTimestampRequest {
    // message fields
    pub fid: u64,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    pub start_timestamp: u64,
    pub stop_timestamp: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidTimestampRequest {
    fn default() -> &'a FidTimestampRequest {
        <FidTimestampRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidTimestampRequest {
    pub fn new() -> FidTimestampRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // uint32 page_size = 2;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 3;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 4;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }

    // uint64 start_timestamp = 5;


    pub fn get_start_timestamp(&self) -> u64 {
        self.start_timestamp
    }
    pub fn clear_start_timestamp(&mut self) {
        self.start_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp(&mut self, v: u64) {
        self.start_timestamp = v;
    }

    // uint64 stop_timestamp = 6;


    pub fn get_stop_timestamp(&self) -> u64 {
        self.stop_timestamp
    }
    pub fn clear_stop_timestamp(&mut self) {
        self.stop_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_stop_timestamp(&mut self, v: u64) {
        self.stop_timestamp = v;
    }
}

impl ::protobuf::Message for FidTimestampRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_timestamp = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stop_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if self.start_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.start_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stop_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.stop_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.page_size != 0 {
            os.write_uint32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(3, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(4, self.reverse)?;
        }
        if self.start_timestamp != 0 {
            os.write_uint64(5, self.start_timestamp)?;
        }
        if self.stop_timestamp != 0 {
            os.write_uint64(6, self.stop_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidTimestampRequest {
        FidTimestampRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &FidTimestampRequest| { &m.fid },
                |m: &mut FidTimestampRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &FidTimestampRequest| { &m.page_size },
                |m: &mut FidTimestampRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &FidTimestampRequest| { &m.page_token },
                |m: &mut FidTimestampRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &FidTimestampRequest| { &m.reverse },
                |m: &mut FidTimestampRequest| { &mut m.reverse },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start_timestamp",
                |m: &FidTimestampRequest| { &m.start_timestamp },
                |m: &mut FidTimestampRequest| { &mut m.start_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "stop_timestamp",
                |m: &FidTimestampRequest| { &m.stop_timestamp },
                |m: &mut FidTimestampRequest| { &mut m.stop_timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidTimestampRequest>(
                "FidTimestampRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidTimestampRequest {
        static instance: ::protobuf::rt::LazyV2<FidTimestampRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidTimestampRequest::new)
    }
}

impl ::protobuf::Clear for FidTimestampRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.start_timestamp = 0;
        self.stop_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidTimestampRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidTimestampRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidsRequest {
    // message fields
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    pub shard_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidsRequest {
    fn default() -> &'a FidsRequest {
        <FidsRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidsRequest {
    pub fn new() -> FidsRequest {
        ::std::default::Default::default()
    }

    // uint32 page_size = 1;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 2;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 3;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }

    // uint32 shard_id = 4;


    pub fn get_shard_id(&self) -> u32 {
        self.shard_id
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: u32) {
        self.shard_id = v;
    }
}

impl ::protobuf::Message for FidsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.shard_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page_size != 0 {
            os.write_uint32(1, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(2, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(3, self.reverse)?;
        }
        if self.shard_id != 0 {
            os.write_uint32(4, self.shard_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidsRequest {
        FidsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &FidsRequest| { &m.page_size },
                |m: &mut FidsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &FidsRequest| { &m.page_token },
                |m: &mut FidsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &FidsRequest| { &m.reverse },
                |m: &mut FidsRequest| { &mut m.reverse },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_id",
                |m: &FidsRequest| { &m.shard_id },
                |m: &mut FidsRequest| { &mut m.shard_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidsRequest>(
                "FidsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidsRequest {
        static instance: ::protobuf::rt::LazyV2<FidsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidsRequest::new)
    }
}

impl ::protobuf::Clear for FidsRequest {
    fn clear(&mut self) {
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.shard_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidsResponse {
    // message fields
    pub fids: ::std::vec::Vec<u64>,
    pub next_page_token: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidsResponse {
    fn default() -> &'a FidsResponse {
        <FidsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FidsResponse {
    pub fn new() -> FidsResponse {
        ::std::default::Default::default()
    }

    // repeated uint64 fids = 1;


    pub fn get_fids(&self) -> &[u64] {
        &self.fids
    }
    pub fn clear_fids(&mut self) {
        self.fids.clear();
    }

    // Param is passed by value, moved
    pub fn set_fids(&mut self, v: ::std::vec::Vec<u64>) {
        self.fids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.fids
    }

    // Take field
    pub fn take_fids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.fids, ::std::vec::Vec::new())
    }

    // bytes next_page_token = 2;


    pub fn get_next_page_token(&self) -> &[u8] {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.next_page_token, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FidsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.fids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fids {
            os.write_uint64(1, *v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_bytes(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidsResponse {
        FidsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fids",
                |m: &FidsResponse| { &m.fids },
                |m: &mut FidsResponse| { &mut m.fids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_page_token",
                |m: &FidsResponse| { &m.next_page_token },
                |m: &mut FidsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidsResponse>(
                "FidsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidsResponse {
        static instance: ::protobuf::rt::LazyV2<FidsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidsResponse::new)
    }
}

impl ::protobuf::Clear for FidsResponse {
    fn clear(&mut self) {
        self.fids.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagesResponse {
    // message fields
    pub messages: ::protobuf::RepeatedField<super::message::Message>,
    pub next_page_token: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagesResponse {
    fn default() -> &'a MessagesResponse {
        <MessagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessagesResponse {
    pub fn new() -> MessagesResponse {
        ::std::default::Default::default()
    }

    // repeated .Message messages = 1;


    pub fn get_messages(&self) -> &[super::message::Message] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<super::message::Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<super::message::Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<super::message::Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }

    // bytes next_page_token = 2;


    pub fn get_next_page_token(&self) -> &[u8] {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.next_page_token, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MessagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_bytes(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagesResponse {
        MessagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Message>>(
                "messages",
                |m: &MessagesResponse| { &m.messages },
                |m: &mut MessagesResponse| { &mut m.messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_page_token",
                |m: &MessagesResponse| { &m.next_page_token },
                |m: &mut MessagesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagesResponse>(
                "MessagesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessagesResponse {
        static instance: ::protobuf::rt::LazyV2<MessagesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessagesResponse::new)
    }
}

impl ::protobuf::Clear for MessagesResponse {
    fn clear(&mut self) {
        self.messages.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CastsByParentRequest {
    // message fields
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // message oneof groups
    pub parent: ::std::option::Option<CastsByParentRequest_oneof_parent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CastsByParentRequest {
    fn default() -> &'a CastsByParentRequest {
        <CastsByParentRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CastsByParentRequest_oneof_parent {
    parent_cast_id(super::message::CastId),
    parent_url(::std::string::String),
}

impl CastsByParentRequest {
    pub fn new() -> CastsByParentRequest {
        ::std::default::Default::default()
    }

    // .CastId parent_cast_id = 1;


    pub fn get_parent_cast_id(&self) -> &super::message::CastId {
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_parent_cast_id(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent_cast_id(&self) -> bool {
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_cast_id(&mut self, v: super::message::CastId) {
        self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(_)) = self.parent {
        } else {
            self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(super::message::CastId::new()));
        }
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_cast_id(&mut self) -> super::message::CastId {
        if self.has_parent_cast_id() {
            match self.parent.take() {
                ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string parent_url = 5;


    pub fn get_parent_url(&self) -> &str {
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_parent_url(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent_url(&self) -> bool {
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_url(&mut self, v: ::std::string::String) {
        self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(_)) = self.parent {
        } else {
            self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(::std::string::String::new()));
        }
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_url(&mut self) -> ::std::string::String {
        if self.has_parent_url() {
            match self.parent.take() {
                ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint32 page_size = 2;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 3;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 4;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for CastsByParentRequest {
    fn is_initialized(&self) -> bool {
        if let Some(CastsByParentRequest_oneof_parent::parent_cast_id(ref v)) = self.parent {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.parent {
            match v {
                &CastsByParentRequest_oneof_parent::parent_cast_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CastsByParentRequest_oneof_parent::parent_url(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page_size != 0 {
            os.write_uint32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(3, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(4, self.reverse)?;
        }
        if let ::std::option::Option::Some(ref v) = self.parent {
            match v {
                &CastsByParentRequest_oneof_parent::parent_cast_id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CastsByParentRequest_oneof_parent::parent_url(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CastsByParentRequest {
        CastsByParentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::message::CastId>(
                "parent_cast_id",
                CastsByParentRequest::has_parent_cast_id,
                CastsByParentRequest::get_parent_cast_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "parent_url",
                CastsByParentRequest::has_parent_url,
                CastsByParentRequest::get_parent_url,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &CastsByParentRequest| { &m.page_size },
                |m: &mut CastsByParentRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &CastsByParentRequest| { &m.page_token },
                |m: &mut CastsByParentRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &CastsByParentRequest| { &m.reverse },
                |m: &mut CastsByParentRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CastsByParentRequest>(
                "CastsByParentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CastsByParentRequest {
        static instance: ::protobuf::rt::LazyV2<CastsByParentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CastsByParentRequest::new)
    }
}

impl ::protobuf::Clear for CastsByParentRequest {
    fn clear(&mut self) {
        self.parent = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CastsByParentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CastsByParentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReactionRequest {
    // message fields
    pub fid: u64,
    pub reaction_type: super::message::ReactionType,
    // message oneof groups
    pub target: ::std::option::Option<ReactionRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReactionRequest {
    fn default() -> &'a ReactionRequest {
        <ReactionRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ReactionRequest_oneof_target {
    target_cast_id(super::message::CastId),
    target_url(::std::string::String),
}

impl ReactionRequest {
    pub fn new() -> ReactionRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // .ReactionType reaction_type = 2;


    pub fn get_reaction_type(&self) -> super::message::ReactionType {
        self.reaction_type
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: super::message::ReactionType) {
        self.reaction_type = v;
    }

    // .CastId target_cast_id = 3;


    pub fn get_target_cast_id(&self) -> &super::message::CastId {
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_target_cast_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_cast_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_cast_id(&mut self, v: super::message::CastId) {
        self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(super::message::CastId::new()));
        }
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_cast_id(&mut self) -> super::message::CastId {
        if self.has_target_cast_id() {
            match self.target.take() {
                ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string target_url = 4;


    pub fn get_target_url(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_target_url(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_url(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_url(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_url(&mut self) -> ::std::string::String {
        if self.has_target_url() {
            match self.target.take() {
                ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for ReactionRequest {
    fn is_initialized(&self) -> bool {
        if let Some(ReactionRequest_oneof_target::target_cast_id(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.reaction_type);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ReactionRequest_oneof_target::target_cast_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ReactionRequest_oneof_target::target_url(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.reaction_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ReactionRequest_oneof_target::target_cast_id(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ReactionRequest_oneof_target::target_url(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReactionRequest {
        ReactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &ReactionRequest| { &m.fid },
                |m: &mut ReactionRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::ReactionType>>(
                "reaction_type",
                |m: &ReactionRequest| { &m.reaction_type },
                |m: &mut ReactionRequest| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::message::CastId>(
                "target_cast_id",
                ReactionRequest::has_target_cast_id,
                ReactionRequest::get_target_cast_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "target_url",
                ReactionRequest::has_target_url,
                ReactionRequest::get_target_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReactionRequest>(
                "ReactionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReactionRequest {
        static instance: ::protobuf::rt::LazyV2<ReactionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReactionRequest::new)
    }
}

impl ::protobuf::Clear for ReactionRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReactionsByFidRequest {
    // message fields
    pub fid: u64,
    pub reaction_type: super::message::ReactionType,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReactionsByFidRequest {
    fn default() -> &'a ReactionsByFidRequest {
        <ReactionsByFidRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReactionsByFidRequest {
    pub fn new() -> ReactionsByFidRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // .ReactionType reaction_type = 2;


    pub fn get_reaction_type(&self) -> super::message::ReactionType {
        self.reaction_type
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: super::message::ReactionType) {
        self.reaction_type = v;
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for ReactionsByFidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.reaction_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.reaction_type))?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReactionsByFidRequest {
        ReactionsByFidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &ReactionsByFidRequest| { &m.fid },
                |m: &mut ReactionsByFidRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::ReactionType>>(
                "reaction_type",
                |m: &ReactionsByFidRequest| { &m.reaction_type },
                |m: &mut ReactionsByFidRequest| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &ReactionsByFidRequest| { &m.page_size },
                |m: &mut ReactionsByFidRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &ReactionsByFidRequest| { &m.page_token },
                |m: &mut ReactionsByFidRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &ReactionsByFidRequest| { &m.reverse },
                |m: &mut ReactionsByFidRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReactionsByFidRequest>(
                "ReactionsByFidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReactionsByFidRequest {
        static instance: ::protobuf::rt::LazyV2<ReactionsByFidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReactionsByFidRequest::new)
    }
}

impl ::protobuf::Clear for ReactionsByFidRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReactionsByFidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionsByFidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReactionsByTargetRequest {
    // message fields
    pub reaction_type: super::message::ReactionType,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // message oneof groups
    pub target: ::std::option::Option<ReactionsByTargetRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReactionsByTargetRequest {
    fn default() -> &'a ReactionsByTargetRequest {
        <ReactionsByTargetRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ReactionsByTargetRequest_oneof_target {
    target_cast_id(super::message::CastId),
    target_url(::std::string::String),
}

impl ReactionsByTargetRequest {
    pub fn new() -> ReactionsByTargetRequest {
        ::std::default::Default::default()
    }

    // .CastId target_cast_id = 1;


    pub fn get_target_cast_id(&self) -> &super::message::CastId {
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_target_cast_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_cast_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_cast_id(&mut self, v: super::message::CastId) {
        self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(super::message::CastId::new()));
        }
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_cast_id(&mut self) -> super::message::CastId {
        if self.has_target_cast_id() {
            match self.target.take() {
                ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string target_url = 6;


    pub fn get_target_url(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_target_url(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_url(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_url(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_url(&mut self) -> ::std::string::String {
        if self.has_target_url() {
            match self.target.take() {
                ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .ReactionType reaction_type = 2;


    pub fn get_reaction_type(&self) -> super::message::ReactionType {
        self.reaction_type
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: super::message::ReactionType) {
        self.reaction_type = v;
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for ReactionsByTargetRequest {
    fn is_initialized(&self) -> bool {
        if let Some(ReactionsByTargetRequest_oneof_target::target_cast_id(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(is.read_string()?));
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.reaction_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ReactionsByTargetRequest_oneof_target::target_cast_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ReactionsByTargetRequest_oneof_target::target_url(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.reaction_type))?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ReactionsByTargetRequest_oneof_target::target_cast_id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ReactionsByTargetRequest_oneof_target::target_url(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReactionsByTargetRequest {
        ReactionsByTargetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::message::CastId>(
                "target_cast_id",
                ReactionsByTargetRequest::has_target_cast_id,
                ReactionsByTargetRequest::get_target_cast_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "target_url",
                ReactionsByTargetRequest::has_target_url,
                ReactionsByTargetRequest::get_target_url,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::ReactionType>>(
                "reaction_type",
                |m: &ReactionsByTargetRequest| { &m.reaction_type },
                |m: &mut ReactionsByTargetRequest| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &ReactionsByTargetRequest| { &m.page_size },
                |m: &mut ReactionsByTargetRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &ReactionsByTargetRequest| { &m.page_token },
                |m: &mut ReactionsByTargetRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &ReactionsByTargetRequest| { &m.reverse },
                |m: &mut ReactionsByTargetRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReactionsByTargetRequest>(
                "ReactionsByTargetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReactionsByTargetRequest {
        static instance: ::protobuf::rt::LazyV2<ReactionsByTargetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReactionsByTargetRequest::new)
    }
}

impl ::protobuf::Clear for ReactionsByTargetRequest {
    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReactionsByTargetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionsByTargetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserDataRequest {
    // message fields
    pub fid: u64,
    pub user_data_type: super::message::UserDataType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserDataRequest {
    fn default() -> &'a UserDataRequest {
        <UserDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserDataRequest {
    pub fn new() -> UserDataRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // .UserDataType user_data_type = 2;


    pub fn get_user_data_type(&self) -> super::message::UserDataType {
        self.user_data_type
    }
    pub fn clear_user_data_type(&mut self) {
        self.user_data_type = super::message::UserDataType::USER_DATA_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_user_data_type(&mut self, v: super::message::UserDataType) {
        self.user_data_type = v;
    }
}

impl ::protobuf::Message for UserDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.user_data_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.user_data_type != super::message::UserDataType::USER_DATA_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.user_data_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.user_data_type != super::message::UserDataType::USER_DATA_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.user_data_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserDataRequest {
        UserDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &UserDataRequest| { &m.fid },
                |m: &mut UserDataRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::UserDataType>>(
                "user_data_type",
                |m: &UserDataRequest| { &m.user_data_type },
                |m: &mut UserDataRequest| { &mut m.user_data_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserDataRequest>(
                "UserDataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserDataRequest {
        static instance: ::protobuf::rt::LazyV2<UserDataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserDataRequest::new)
    }
}

impl ::protobuf::Clear for UserDataRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.user_data_type = super::message::UserDataType::USER_DATA_TYPE_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnChainEventRequest {
    // message fields
    pub fid: u64,
    pub event_type: super::onchain_event::OnChainEventType,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnChainEventRequest {
    fn default() -> &'a OnChainEventRequest {
        <OnChainEventRequest as ::protobuf::Message>::default_instance()
    }
}

impl OnChainEventRequest {
    pub fn new() -> OnChainEventRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // .OnChainEventType event_type = 2;


    pub fn get_event_type(&self) -> super::onchain_event::OnChainEventType {
        self.event_type
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = super::onchain_event::OnChainEventType::EVENT_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: super::onchain_event::OnChainEventType) {
        self.event_type = v;
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for OnChainEventRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.event_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.event_type != super::onchain_event::OnChainEventType::EVENT_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.event_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.event_type != super::onchain_event::OnChainEventType::EVENT_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.event_type))?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnChainEventRequest {
        OnChainEventRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &OnChainEventRequest| { &m.fid },
                |m: &mut OnChainEventRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::onchain_event::OnChainEventType>>(
                "event_type",
                |m: &OnChainEventRequest| { &m.event_type },
                |m: &mut OnChainEventRequest| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &OnChainEventRequest| { &m.page_size },
                |m: &mut OnChainEventRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &OnChainEventRequest| { &m.page_token },
                |m: &mut OnChainEventRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &OnChainEventRequest| { &m.reverse },
                |m: &mut OnChainEventRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OnChainEventRequest>(
                "OnChainEventRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OnChainEventRequest {
        static instance: ::protobuf::rt::LazyV2<OnChainEventRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OnChainEventRequest::new)
    }
}

impl ::protobuf::Clear for OnChainEventRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.event_type = super::onchain_event::OnChainEventType::EVENT_TYPE_NONE;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnChainEventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnChainEventRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnChainEventResponse {
    // message fields
    pub events: ::protobuf::RepeatedField<super::onchain_event::OnChainEvent>,
    pub next_page_token: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnChainEventResponse {
    fn default() -> &'a OnChainEventResponse {
        <OnChainEventResponse as ::protobuf::Message>::default_instance()
    }
}

impl OnChainEventResponse {
    pub fn new() -> OnChainEventResponse {
        ::std::default::Default::default()
    }

    // repeated .OnChainEvent events = 1;


    pub fn get_events(&self) -> &[super::onchain_event::OnChainEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<super::onchain_event::OnChainEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<super::onchain_event::OnChainEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<super::onchain_event::OnChainEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // bytes next_page_token = 2;


    pub fn get_next_page_token(&self) -> &[u8] {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.next_page_token, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OnChainEventResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_bytes(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnChainEventResponse {
        OnChainEventResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::onchain_event::OnChainEvent>>(
                "events",
                |m: &OnChainEventResponse| { &m.events },
                |m: &mut OnChainEventResponse| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_page_token",
                |m: &OnChainEventResponse| { &m.next_page_token },
                |m: &mut OnChainEventResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OnChainEventResponse>(
                "OnChainEventResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OnChainEventResponse {
        static instance: ::protobuf::rt::LazyV2<OnChainEventResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OnChainEventResponse::new)
    }
}

impl ::protobuf::Clear for OnChainEventResponse {
    fn clear(&mut self) {
        self.events.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnChainEventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnChainEventResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TierDetails {
    // message fields
    pub tier_type: super::onchain_event::TierType,
    pub expires_at: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TierDetails {
    fn default() -> &'a TierDetails {
        <TierDetails as ::protobuf::Message>::default_instance()
    }
}

impl TierDetails {
    pub fn new() -> TierDetails {
        ::std::default::Default::default()
    }

    // .TierType tier_type = 1;


    pub fn get_tier_type(&self) -> super::onchain_event::TierType {
        self.tier_type
    }
    pub fn clear_tier_type(&mut self) {
        self.tier_type = super::onchain_event::TierType::None;
    }

    // Param is passed by value, moved
    pub fn set_tier_type(&mut self, v: super::onchain_event::TierType) {
        self.tier_type = v;
    }

    // uint64 expires_at = 2;


    pub fn get_expires_at(&self) -> u64 {
        self.expires_at
    }
    pub fn clear_expires_at(&mut self) {
        self.expires_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_expires_at(&mut self, v: u64) {
        self.expires_at = v;
    }
}

impl ::protobuf::Message for TierDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.tier_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expires_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tier_type != super::onchain_event::TierType::None {
            my_size += ::protobuf::rt::enum_size(1, self.tier_type);
        }
        if self.expires_at != 0 {
            my_size += ::protobuf::rt::value_size(2, self.expires_at, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tier_type != super::onchain_event::TierType::None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.tier_type))?;
        }
        if self.expires_at != 0 {
            os.write_uint64(2, self.expires_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TierDetails {
        TierDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::onchain_event::TierType>>(
                "tier_type",
                |m: &TierDetails| { &m.tier_type },
                |m: &mut TierDetails| { &mut m.tier_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "expires_at",
                |m: &TierDetails| { &m.expires_at },
                |m: &mut TierDetails| { &mut m.expires_at },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TierDetails>(
                "TierDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TierDetails {
        static instance: ::protobuf::rt::LazyV2<TierDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TierDetails::new)
    }
}

impl ::protobuf::Clear for TierDetails {
    fn clear(&mut self) {
        self.tier_type = super::onchain_event::TierType::None;
        self.expires_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TierDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TierDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageLimitsResponse {
    // message fields
    pub limits: ::protobuf::RepeatedField<StorageLimit>,
    pub units: u32,
    pub unit_details: ::protobuf::RepeatedField<StorageUnitDetails>,
    pub tier_subscriptions: ::protobuf::RepeatedField<TierDetails>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageLimitsResponse {
    fn default() -> &'a StorageLimitsResponse {
        <StorageLimitsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StorageLimitsResponse {
    pub fn new() -> StorageLimitsResponse {
        ::std::default::Default::default()
    }

    // repeated .StorageLimit limits = 1;


    pub fn get_limits(&self) -> &[StorageLimit] {
        &self.limits
    }
    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::protobuf::RepeatedField<StorageLimit>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::protobuf::RepeatedField<StorageLimit> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::protobuf::RepeatedField<StorageLimit> {
        ::std::mem::replace(&mut self.limits, ::protobuf::RepeatedField::new())
    }

    // uint32 units = 2;


    pub fn get_units(&self) -> u32 {
        self.units
    }
    pub fn clear_units(&mut self) {
        self.units = 0;
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: u32) {
        self.units = v;
    }

    // repeated .StorageUnitDetails unit_details = 3;


    pub fn get_unit_details(&self) -> &[StorageUnitDetails] {
        &self.unit_details
    }
    pub fn clear_unit_details(&mut self) {
        self.unit_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_details(&mut self, v: ::protobuf::RepeatedField<StorageUnitDetails>) {
        self.unit_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_details(&mut self) -> &mut ::protobuf::RepeatedField<StorageUnitDetails> {
        &mut self.unit_details
    }

    // Take field
    pub fn take_unit_details(&mut self) -> ::protobuf::RepeatedField<StorageUnitDetails> {
        ::std::mem::replace(&mut self.unit_details, ::protobuf::RepeatedField::new())
    }

    // repeated .TierDetails tier_subscriptions = 4;


    pub fn get_tier_subscriptions(&self) -> &[TierDetails] {
        &self.tier_subscriptions
    }
    pub fn clear_tier_subscriptions(&mut self) {
        self.tier_subscriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_tier_subscriptions(&mut self, v: ::protobuf::RepeatedField<TierDetails>) {
        self.tier_subscriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tier_subscriptions(&mut self) -> &mut ::protobuf::RepeatedField<TierDetails> {
        &mut self.tier_subscriptions
    }

    // Take field
    pub fn take_tier_subscriptions(&mut self) -> ::protobuf::RepeatedField<TierDetails> {
        ::std::mem::replace(&mut self.tier_subscriptions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StorageLimitsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tier_subscriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limits)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.units = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unit_details)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tier_subscriptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.units != 0 {
            my_size += ::protobuf::rt::value_size(2, self.units, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unit_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tier_subscriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.limits {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.units != 0 {
            os.write_uint32(2, self.units)?;
        }
        for v in &self.unit_details {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tier_subscriptions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageLimitsResponse {
        StorageLimitsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageLimit>>(
                "limits",
                |m: &StorageLimitsResponse| { &m.limits },
                |m: &mut StorageLimitsResponse| { &mut m.limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "units",
                |m: &StorageLimitsResponse| { &m.units },
                |m: &mut StorageLimitsResponse| { &mut m.units },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageUnitDetails>>(
                "unit_details",
                |m: &StorageLimitsResponse| { &m.unit_details },
                |m: &mut StorageLimitsResponse| { &mut m.unit_details },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TierDetails>>(
                "tier_subscriptions",
                |m: &StorageLimitsResponse| { &m.tier_subscriptions },
                |m: &mut StorageLimitsResponse| { &mut m.tier_subscriptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageLimitsResponse>(
                "StorageLimitsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageLimitsResponse {
        static instance: ::protobuf::rt::LazyV2<StorageLimitsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageLimitsResponse::new)
    }
}

impl ::protobuf::Clear for StorageLimitsResponse {
    fn clear(&mut self) {
        self.limits.clear();
        self.units = 0;
        self.unit_details.clear();
        self.tier_subscriptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageLimitsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageLimitsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageUnitDetails {
    // message fields
    pub unit_type: super::message::StorageUnitType,
    pub unit_size: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageUnitDetails {
    fn default() -> &'a StorageUnitDetails {
        <StorageUnitDetails as ::protobuf::Message>::default_instance()
    }
}

impl StorageUnitDetails {
    pub fn new() -> StorageUnitDetails {
        ::std::default::Default::default()
    }

    // .StorageUnitType unit_type = 1;


    pub fn get_unit_type(&self) -> super::message::StorageUnitType {
        self.unit_type
    }
    pub fn clear_unit_type(&mut self) {
        self.unit_type = super::message::StorageUnitType::UNIT_TYPE_LEGACY;
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: super::message::StorageUnitType) {
        self.unit_type = v;
    }

    // uint32 unit_size = 2;


    pub fn get_unit_size(&self) -> u32 {
        self.unit_size
    }
    pub fn clear_unit_size(&mut self) {
        self.unit_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_unit_size(&mut self, v: u32) {
        self.unit_size = v;
    }
}

impl ::protobuf::Message for StorageUnitDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.unit_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unit_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.unit_type != super::message::StorageUnitType::UNIT_TYPE_LEGACY {
            my_size += ::protobuf::rt::enum_size(1, self.unit_type);
        }
        if self.unit_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.unit_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.unit_type != super::message::StorageUnitType::UNIT_TYPE_LEGACY {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.unit_type))?;
        }
        if self.unit_size != 0 {
            os.write_uint32(2, self.unit_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageUnitDetails {
        StorageUnitDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::StorageUnitType>>(
                "unit_type",
                |m: &StorageUnitDetails| { &m.unit_type },
                |m: &mut StorageUnitDetails| { &mut m.unit_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unit_size",
                |m: &StorageUnitDetails| { &m.unit_size },
                |m: &mut StorageUnitDetails| { &mut m.unit_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageUnitDetails>(
                "StorageUnitDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageUnitDetails {
        static instance: ::protobuf::rt::LazyV2<StorageUnitDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageUnitDetails::new)
    }
}

impl ::protobuf::Clear for StorageUnitDetails {
    fn clear(&mut self) {
        self.unit_type = super::message::StorageUnitType::UNIT_TYPE_LEGACY;
        self.unit_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageUnitDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageUnitDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageLimit {
    // message fields
    pub store_type: StoreType,
    pub name: ::std::string::String,
    pub limit: u64,
    pub used: u64,
    pub earliestTimestamp: u64,
    pub earliestHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageLimit {
    fn default() -> &'a StorageLimit {
        <StorageLimit as ::protobuf::Message>::default_instance()
    }
}

impl StorageLimit {
    pub fn new() -> StorageLimit {
        ::std::default::Default::default()
    }

    // .StoreType store_type = 1;


    pub fn get_store_type(&self) -> StoreType {
        self.store_type
    }
    pub fn clear_store_type(&mut self) {
        self.store_type = StoreType::STORE_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_store_type(&mut self, v: StoreType) {
        self.store_type = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 limit = 3;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    // uint64 used = 4;


    pub fn get_used(&self) -> u64 {
        self.used
    }
    pub fn clear_used(&mut self) {
        self.used = 0;
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: u64) {
        self.used = v;
    }

    // uint64 earliestTimestamp = 5;


    pub fn get_earliestTimestamp(&self) -> u64 {
        self.earliestTimestamp
    }
    pub fn clear_earliestTimestamp(&mut self) {
        self.earliestTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_earliestTimestamp(&mut self, v: u64) {
        self.earliestTimestamp = v;
    }

    // bytes earliestHash = 6;


    pub fn get_earliestHash(&self) -> &[u8] {
        &self.earliestHash
    }
    pub fn clear_earliestHash(&mut self) {
        self.earliestHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_earliestHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.earliestHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_earliestHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.earliestHash
    }

    // Take field
    pub fn take_earliestHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.earliestHash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StorageLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.store_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.used = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.earliestTimestamp = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.earliestHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.store_type != StoreType::STORE_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.store_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.used != 0 {
            my_size += ::protobuf::rt::value_size(4, self.used, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.earliestTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.earliestTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.earliestHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.earliestHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.store_type != StoreType::STORE_TYPE_NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.store_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.limit != 0 {
            os.write_uint64(3, self.limit)?;
        }
        if self.used != 0 {
            os.write_uint64(4, self.used)?;
        }
        if self.earliestTimestamp != 0 {
            os.write_uint64(5, self.earliestTimestamp)?;
        }
        if !self.earliestHash.is_empty() {
            os.write_bytes(6, &self.earliestHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageLimit {
        StorageLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StoreType>>(
                "store_type",
                |m: &StorageLimit| { &m.store_type },
                |m: &mut StorageLimit| { &mut m.store_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &StorageLimit| { &m.name },
                |m: &mut StorageLimit| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "limit",
                |m: &StorageLimit| { &m.limit },
                |m: &mut StorageLimit| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "used",
                |m: &StorageLimit| { &m.used },
                |m: &mut StorageLimit| { &mut m.used },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "earliestTimestamp",
                |m: &StorageLimit| { &m.earliestTimestamp },
                |m: &mut StorageLimit| { &mut m.earliestTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "earliestHash",
                |m: &StorageLimit| { &m.earliestHash },
                |m: &mut StorageLimit| { &mut m.earliestHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageLimit>(
                "StorageLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageLimit {
        static instance: ::protobuf::rt::LazyV2<StorageLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageLimit::new)
    }
}

impl ::protobuf::Clear for StorageLimit {
    fn clear(&mut self) {
        self.store_type = StoreType::STORE_TYPE_NONE;
        self.name.clear();
        self.limit = 0;
        self.used = 0;
        self.earliestTimestamp = 0;
        self.earliestHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UsernameProofRequest {
    // message fields
    pub name: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UsernameProofRequest {
    fn default() -> &'a UsernameProofRequest {
        <UsernameProofRequest as ::protobuf::Message>::default_instance()
    }
}

impl UsernameProofRequest {
    pub fn new() -> UsernameProofRequest {
        ::std::default::Default::default()
    }

    // bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UsernameProofRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UsernameProofRequest {
        UsernameProofRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &UsernameProofRequest| { &m.name },
                |m: &mut UsernameProofRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UsernameProofRequest>(
                "UsernameProofRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UsernameProofRequest {
        static instance: ::protobuf::rt::LazyV2<UsernameProofRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UsernameProofRequest::new)
    }
}

impl ::protobuf::Clear for UsernameProofRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UsernameProofRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsernameProofRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UsernameProofsResponse {
    // message fields
    pub proofs: ::protobuf::RepeatedField<super::username_proof::UserNameProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UsernameProofsResponse {
    fn default() -> &'a UsernameProofsResponse {
        <UsernameProofsResponse as ::protobuf::Message>::default_instance()
    }
}

impl UsernameProofsResponse {
    pub fn new() -> UsernameProofsResponse {
        ::std::default::Default::default()
    }

    // repeated .UserNameProof proofs = 1;


    pub fn get_proofs(&self) -> &[super::username_proof::UserNameProof] {
        &self.proofs
    }
    pub fn clear_proofs(&mut self) {
        self.proofs.clear();
    }

    // Param is passed by value, moved
    pub fn set_proofs(&mut self, v: ::protobuf::RepeatedField<super::username_proof::UserNameProof>) {
        self.proofs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_proofs(&mut self) -> &mut ::protobuf::RepeatedField<super::username_proof::UserNameProof> {
        &mut self.proofs
    }

    // Take field
    pub fn take_proofs(&mut self) -> ::protobuf::RepeatedField<super::username_proof::UserNameProof> {
        ::std::mem::replace(&mut self.proofs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UsernameProofsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.proofs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.proofs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.proofs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.proofs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UsernameProofsResponse {
        UsernameProofsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::username_proof::UserNameProof>>(
                "proofs",
                |m: &UsernameProofsResponse| { &m.proofs },
                |m: &mut UsernameProofsResponse| { &mut m.proofs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UsernameProofsResponse>(
                "UsernameProofsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UsernameProofsResponse {
        static instance: ::protobuf::rt::LazyV2<UsernameProofsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UsernameProofsResponse::new)
    }
}

impl ::protobuf::Clear for UsernameProofsResponse {
    fn clear(&mut self) {
        self.proofs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UsernameProofsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsernameProofsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidationResponse {
    // message fields
    pub valid: bool,
    pub message: ::protobuf::SingularPtrField<super::message::Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidationResponse {
    fn default() -> &'a ValidationResponse {
        <ValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl ValidationResponse {
    pub fn new() -> ValidationResponse {
        ::std::default::Default::default()
    }

    // bool valid = 1;


    pub fn get_valid(&self) -> bool {
        self.valid
    }
    pub fn clear_valid(&mut self) {
        self.valid = false;
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = v;
    }

    // .Message message = 2;


    pub fn get_message(&self) -> &super::message::Message {
        self.message.as_ref().unwrap_or_else(|| <super::message::Message as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::message::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::message::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::message::Message {
        self.message.take().unwrap_or_else(|| super::message::Message::new())
    }
}

impl ::protobuf::Message for ValidationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.valid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.valid != false {
            my_size += 2;
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.valid != false {
            os.write_bool(1, self.valid)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidationResponse {
        ValidationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "valid",
                |m: &ValidationResponse| { &m.valid },
                |m: &mut ValidationResponse| { &mut m.valid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Message>>(
                "message",
                |m: &ValidationResponse| { &m.message },
                |m: &mut ValidationResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidationResponse>(
                "ValidationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidationResponse {
        static instance: ::protobuf::rt::LazyV2<ValidationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidationResponse::new)
    }
}

impl ::protobuf::Clear for ValidationResponse {
    fn clear(&mut self) {
        self.valid = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerificationRequest {
    // message fields
    pub fid: u64,
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerificationRequest {
    fn default() -> &'a VerificationRequest {
        <VerificationRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerificationRequest {
    pub fn new() -> VerificationRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VerificationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerificationRequest {
        VerificationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &VerificationRequest| { &m.fid },
                |m: &mut VerificationRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &VerificationRequest| { &m.address },
                |m: &mut VerificationRequest| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerificationRequest>(
                "VerificationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerificationRequest {
        static instance: ::protobuf::rt::LazyV2<VerificationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerificationRequest::new)
    }
}

impl ::protobuf::Clear for VerificationRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerificationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignerRequest {
    // message fields
    pub fid: u64,
    pub signer: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignerRequest {
    fn default() -> &'a SignerRequest {
        <SignerRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignerRequest {
    pub fn new() -> SignerRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // bytes signer = 2;


    pub fn get_signer(&self) -> &[u8] {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::vec::Vec<u8>) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signer, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.signer.is_empty() {
            os.write_bytes(2, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignerRequest {
        SignerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &SignerRequest| { &m.fid },
                |m: &mut SignerRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signer",
                |m: &SignerRequest| { &m.signer },
                |m: &mut SignerRequest| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignerRequest>(
                "SignerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignerRequest {
        static instance: ::protobuf::rt::LazyV2<SignerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignerRequest::new)
    }
}

impl ::protobuf::Clear for SignerRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinkRequest {
    // message fields
    pub fid: u64,
    pub link_type: ::std::string::String,
    // message oneof groups
    pub target: ::std::option::Option<LinkRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinkRequest {
    fn default() -> &'a LinkRequest {
        <LinkRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LinkRequest_oneof_target {
    target_fid(u64),
}

impl LinkRequest {
    pub fn new() -> LinkRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // string link_type = 2;


    pub fn get_link_type(&self) -> &str {
        &self.link_type
    }
    pub fn clear_link_type(&mut self) {
        self.link_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_type(&mut self, v: ::std::string::String) {
        self.link_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_type(&mut self) -> &mut ::std::string::String {
        &mut self.link_type
    }

    // Take field
    pub fn take_link_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_type, ::std::string::String::new())
    }

    // uint64 target_fid = 3;


    pub fn get_target_fid(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(LinkRequest_oneof_target::target_fid(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_target_fid(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_fid(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(LinkRequest_oneof_target::target_fid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_fid(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(LinkRequest_oneof_target::target_fid(v))
    }
}

impl ::protobuf::Message for LinkRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(LinkRequest_oneof_target::target_fid(is.read_uint64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.link_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.link_type);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &LinkRequest_oneof_target::target_fid(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.link_type.is_empty() {
            os.write_string(2, &self.link_type)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &LinkRequest_oneof_target::target_fid(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinkRequest {
        LinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &LinkRequest| { &m.fid },
                |m: &mut LinkRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "link_type",
                |m: &LinkRequest| { &m.link_type },
                |m: &mut LinkRequest| { &mut m.link_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "target_fid",
                LinkRequest::has_target_fid,
                LinkRequest::get_target_fid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinkRequest>(
                "LinkRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinkRequest {
        static instance: ::protobuf::rt::LazyV2<LinkRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinkRequest::new)
    }
}

impl ::protobuf::Clear for LinkRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.link_type.clear();
        self.target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinksByFidRequest {
    // message fields
    pub fid: u64,
    pub link_type: ::std::string::String,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinksByFidRequest {
    fn default() -> &'a LinksByFidRequest {
        <LinksByFidRequest as ::protobuf::Message>::default_instance()
    }
}

impl LinksByFidRequest {
    pub fn new() -> LinksByFidRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // string link_type = 2;


    pub fn get_link_type(&self) -> &str {
        &self.link_type
    }
    pub fn clear_link_type(&mut self) {
        self.link_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_type(&mut self, v: ::std::string::String) {
        self.link_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_type(&mut self) -> &mut ::std::string::String {
        &mut self.link_type
    }

    // Take field
    pub fn take_link_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_type, ::std::string::String::new())
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for LinksByFidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.link_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.link_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.link_type.is_empty() {
            os.write_string(2, &self.link_type)?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinksByFidRequest {
        LinksByFidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &LinksByFidRequest| { &m.fid },
                |m: &mut LinksByFidRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "link_type",
                |m: &LinksByFidRequest| { &m.link_type },
                |m: &mut LinksByFidRequest| { &mut m.link_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &LinksByFidRequest| { &m.page_size },
                |m: &mut LinksByFidRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &LinksByFidRequest| { &m.page_token },
                |m: &mut LinksByFidRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &LinksByFidRequest| { &m.reverse },
                |m: &mut LinksByFidRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinksByFidRequest>(
                "LinksByFidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinksByFidRequest {
        static instance: ::protobuf::rt::LazyV2<LinksByFidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinksByFidRequest::new)
    }
}

impl ::protobuf::Clear for LinksByFidRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.link_type.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinksByFidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinksByFidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinksByTargetRequest {
    // message fields
    pub link_type: ::std::string::String,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // message oneof groups
    pub target: ::std::option::Option<LinksByTargetRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinksByTargetRequest {
    fn default() -> &'a LinksByTargetRequest {
        <LinksByTargetRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LinksByTargetRequest_oneof_target {
    target_fid(u64),
}

impl LinksByTargetRequest {
    pub fn new() -> LinksByTargetRequest {
        ::std::default::Default::default()
    }

    // uint64 target_fid = 1;


    pub fn get_target_fid(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(LinksByTargetRequest_oneof_target::target_fid(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_target_fid(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_fid(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(LinksByTargetRequest_oneof_target::target_fid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_fid(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(LinksByTargetRequest_oneof_target::target_fid(v))
    }

    // string link_type = 2;


    pub fn get_link_type(&self) -> &str {
        &self.link_type
    }
    pub fn clear_link_type(&mut self) {
        self.link_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_type(&mut self, v: ::std::string::String) {
        self.link_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_type(&mut self) -> &mut ::std::string::String {
        &mut self.link_type
    }

    // Take field
    pub fn take_link_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_type, ::std::string::String::new())
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for LinksByTargetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(LinksByTargetRequest_oneof_target::target_fid(is.read_uint64()?));
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.link_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.link_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &LinksByTargetRequest_oneof_target::target_fid(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.link_type.is_empty() {
            os.write_string(2, &self.link_type)?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &LinksByTargetRequest_oneof_target::target_fid(v) => {
                    os.write_uint64(1, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinksByTargetRequest {
        LinksByTargetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "target_fid",
                LinksByTargetRequest::has_target_fid,
                LinksByTargetRequest::get_target_fid,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "link_type",
                |m: &LinksByTargetRequest| { &m.link_type },
                |m: &mut LinksByTargetRequest| { &mut m.link_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &LinksByTargetRequest| { &m.page_size },
                |m: &mut LinksByTargetRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &LinksByTargetRequest| { &m.page_token },
                |m: &mut LinksByTargetRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &LinksByTargetRequest| { &m.reverse },
                |m: &mut LinksByTargetRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinksByTargetRequest>(
                "LinksByTargetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinksByTargetRequest {
        static instance: ::protobuf::rt::LazyV2<LinksByTargetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinksByTargetRequest::new)
    }
}

impl ::protobuf::Clear for LinksByTargetRequest {
    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.link_type.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinksByTargetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinksByTargetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdRegistryEventByAddressRequest {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdRegistryEventByAddressRequest {
    fn default() -> &'a IdRegistryEventByAddressRequest {
        <IdRegistryEventByAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl IdRegistryEventByAddressRequest {
    pub fn new() -> IdRegistryEventByAddressRequest {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IdRegistryEventByAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdRegistryEventByAddressRequest {
        IdRegistryEventByAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &IdRegistryEventByAddressRequest| { &m.address },
                |m: &mut IdRegistryEventByAddressRequest| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdRegistryEventByAddressRequest>(
                "IdRegistryEventByAddressRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IdRegistryEventByAddressRequest {
        static instance: ::protobuf::rt::LazyV2<IdRegistryEventByAddressRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IdRegistryEventByAddressRequest::new)
    }
}

impl ::protobuf::Clear for IdRegistryEventByAddressRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdRegistryEventByAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdRegistryEventByAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitBulkMessagesRequest {
    // message fields
    pub messages: ::protobuf::RepeatedField<super::message::Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitBulkMessagesRequest {
    fn default() -> &'a SubmitBulkMessagesRequest {
        <SubmitBulkMessagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubmitBulkMessagesRequest {
    pub fn new() -> SubmitBulkMessagesRequest {
        ::std::default::Default::default()
    }

    // repeated .Message messages = 1;


    pub fn get_messages(&self) -> &[super::message::Message] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<super::message::Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<super::message::Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<super::message::Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubmitBulkMessagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitBulkMessagesRequest {
        SubmitBulkMessagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Message>>(
                "messages",
                |m: &SubmitBulkMessagesRequest| { &m.messages },
                |m: &mut SubmitBulkMessagesRequest| { &mut m.messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitBulkMessagesRequest>(
                "SubmitBulkMessagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitBulkMessagesRequest {
        static instance: ::protobuf::rt::LazyV2<SubmitBulkMessagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitBulkMessagesRequest::new)
    }
}

impl ::protobuf::Clear for SubmitBulkMessagesRequest {
    fn clear(&mut self) {
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitBulkMessagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitBulkMessagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageError {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub errCode: ::std::string::String,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageError {
    fn default() -> &'a MessageError {
        <MessageError as ::protobuf::Message>::default_instance()
    }
}

impl MessageError {
    pub fn new() -> MessageError {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // string errCode = 2;


    pub fn get_errCode(&self) -> &str {
        &self.errCode
    }
    pub fn clear_errCode(&mut self) {
        self.errCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_errCode(&mut self, v: ::std::string::String) {
        self.errCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errCode(&mut self) -> &mut ::std::string::String {
        &mut self.errCode
    }

    // Take field
    pub fn take_errCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errCode, ::std::string::String::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessageError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.errCode.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errCode);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.errCode.is_empty() {
            os.write_string(2, &self.errCode)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageError {
        MessageError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &MessageError| { &m.hash },
                |m: &mut MessageError| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errCode",
                |m: &MessageError| { &m.errCode },
                |m: &mut MessageError| { &mut m.errCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &MessageError| { &m.message },
                |m: &mut MessageError| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageError>(
                "MessageError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessageError {
        static instance: ::protobuf::rt::LazyV2<MessageError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageError::new)
    }
}

impl ::protobuf::Clear for MessageError {
    fn clear(&mut self) {
        self.hash.clear();
        self.errCode.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BulkMessageResponse {
    // message oneof groups
    pub response: ::std::option::Option<BulkMessageResponse_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BulkMessageResponse {
    fn default() -> &'a BulkMessageResponse {
        <BulkMessageResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BulkMessageResponse_oneof_response {
    message(super::message::Message),
    message_error(MessageError),
}

impl BulkMessageResponse {
    pub fn new() -> BulkMessageResponse {
        ::std::default::Default::default()
    }

    // .Message message = 1;


    pub fn get_message(&self) -> &super::message::Message {
        match self.response {
            ::std::option::Option::Some(BulkMessageResponse_oneof_response::message(ref v)) => v,
            _ => <super::message::Message as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_message(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(BulkMessageResponse_oneof_response::message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::message::Message) {
        self.response = ::std::option::Option::Some(BulkMessageResponse_oneof_response::message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message(&mut self) -> &mut super::message::Message {
        if let ::std::option::Option::Some(BulkMessageResponse_oneof_response::message(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(BulkMessageResponse_oneof_response::message(super::message::Message::new()));
        }
        match self.response {
            ::std::option::Option::Some(BulkMessageResponse_oneof_response::message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message(&mut self) -> super::message::Message {
        if self.has_message() {
            match self.response.take() {
                ::std::option::Option::Some(BulkMessageResponse_oneof_response::message(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::Message::new()
        }
    }

    // .MessageError message_error = 2;


    pub fn get_message_error(&self) -> &MessageError {
        match self.response {
            ::std::option::Option::Some(BulkMessageResponse_oneof_response::message_error(ref v)) => v,
            _ => <MessageError as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_message_error(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_message_error(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(BulkMessageResponse_oneof_response::message_error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_error(&mut self, v: MessageError) {
        self.response = ::std::option::Option::Some(BulkMessageResponse_oneof_response::message_error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_error(&mut self) -> &mut MessageError {
        if let ::std::option::Option::Some(BulkMessageResponse_oneof_response::message_error(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(BulkMessageResponse_oneof_response::message_error(MessageError::new()));
        }
        match self.response {
            ::std::option::Option::Some(BulkMessageResponse_oneof_response::message_error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_error(&mut self) -> MessageError {
        if self.has_message_error() {
            match self.response.take() {
                ::std::option::Option::Some(BulkMessageResponse_oneof_response::message_error(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageError::new()
        }
    }
}

impl ::protobuf::Message for BulkMessageResponse {
    fn is_initialized(&self) -> bool {
        if let Some(BulkMessageResponse_oneof_response::message(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BulkMessageResponse_oneof_response::message_error(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(BulkMessageResponse_oneof_response::message(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(BulkMessageResponse_oneof_response::message_error(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &BulkMessageResponse_oneof_response::message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BulkMessageResponse_oneof_response::message_error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &BulkMessageResponse_oneof_response::message(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BulkMessageResponse_oneof_response::message_error(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkMessageResponse {
        BulkMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::message::Message>(
                "message",
                BulkMessageResponse::has_message,
                BulkMessageResponse::get_message,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageError>(
                "message_error",
                BulkMessageResponse::has_message_error,
                BulkMessageResponse::get_message_error,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BulkMessageResponse>(
                "BulkMessageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkMessageResponse {
        static instance: ::protobuf::rt::LazyV2<BulkMessageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BulkMessageResponse::new)
    }
}

impl ::protobuf::Clear for BulkMessageResponse {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitBulkMessagesResponse {
    // message fields
    pub messages: ::protobuf::RepeatedField<BulkMessageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitBulkMessagesResponse {
    fn default() -> &'a SubmitBulkMessagesResponse {
        <SubmitBulkMessagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubmitBulkMessagesResponse {
    pub fn new() -> SubmitBulkMessagesResponse {
        ::std::default::Default::default()
    }

    // repeated .BulkMessageResponse messages = 1;


    pub fn get_messages(&self) -> &[BulkMessageResponse] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<BulkMessageResponse>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<BulkMessageResponse> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<BulkMessageResponse> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubmitBulkMessagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitBulkMessagesResponse {
        SubmitBulkMessagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulkMessageResponse>>(
                "messages",
                |m: &SubmitBulkMessagesResponse| { &m.messages },
                |m: &mut SubmitBulkMessagesResponse| { &mut m.messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitBulkMessagesResponse>(
                "SubmitBulkMessagesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitBulkMessagesResponse {
        static instance: ::protobuf::rt::LazyV2<SubmitBulkMessagesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitBulkMessagesResponse::new)
    }
}

impl ::protobuf::Clear for SubmitBulkMessagesResponse {
    fn clear(&mut self) {
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitBulkMessagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitBulkMessagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrieNodeMetadataRequest {
    // message fields
    pub shard_id: u32,
    pub prefix: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrieNodeMetadataRequest {
    fn default() -> &'a TrieNodeMetadataRequest {
        <TrieNodeMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl TrieNodeMetadataRequest {
    pub fn new() -> TrieNodeMetadataRequest {
        ::std::default::Default::default()
    }

    // uint32 shard_id = 1;


    pub fn get_shard_id(&self) -> u32 {
        self.shard_id
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: u32) {
        self.shard_id = v;
    }

    // bytes prefix = 2;


    pub fn get_prefix(&self) -> &[u8] {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prefix, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TrieNodeMetadataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shard_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if !self.prefix.is_empty() {
            os.write_bytes(2, &self.prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrieNodeMetadataRequest {
        TrieNodeMetadataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_id",
                |m: &TrieNodeMetadataRequest| { &m.shard_id },
                |m: &mut TrieNodeMetadataRequest| { &mut m.shard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prefix",
                |m: &TrieNodeMetadataRequest| { &m.prefix },
                |m: &mut TrieNodeMetadataRequest| { &mut m.prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrieNodeMetadataRequest>(
                "TrieNodeMetadataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrieNodeMetadataRequest {
        static instance: ::protobuf::rt::LazyV2<TrieNodeMetadataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrieNodeMetadataRequest::new)
    }
}

impl ::protobuf::Clear for TrieNodeMetadataRequest {
    fn clear(&mut self) {
        self.shard_id = 0;
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrieNodeMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrieNodeMetadataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrieNodeMetadataResponse {
    // message fields
    pub prefix: ::std::vec::Vec<u8>,
    pub num_messages: u64,
    pub hash: ::std::string::String,
    pub children: ::protobuf::RepeatedField<TrieNodeMetadataResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrieNodeMetadataResponse {
    fn default() -> &'a TrieNodeMetadataResponse {
        <TrieNodeMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl TrieNodeMetadataResponse {
    pub fn new() -> TrieNodeMetadataResponse {
        ::std::default::Default::default()
    }

    // bytes prefix = 1;


    pub fn get_prefix(&self) -> &[u8] {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prefix, ::std::vec::Vec::new())
    }

    // uint64 num_messages = 2;


    pub fn get_num_messages(&self) -> u64 {
        self.num_messages
    }
    pub fn clear_num_messages(&mut self) {
        self.num_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: u64) {
        self.num_messages = v;
    }

    // string hash = 3;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // repeated .TrieNodeMetadataResponse children = 4;


    pub fn get_children(&self) -> &[TrieNodeMetadataResponse] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::protobuf::RepeatedField<TrieNodeMetadataResponse>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::protobuf::RepeatedField<TrieNodeMetadataResponse> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::protobuf::RepeatedField<TrieNodeMetadataResponse> {
        ::std::mem::replace(&mut self.children, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TrieNodeMetadataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_messages = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.children)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prefix);
        }
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hash);
        }
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_bytes(1, &self.prefix)?;
        }
        if self.num_messages != 0 {
            os.write_uint64(2, self.num_messages)?;
        }
        if !self.hash.is_empty() {
            os.write_string(3, &self.hash)?;
        }
        for v in &self.children {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrieNodeMetadataResponse {
        TrieNodeMetadataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prefix",
                |m: &TrieNodeMetadataResponse| { &m.prefix },
                |m: &mut TrieNodeMetadataResponse| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_messages",
                |m: &TrieNodeMetadataResponse| { &m.num_messages },
                |m: &mut TrieNodeMetadataResponse| { &mut m.num_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &TrieNodeMetadataResponse| { &m.hash },
                |m: &mut TrieNodeMetadataResponse| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrieNodeMetadataResponse>>(
                "children",
                |m: &TrieNodeMetadataResponse| { &m.children },
                |m: &mut TrieNodeMetadataResponse| { &mut m.children },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrieNodeMetadataResponse>(
                "TrieNodeMetadataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrieNodeMetadataResponse {
        static instance: ::protobuf::rt::LazyV2<TrieNodeMetadataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrieNodeMetadataResponse::new)
    }
}

impl ::protobuf::Clear for TrieNodeMetadataResponse {
    fn clear(&mut self) {
        self.prefix.clear();
        self.num_messages = 0;
        self.hash.clear();
        self.children.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrieNodeMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrieNodeMetadataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventsRequest {
    // message fields
    pub start_id: u64,
    pub shard_index: u32,
    pub stop_id: u64,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventsRequest {
    fn default() -> &'a EventsRequest {
        <EventsRequest as ::protobuf::Message>::default_instance()
    }
}

impl EventsRequest {
    pub fn new() -> EventsRequest {
        ::std::default::Default::default()
    }

    // uint64 start_id = 1;


    pub fn get_start_id(&self) -> u64 {
        self.start_id
    }
    pub fn clear_start_id(&mut self) {
        self.start_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_id(&mut self, v: u64) {
        self.start_id = v;
    }

    // uint32 shard_index = 2;


    pub fn get_shard_index(&self) -> u32 {
        self.shard_index
    }
    pub fn clear_shard_index(&mut self) {
        self.shard_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_index(&mut self, v: u32) {
        self.shard_index = v;
    }

    // uint64 stop_id = 3;


    pub fn get_stop_id(&self) -> u64 {
        self.stop_id
    }
    pub fn clear_stop_id(&mut self) {
        self.stop_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_stop_id(&mut self, v: u64) {
        self.stop_id = v;
    }

    // uint32 page_size = 4;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 5;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 6;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for EventsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shard_index = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stop_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.shard_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stop_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.stop_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_id != 0 {
            os.write_uint64(1, self.start_id)?;
        }
        if self.shard_index != 0 {
            os.write_uint32(2, self.shard_index)?;
        }
        if self.stop_id != 0 {
            os.write_uint64(3, self.stop_id)?;
        }
        if self.page_size != 0 {
            os.write_uint32(4, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(5, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(6, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventsRequest {
        EventsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start_id",
                |m: &EventsRequest| { &m.start_id },
                |m: &mut EventsRequest| { &mut m.start_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shard_index",
                |m: &EventsRequest| { &m.shard_index },
                |m: &mut EventsRequest| { &mut m.shard_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "stop_id",
                |m: &EventsRequest| { &m.stop_id },
                |m: &mut EventsRequest| { &mut m.stop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &EventsRequest| { &m.page_size },
                |m: &mut EventsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &EventsRequest| { &m.page_token },
                |m: &mut EventsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &EventsRequest| { &m.reverse },
                |m: &mut EventsRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventsRequest>(
                "EventsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventsRequest {
        static instance: ::protobuf::rt::LazyV2<EventsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventsRequest::new)
    }
}

impl ::protobuf::Clear for EventsRequest {
    fn clear(&mut self) {
        self.start_id = 0;
        self.shard_index = 0;
        self.stop_id = 0;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventsResponse {
    // message fields
    pub events: ::protobuf::RepeatedField<super::hub_event::HubEvent>,
    pub next_page_token: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventsResponse {
    fn default() -> &'a EventsResponse {
        <EventsResponse as ::protobuf::Message>::default_instance()
    }
}

impl EventsResponse {
    pub fn new() -> EventsResponse {
        ::std::default::Default::default()
    }

    // repeated .HubEvent events = 1;


    pub fn get_events(&self) -> &[super::hub_event::HubEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<super::hub_event::HubEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<super::hub_event::HubEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<super::hub_event::HubEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // bytes next_page_token = 2;


    pub fn get_next_page_token(&self) -> &[u8] {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.next_page_token, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EventsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_bytes(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventsResponse {
        EventsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hub_event::HubEvent>>(
                "events",
                |m: &EventsResponse| { &m.events },
                |m: &mut EventsResponse| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_page_token",
                |m: &EventsResponse| { &m.next_page_token },
                |m: &mut EventsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventsResponse>(
                "EventsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventsResponse {
        static instance: ::protobuf::rt::LazyV2<EventsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventsResponse::new)
    }
}

impl ::protobuf::Clear for EventsResponse {
    fn clear(&mut self) {
        self.events.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidAddressTypeRequest {
    // message fields
    pub fid: u64,
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidAddressTypeRequest {
    fn default() -> &'a FidAddressTypeRequest {
        <FidAddressTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidAddressTypeRequest {
    pub fn new() -> FidAddressTypeRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FidAddressTypeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidAddressTypeRequest {
        FidAddressTypeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &FidAddressTypeRequest| { &m.fid },
                |m: &mut FidAddressTypeRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &FidAddressTypeRequest| { &m.address },
                |m: &mut FidAddressTypeRequest| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidAddressTypeRequest>(
                "FidAddressTypeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidAddressTypeRequest {
        static instance: ::protobuf::rt::LazyV2<FidAddressTypeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidAddressTypeRequest::new)
    }
}

impl ::protobuf::Clear for FidAddressTypeRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidAddressTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidAddressTypeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidAddressTypeResponse {
    // message fields
    pub is_custody: bool,
    pub is_auth: bool,
    pub is_verified: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidAddressTypeResponse {
    fn default() -> &'a FidAddressTypeResponse {
        <FidAddressTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl FidAddressTypeResponse {
    pub fn new() -> FidAddressTypeResponse {
        ::std::default::Default::default()
    }

    // bool is_custody = 1;


    pub fn get_is_custody(&self) -> bool {
        self.is_custody
    }
    pub fn clear_is_custody(&mut self) {
        self.is_custody = false;
    }

    // Param is passed by value, moved
    pub fn set_is_custody(&mut self, v: bool) {
        self.is_custody = v;
    }

    // bool is_auth = 2;


    pub fn get_is_auth(&self) -> bool {
        self.is_auth
    }
    pub fn clear_is_auth(&mut self) {
        self.is_auth = false;
    }

    // Param is passed by value, moved
    pub fn set_is_auth(&mut self, v: bool) {
        self.is_auth = v;
    }

    // bool is_verified = 3;


    pub fn get_is_verified(&self) -> bool {
        self.is_verified
    }
    pub fn clear_is_verified(&mut self) {
        self.is_verified = false;
    }

    // Param is passed by value, moved
    pub fn set_is_verified(&mut self, v: bool) {
        self.is_verified = v;
    }
}

impl ::protobuf::Message for FidAddressTypeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_custody = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_auth = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_verified = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_custody != false {
            my_size += 2;
        }
        if self.is_auth != false {
            my_size += 2;
        }
        if self.is_verified != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_custody != false {
            os.write_bool(1, self.is_custody)?;
        }
        if self.is_auth != false {
            os.write_bool(2, self.is_auth)?;
        }
        if self.is_verified != false {
            os.write_bool(3, self.is_verified)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidAddressTypeResponse {
        FidAddressTypeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_custody",
                |m: &FidAddressTypeResponse| { &m.is_custody },
                |m: &mut FidAddressTypeResponse| { &mut m.is_custody },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_auth",
                |m: &FidAddressTypeResponse| { &m.is_auth },
                |m: &mut FidAddressTypeResponse| { &mut m.is_auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_verified",
                |m: &FidAddressTypeResponse| { &m.is_verified },
                |m: &mut FidAddressTypeResponse| { &mut m.is_verified },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidAddressTypeResponse>(
                "FidAddressTypeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidAddressTypeResponse {
        static instance: ::protobuf::rt::LazyV2<FidAddressTypeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidAddressTypeResponse::new)
    }
}

impl ::protobuf::Clear for FidAddressTypeResponse {
    fn clear(&mut self) {
        self.is_custody = false;
        self.is_auth = false;
        self.is_verified = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidAddressTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidAddressTypeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConnectedPeersRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectedPeersRequest {
    fn default() -> &'a GetConnectedPeersRequest {
        <GetConnectedPeersRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectedPeersRequest {
    pub fn new() -> GetConnectedPeersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetConnectedPeersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectedPeersRequest {
        GetConnectedPeersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConnectedPeersRequest>(
                "GetConnectedPeersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConnectedPeersRequest {
        static instance: ::protobuf::rt::LazyV2<GetConnectedPeersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConnectedPeersRequest::new)
    }
}

impl ::protobuf::Clear for GetConnectedPeersRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectedPeersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectedPeersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConnectedPeersResponse {
    // message fields
    pub contacts: ::protobuf::RepeatedField<super::gossip::ContactInfoBody>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectedPeersResponse {
    fn default() -> &'a GetConnectedPeersResponse {
        <GetConnectedPeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectedPeersResponse {
    pub fn new() -> GetConnectedPeersResponse {
        ::std::default::Default::default()
    }

    // repeated .ContactInfoBody contacts = 1;


    pub fn get_contacts(&self) -> &[super::gossip::ContactInfoBody] {
        &self.contacts
    }
    pub fn clear_contacts(&mut self) {
        self.contacts.clear();
    }

    // Param is passed by value, moved
    pub fn set_contacts(&mut self, v: ::protobuf::RepeatedField<super::gossip::ContactInfoBody>) {
        self.contacts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contacts(&mut self) -> &mut ::protobuf::RepeatedField<super::gossip::ContactInfoBody> {
        &mut self.contacts
    }

    // Take field
    pub fn take_contacts(&mut self) -> ::protobuf::RepeatedField<super::gossip::ContactInfoBody> {
        ::std::mem::replace(&mut self.contacts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetConnectedPeersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.contacts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contacts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.contacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.contacts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectedPeersResponse {
        GetConnectedPeersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gossip::ContactInfoBody>>(
                "contacts",
                |m: &GetConnectedPeersResponse| { &m.contacts },
                |m: &mut GetConnectedPeersResponse| { &mut m.contacts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConnectedPeersResponse>(
                "GetConnectedPeersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConnectedPeersResponse {
        static instance: ::protobuf::rt::LazyV2<GetConnectedPeersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConnectedPeersResponse::new)
    }
}

impl ::protobuf::Clear for GetConnectedPeersResponse {
    fn clear(&mut self) {
        self.contacts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectedPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectedPeersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StoreType {
    STORE_TYPE_NONE = 0,
    STORE_TYPE_CASTS = 1,
    STORE_TYPE_LINKS = 2,
    STORE_TYPE_REACTIONS = 3,
    STORE_TYPE_USER_DATA = 4,
    STORE_TYPE_VERIFICATIONS = 5,
    STORE_TYPE_USERNAME_PROOFS = 6,
    STORE_TYPE_STORAGE_LENDS = 7,
}

impl ::protobuf::ProtobufEnum for StoreType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StoreType> {
        match value {
            0 => ::std::option::Option::Some(StoreType::STORE_TYPE_NONE),
            1 => ::std::option::Option::Some(StoreType::STORE_TYPE_CASTS),
            2 => ::std::option::Option::Some(StoreType::STORE_TYPE_LINKS),
            3 => ::std::option::Option::Some(StoreType::STORE_TYPE_REACTIONS),
            4 => ::std::option::Option::Some(StoreType::STORE_TYPE_USER_DATA),
            5 => ::std::option::Option::Some(StoreType::STORE_TYPE_VERIFICATIONS),
            6 => ::std::option::Option::Some(StoreType::STORE_TYPE_USERNAME_PROOFS),
            7 => ::std::option::Option::Some(StoreType::STORE_TYPE_STORAGE_LENDS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StoreType] = &[
            StoreType::STORE_TYPE_NONE,
            StoreType::STORE_TYPE_CASTS,
            StoreType::STORE_TYPE_LINKS,
            StoreType::STORE_TYPE_REACTIONS,
            StoreType::STORE_TYPE_USER_DATA,
            StoreType::STORE_TYPE_VERIFICATIONS,
            StoreType::STORE_TYPE_USERNAME_PROOFS,
            StoreType::STORE_TYPE_STORAGE_LENDS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StoreType>("StoreType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StoreType {
}

impl ::std::default::Default for StoreType {
    fn default() -> Self {
        StoreType::STORE_TYPE_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16request_response.proto\x1a\rmessage.proto\x1a\x0cblocks.proto\x1a\
    \x0fhub_event.proto\x1a\x14username_proof.proto\x1a\x13onchain_event.pro\
    to\x1a\x0cgossip.proto\"\x8c\x01\n\rBlocksRequest\x12\x1b\n\x08shard_id\
    \x18\x01\x20\x01(\rR\x07shardIdB\0\x12.\n\x12start_block_number\x18\x02\
    \x20\x01(\x04R\x10startBlockNumberB\0\x12,\n\x11stop_block_number\x18\
    \x03\x20\x01(\x04R\x0fstopBlockNumberB\0:\0\"\x91\x01\n\x12ShardChunksRe\
    quest\x12\x1b\n\x08shard_id\x18\x01\x20\x01(\rR\x07shardIdB\0\x12.\n\x12\
    start_block_number\x18\x02\x20\x01(\x04R\x10startBlockNumberB\0\x12,\n\
    \x11stop_block_number\x18\x03\x20\x01(\x04R\x0fstopBlockNumberB\0:\0\"I\
    \n\x13ShardChunksResponse\x120\n\x0cshard_chunks\x18\x01\x20\x03(\x0b2\
    \x0b.ShardChunkR\x0bshardChunksB\0:\0\"\x84\x01\n\x10SubscribeRequest\
    \x120\n\x0bevent_types\x18\x01\x20\x03(\x0e2\r.HubEventTypeR\neventTypes\
    B\0\x12\x19\n\x07from_id\x18\x02\x20\x01(\x04R\x06fromIdB\0\x12!\n\x0bsh\
    ard_index\x18\x04\x20\x01(\rR\nshardIndexB\0:\0\"\x89\x01\n\x07DbStats\
    \x12#\n\x0cnum_messages\x18\x01\x20\x01(\x04R\x0bnumMessagesB\0\x124\n\
    \x15num_fid_registrations\x18\x02\x20\x01(\x04R\x13numFidRegistrationsB\
    \0\x12!\n\x0bapprox_size\x18\x04\x20\x01(\x04R\napproxSizeB\0:\0\"\x91\
    \x02\n\tShardInfo\x12\x1b\n\x08shard_id\x18\x01\x20\x01(\rR\x07shardIdB\
    \0\x12\x1f\n\nmax_height\x18\x02\x20\x01(\x04R\tmaxHeightB\0\x12#\n\x0cn\
    um_messages\x18\x03\x20\x01(\x04R\x0bnumMessagesB\0\x124\n\x15num_fid_re\
    gistrations\x18\x04\x20\x01(\x04R\x13numFidRegistrationsB\0\x12!\n\x0bap\
    prox_size\x18\x05\x20\x01(\x04R\napproxSizeB\0\x12!\n\x0bblock_delay\x18\
    \x06\x20\x01(\x04R\nblockDelayB\0\x12#\n\x0cmempool_size\x18\x07\x20\x01\
    (\x04R\x0bmempoolSizeB\0:\0\"\x12\n\x0eGetInfoRequest:\0\"\x85\x02\n\x0f\
    GetInfoResponse\x12\x1a\n\x07version\x18\x01\x20\x01(\tR\x07versionB\0\
    \x12%\n\x08db_stats\x18\x05\x20\x01(\x0b2\x08.DbStatsR\x07dbStatsB\0\x12\
    \x18\n\x06peerId\x18\x06\x20\x01(\tR\x06peerIdB\0\x12\x1f\n\nnum_shards\
    \x18\x08\x20\x01(\rR\tnumShardsB\0\x12-\n\x0bshard_infos\x18\t\x20\x03(\
    \x0b2\n.ShardInfoR\nshardInfosB\0\x12C\n\x1dnext_engine_version_timestam\
    p\x18\n\x20\x01(\x04R\x1anextEngineVersionTimestampB\0:\0\"E\n\x0cEventR\
    equest\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02idB\0\x12!\n\x0bshard_in\
    dex\x18\x05\x20\x01(\rR\nshardIndexB\0:\0\"~\n\nFidRequest\x12\x12\n\x03\
    fid\x18\x01\x20\x01(\x04R\x03fidB\0\x12\x1d\n\tpage_size\x18\x02\x20\x01\
    (\rR\x08pageSizeB\0\x12\x1f\n\npage_token\x18\x03\x20\x01(\x0cR\tpageTok\
    enB\0\x12\x1a\n\x07reverse\x18\x04\x20\x01(\x08R\x07reverseB\0:\0\"\xdb\
    \x01\n\x13FidTimestampRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03\
    fidB\0\x12\x1d\n\tpage_size\x18\x02\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\
    \npage_token\x18\x03\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\
    \x18\x04\x20\x01(\x08R\x07reverseB\0\x12)\n\x0fstart_timestamp\x18\x05\
    \x20\x01(\x04R\x0estartTimestampB\0\x12'\n\x0estop_timestamp\x18\x06\x20\
    \x01(\x04R\rstopTimestampB\0:\0\"\x88\x01\n\x0bFidsRequest\x12\x1d\n\tpa\
    ge_size\x18\x01\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\npage_token\x18\x02\
    \x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\x18\x03\x20\x01(\x08R\
    \x07reverseB\0\x12\x1b\n\x08shard_id\x18\x04\x20\x01(\rR\x07shardIdB\0:\
    \0\"P\n\x0cFidsResponse\x12\x14\n\x04fids\x18\x01\x20\x03(\x04R\x04fidsB\
    \0\x12(\n\x0fnext_page_token\x18\x02\x20\x01(\x0cR\rnextPageTokenB\0:\0\
    \"f\n\x10MessagesResponse\x12&\n\x08messages\x18\x01\x20\x03(\x0b2\x08.M\
    essageR\x08messagesB\0\x12(\n\x0fnext_page_token\x18\x02\x20\x01(\x0cR\r\
    nextPageTokenB\0:\0\"\xd4\x01\n\x14CastsByParentRequest\x121\n\x0eparent\
    _cast_id\x18\x01\x20\x01(\x0b2\x07.CastIdH\0R\x0cparentCastIdB\0\x12!\n\
    \nparent_url\x18\x05\x20\x01(\tH\0R\tparentUrlB\0\x12\x1d\n\tpage_size\
    \x18\x02\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\npage_token\x18\x03\x20\
    \x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\x18\x04\x20\x01(\x08R\x07r\
    everseB\0B\x08\n\x06parent:\0\"\xbd\x01\n\x0fReactionRequest\x12\x12\n\
    \x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x124\n\rreaction_type\x18\x02\
    \x20\x01(\x0e2\r.ReactionTypeR\x0creactionTypeB\0\x121\n\x0etarget_cast_\
    id\x18\x03\x20\x01(\x0b2\x07.CastIdH\0R\x0ctargetCastIdB\0\x12!\n\ntarge\
    t_url\x18\x04\x20\x01(\tH\0R\ttargetUrlB\0B\x08\n\x06target:\0\"\xbf\x01\
    \n\x15ReactionsByFidRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fi\
    dB\0\x124\n\rreaction_type\x18\x02\x20\x01(\x0e2\r.ReactionTypeR\x0creac\
    tionTypeB\0\x12\x1d\n\tpage_size\x18\x03\x20\x01(\rR\x08pageSizeB\0\x12\
    \x1f\n\npage_token\x18\x04\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reve\
    rse\x18\x05\x20\x01(\x08R\x07reverseB\0:\0\"\x8e\x02\n\x18ReactionsByTar\
    getRequest\x121\n\x0etarget_cast_id\x18\x01\x20\x01(\x0b2\x07.CastIdH\0R\
    \x0ctargetCastIdB\0\x12!\n\ntarget_url\x18\x06\x20\x01(\tH\0R\ttargetUrl\
    B\0\x124\n\rreaction_type\x18\x02\x20\x01(\x0e2\r.ReactionTypeR\x0creact\
    ionTypeB\0\x12\x1d\n\tpage_size\x18\x03\x20\x01(\rR\x08pageSizeB\0\x12\
    \x1f\n\npage_token\x18\x04\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reve\
    rse\x18\x05\x20\x01(\x08R\x07reverseB\0B\x08\n\x06target:\0\"^\n\x0fUser\
    DataRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x125\n\x0eu\
    ser_data_type\x18\x02\x20\x01(\x0e2\r.UserDataTypeR\x0cuserDataTypeB\0:\
    \0\"\xbb\x01\n\x13OnChainEventRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\
    \x04R\x03fidB\0\x122\n\nevent_type\x18\x02\x20\x01(\x0e2\x11.OnChainEven\
    tTypeR\teventTypeB\0\x12\x1d\n\tpage_size\x18\x03\x20\x01(\rR\x08pageSiz\
    eB\0\x12\x1f\n\npage_token\x18\x04\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\
    \x07reverse\x18\x05\x20\x01(\x08R\x07reverseB\0:\0\"k\n\x14OnChainEventR\
    esponse\x12'\n\x06events\x18\x01\x20\x03(\x0b2\r.OnChainEventR\x06events\
    B\0\x12(\n\x0fnext_page_token\x18\x02\x20\x01(\x0cR\rnextPageTokenB\0:\0\
    \"Z\n\x0bTierDetails\x12(\n\ttier_type\x18\x01\x20\x01(\x0e2\t.TierTypeR\
    \x08tierTypeB\0\x12\x1f\n\nexpires_at\x18\x02\x20\x01(\x04R\texpiresAtB\
    \0:\0\"\xd3\x01\n\x15StorageLimitsResponse\x12'\n\x06limits\x18\x01\x20\
    \x03(\x0b2\r.StorageLimitR\x06limitsB\0\x12\x16\n\x05units\x18\x02\x20\
    \x01(\rR\x05unitsB\0\x128\n\x0cunit_details\x18\x03\x20\x03(\x0b2\x13.St\
    orageUnitDetailsR\x0bunitDetailsB\0\x12=\n\x12tier_subscriptions\x18\x04\
    \x20\x03(\x0b2\x0c.TierDetailsR\x11tierSubscriptionsB\0:\0\"f\n\x12Stora\
    geUnitDetails\x12/\n\tunit_type\x18\x01\x20\x01(\x0e2\x10.StorageUnitTyp\
    eR\x08unitTypeB\0\x12\x1d\n\tunit_size\x18\x02\x20\x01(\rR\x08unitSizeB\
    \0:\0\"\xd7\x01\n\x0cStorageLimit\x12+\n\nstore_type\x18\x01\x20\x01(\
    \x0e2\n.StoreTypeR\tstoreTypeB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\
    \x04nameB\0\x12\x16\n\x05limit\x18\x03\x20\x01(\x04R\x05limitB\0\x12\x14\
    \n\x04used\x18\x04\x20\x01(\x04R\x04usedB\0\x12.\n\x11earliestTimestamp\
    \x18\x05\x20\x01(\x04R\x11earliestTimestampB\0\x12$\n\x0cearliestHash\
    \x18\x06\x20\x01(\x0cR\x0cearliestHashB\0:\0\".\n\x14UsernameProofReques\
    t\x12\x14\n\x04name\x18\x01\x20\x01(\x0cR\x04nameB\0:\0\"D\n\x16Username\
    ProofsResponse\x12(\n\x06proofs\x18\x01\x20\x03(\x0b2\x0e.UserNameProofR\
    \x06proofsB\0:\0\"T\n\x12ValidationResponse\x12\x16\n\x05valid\x18\x01\
    \x20\x01(\x08R\x05validB\0\x12$\n\x07message\x18\x02\x20\x01(\x0b2\x08.M\
    essageR\x07messageB\0:\0\"G\n\x13VerificationRequest\x12\x12\n\x03fid\
    \x18\x01\x20\x01(\x04R\x03fidB\0\x12\x1a\n\x07address\x18\x02\x20\x01(\
    \x0cR\x07addressB\0:\0\"?\n\rSignerRequest\x12\x12\n\x03fid\x18\x01\x20\
    \x01(\x04R\x03fidB\0\x12\x18\n\x06signer\x18\x02\x20\x01(\x0cR\x06signer\
    B\0:\0\"o\n\x0bLinkRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fid\
    B\0\x12\x1d\n\tlink_type\x18\x02\x20\x01(\tR\x08linkTypeB\0\x12!\n\ntarg\
    et_fid\x18\x03\x20\x01(\x04H\0R\ttargetFidB\0B\x08\n\x06target:\0\"\xa4\
    \x01\n\x11LinksByFidRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fi\
    dB\0\x12\x1d\n\tlink_type\x18\x02\x20\x01(\tR\x08linkTypeB\0\x12\x1d\n\t\
    page_size\x18\x03\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\npage_token\x18\
    \x04\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\x18\x05\x20\x01(\
    \x08R\x07reverseB\0:\0\"\xc0\x01\n\x14LinksByTargetRequest\x12!\n\ntarge\
    t_fid\x18\x01\x20\x01(\x04H\0R\ttargetFidB\0\x12\x1d\n\tlink_type\x18\
    \x02\x20\x01(\tR\x08linkTypeB\0\x12\x1d\n\tpage_size\x18\x03\x20\x01(\rR\
    \x08pageSizeB\0\x12\x1f\n\npage_token\x18\x04\x20\x01(\x0cR\tpageTokenB\
    \0\x12\x1a\n\x07reverse\x18\x05\x20\x01(\x08R\x07reverseB\0B\x08\n\x06ta\
    rget:\0\"?\n\x1fIdRegistryEventByAddressRequest\x12\x1a\n\x07address\x18\
    \x01\x20\x01(\x0cR\x07addressB\0:\0\"E\n\x19SubmitBulkMessagesRequest\
    \x12&\n\x08messages\x18\x01\x20\x03(\x0b2\x08.MessageR\x08messagesB\0:\0\
    \"^\n\x0cMessageError\x12\x14\n\x04hash\x18\x01\x20\x01(\x0cR\x04hashB\0\
    \x12\x1a\n\x07errCode\x18\x02\x20\x01(\tR\x07errCodeB\0\x12\x1a\n\x07mes\
    sage\x18\x03\x20\x01(\tR\x07messageB\0:\0\"\x83\x01\n\x13BulkMessageResp\
    onse\x12&\n\x07message\x18\x01\x20\x01(\x0b2\x08.MessageH\0R\x07messageB\
    \0\x126\n\rmessage_error\x18\x02\x20\x01(\x0b2\r.MessageErrorH\0R\x0cmes\
    sageErrorB\0B\n\n\x08response:\0\"R\n\x1aSubmitBulkMessagesResponse\x122\
    \n\x08messages\x18\x01\x20\x03(\x0b2\x14.BulkMessageResponseR\x08message\
    sB\0:\0\"R\n\x17TrieNodeMetadataRequest\x12\x1b\n\x08shard_id\x18\x01\
    \x20\x01(\rR\x07shardIdB\0\x12\x18\n\x06prefix\x18\x02\x20\x01(\x0cR\x06\
    prefixB\0:\0\"\xaa\x01\n\x18TrieNodeMetadataResponse\x12\x18\n\x06prefix\
    \x18\x01\x20\x01(\x0cR\x06prefixB\0\x12#\n\x0cnum_messages\x18\x02\x20\
    \x01(\x04R\x0bnumMessagesB\0\x12\x14\n\x04hash\x18\x03\x20\x01(\tR\x04ha\
    shB\0\x127\n\x08children\x18\x04\x20\x03(\x0b2\x19.TrieNodeMetadataRespo\
    nseR\x08childrenB\0:\0\"\xc8\x01\n\rEventsRequest\x12\x1b\n\x08start_id\
    \x18\x01\x20\x01(\x04R\x07startIdB\0\x12!\n\x0bshard_index\x18\x02\x20\
    \x01(\rR\nshardIndexB\0\x12\x19\n\x07stop_id\x18\x03\x20\x01(\x04R\x06st\
    opIdB\0\x12\x1d\n\tpage_size\x18\x04\x20\x01(\rR\x08pageSizeB\0\x12\x1f\
    \n\npage_token\x18\x05\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\
    \x18\x06\x20\x01(\x08R\x07reverseB\0:\0\"a\n\x0eEventsResponse\x12#\n\
    \x06events\x18\x01\x20\x03(\x0b2\t.HubEventR\x06eventsB\0\x12(\n\x0fnext\
    _page_token\x18\x02\x20\x01(\x0cR\rnextPageTokenB\0:\0\"I\n\x15FidAddres\
    sTypeRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x12\x1a\n\
    \x07address\x18\x02\x20\x01(\x0cR\x07addressB\0:\0\"y\n\x16FidAddressTyp\
    eResponse\x12\x1f\n\nis_custody\x18\x01\x20\x01(\x08R\tisCustodyB\0\x12\
    \x19\n\x07is_auth\x18\x02\x20\x01(\x08R\x06isAuthB\0\x12!\n\x0bis_verifi\
    ed\x18\x03\x20\x01(\x08R\nisVerifiedB\0:\0\"\x1c\n\x18GetConnectedPeersR\
    equest:\0\"M\n\x19GetConnectedPeersResponse\x12.\n\x08contacts\x18\x01\
    \x20\x03(\x0b2\x10.ContactInfoBodyR\x08contactsB\0:\0*\xde\x01\n\tStoreT\
    ype\x12\x13\n\x0fSTORE_TYPE_NONE\x10\0\x12\x14\n\x10STORE_TYPE_CASTS\x10\
    \x01\x12\x14\n\x10STORE_TYPE_LINKS\x10\x02\x12\x18\n\x14STORE_TYPE_REACT\
    IONS\x10\x03\x12\x18\n\x14STORE_TYPE_USER_DATA\x10\x04\x12\x1c\n\x18STOR\
    E_TYPE_VERIFICATIONS\x10\x05\x12\x1e\n\x1aSTORE_TYPE_USERNAME_PROOFS\x10\
    \x06\x12\x1c\n\x18STORE_TYPE_STORAGE_LENDS\x10\x07\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
