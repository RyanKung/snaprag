#![cfg_attr(rustfmt, rustfmt::skip)]
#![allow(clippy::all)]
#![allow(clippy::pedantic)]
#![allow(clippy::nursery)]
#![allow(unused_lifetimes)]
#![allow(elided_lifetimes_in_paths)]
#![allow(unused_parens)]
#![allow(unknown_lints)]
#![allow(renamed_and_removed_lints)]
#![allow(warnings)]

// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `request_response.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:BlocksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlocksRequest {
    // message fields
    // @@protoc_insertion_point(field:BlocksRequest.shard_id)
    pub shard_id: u32,
    // @@protoc_insertion_point(field:BlocksRequest.start_block_number)
    pub start_block_number: u64,
    // @@protoc_insertion_point(field:BlocksRequest.stop_block_number)
    pub stop_block_number: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:BlocksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlocksRequest {
    fn default() -> &'a BlocksRequest {
        <BlocksRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlocksRequest {
    pub fn new() -> BlocksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &BlocksRequest| { &m.shard_id },
            |m: &mut BlocksRequest| { &mut m.shard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_block_number",
            |m: &BlocksRequest| { &m.start_block_number },
            |m: &mut BlocksRequest| { &mut m.start_block_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_block_number",
            |m: &BlocksRequest| { &m.stop_block_number },
            |m: &mut BlocksRequest| { &mut m.stop_block_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlocksRequest>(
            "BlocksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlocksRequest {
    const NAME: &'static str = "BlocksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_id = is.read_uint32()?;
                },
                16 => {
                    self.start_block_number = is.read_uint64()?;
                },
                24 => {
                    self.stop_block_number = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_id);
        }
        if self.start_block_number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.start_block_number);
        }
        if let Some(v) = self.stop_block_number {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.start_block_number != 0 {
            os.write_uint64(2, self.start_block_number)?;
        }
        if let Some(v) = self.stop_block_number {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlocksRequest {
        BlocksRequest::new()
    }

    fn clear(&mut self) {
        self.shard_id = 0;
        self.start_block_number = 0;
        self.stop_block_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlocksRequest {
        static instance: BlocksRequest = BlocksRequest {
            shard_id: 0,
            start_block_number: 0,
            stop_block_number: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlocksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlocksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlocksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlocksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardChunksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardChunksRequest {
    // message fields
    // @@protoc_insertion_point(field:ShardChunksRequest.shard_id)
    pub shard_id: u32,
    // @@protoc_insertion_point(field:ShardChunksRequest.start_block_number)
    pub start_block_number: u64,
    // @@protoc_insertion_point(field:ShardChunksRequest.stop_block_number)
    pub stop_block_number: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardChunksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardChunksRequest {
    fn default() -> &'a ShardChunksRequest {
        <ShardChunksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ShardChunksRequest {
    pub fn new() -> ShardChunksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &ShardChunksRequest| { &m.shard_id },
            |m: &mut ShardChunksRequest| { &mut m.shard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_block_number",
            |m: &ShardChunksRequest| { &m.start_block_number },
            |m: &mut ShardChunksRequest| { &mut m.start_block_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_block_number",
            |m: &ShardChunksRequest| { &m.stop_block_number },
            |m: &mut ShardChunksRequest| { &mut m.stop_block_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardChunksRequest>(
            "ShardChunksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardChunksRequest {
    const NAME: &'static str = "ShardChunksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_id = is.read_uint32()?;
                },
                16 => {
                    self.start_block_number = is.read_uint64()?;
                },
                24 => {
                    self.stop_block_number = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_id);
        }
        if self.start_block_number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.start_block_number);
        }
        if let Some(v) = self.stop_block_number {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.start_block_number != 0 {
            os.write_uint64(2, self.start_block_number)?;
        }
        if let Some(v) = self.stop_block_number {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardChunksRequest {
        ShardChunksRequest::new()
    }

    fn clear(&mut self) {
        self.shard_id = 0;
        self.start_block_number = 0;
        self.stop_block_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardChunksRequest {
        static instance: ShardChunksRequest = ShardChunksRequest {
            shard_id: 0,
            start_block_number: 0,
            stop_block_number: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardChunksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardChunksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardChunksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardChunksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardChunksResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardChunksResponse {
    // message fields
    // @@protoc_insertion_point(field:ShardChunksResponse.shard_chunks)
    pub shard_chunks: ::std::vec::Vec<super::blocks::ShardChunk>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardChunksResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardChunksResponse {
    fn default() -> &'a ShardChunksResponse {
        <ShardChunksResponse as ::protobuf::Message>::default_instance()
    }
}

impl ShardChunksResponse {
    pub fn new() -> ShardChunksResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shard_chunks",
            |m: &ShardChunksResponse| { &m.shard_chunks },
            |m: &mut ShardChunksResponse| { &mut m.shard_chunks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardChunksResponse>(
            "ShardChunksResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardChunksResponse {
    const NAME: &'static str = "ShardChunksResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shard_chunks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.shard_chunks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.shard_chunks {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardChunksResponse {
        ShardChunksResponse::new()
    }

    fn clear(&mut self) {
        self.shard_chunks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardChunksResponse {
        static instance: ShardChunksResponse = ShardChunksResponse {
            shard_chunks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardChunksResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardChunksResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardChunksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardChunksResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeRequest {
    // message fields
    // @@protoc_insertion_point(field:SubscribeRequest.event_types)
    pub event_types: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::hub_event::HubEventType>>,
    // @@protoc_insertion_point(field:SubscribeRequest.from_id)
    pub from_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:SubscribeRequest.shard_index)
    pub shard_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeRequest {
    fn default() -> &'a SubscribeRequest {
        <SubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeRequest {
    pub fn new() -> SubscribeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_types",
            |m: &SubscribeRequest| { &m.event_types },
            |m: &mut SubscribeRequest| { &mut m.event_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_id",
            |m: &SubscribeRequest| { &m.from_id },
            |m: &mut SubscribeRequest| { &mut m.from_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shard_index",
            |m: &SubscribeRequest| { &m.shard_index },
            |m: &mut SubscribeRequest| { &mut m.shard_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeRequest>(
            "SubscribeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeRequest {
    const NAME: &'static str = "SubscribeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_types.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.event_types)?
                },
                16 => {
                    self.from_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.shard_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(1, &self.event_types);
        if let Some(v) = self.from_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.shard_index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_enum_or_unknown(1, &self.event_types)?;
        if let Some(v) = self.from_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.shard_index {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeRequest {
        SubscribeRequest::new()
    }

    fn clear(&mut self) {
        self.event_types.clear();
        self.from_id = ::std::option::Option::None;
        self.shard_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeRequest {
        static instance: SubscribeRequest = SubscribeRequest {
            event_types: ::std::vec::Vec::new(),
            from_id: ::std::option::Option::None,
            shard_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DbStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DbStats {
    // message fields
    // @@protoc_insertion_point(field:DbStats.num_messages)
    pub num_messages: u64,
    // @@protoc_insertion_point(field:DbStats.num_fid_registrations)
    pub num_fid_registrations: u64,
    // @@protoc_insertion_point(field:DbStats.approx_size)
    pub approx_size: u64,
    // special fields
    // @@protoc_insertion_point(special_field:DbStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DbStats {
    fn default() -> &'a DbStats {
        <DbStats as ::protobuf::Message>::default_instance()
    }
}

impl DbStats {
    pub fn new() -> DbStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_messages",
            |m: &DbStats| { &m.num_messages },
            |m: &mut DbStats| { &mut m.num_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_fid_registrations",
            |m: &DbStats| { &m.num_fid_registrations },
            |m: &mut DbStats| { &mut m.num_fid_registrations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "approx_size",
            |m: &DbStats| { &m.approx_size },
            |m: &mut DbStats| { &mut m.approx_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DbStats>(
            "DbStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DbStats {
    const NAME: &'static str = "DbStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_messages = is.read_uint64()?;
                },
                16 => {
                    self.num_fid_registrations = is.read_uint64()?;
                },
                32 => {
                    self.approx_size = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.num_messages);
        }
        if self.num_fid_registrations != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.num_fid_registrations);
        }
        if self.approx_size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.approx_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.num_messages != 0 {
            os.write_uint64(1, self.num_messages)?;
        }
        if self.num_fid_registrations != 0 {
            os.write_uint64(2, self.num_fid_registrations)?;
        }
        if self.approx_size != 0 {
            os.write_uint64(4, self.approx_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DbStats {
        DbStats::new()
    }

    fn clear(&mut self) {
        self.num_messages = 0;
        self.num_fid_registrations = 0;
        self.approx_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DbStats {
        static instance: DbStats = DbStats {
            num_messages: 0,
            num_fid_registrations: 0,
            approx_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DbStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DbStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DbStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DbStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardInfo {
    // message fields
    // @@protoc_insertion_point(field:ShardInfo.shard_id)
    pub shard_id: u32,
    // @@protoc_insertion_point(field:ShardInfo.max_height)
    pub max_height: u64,
    // @@protoc_insertion_point(field:ShardInfo.num_messages)
    pub num_messages: u64,
    // @@protoc_insertion_point(field:ShardInfo.num_fid_registrations)
    pub num_fid_registrations: u64,
    // @@protoc_insertion_point(field:ShardInfo.approx_size)
    pub approx_size: u64,
    // @@protoc_insertion_point(field:ShardInfo.block_delay)
    pub block_delay: u64,
    // @@protoc_insertion_point(field:ShardInfo.mempool_size)
    pub mempool_size: u64,
    // special fields
    // @@protoc_insertion_point(special_field:ShardInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardInfo {
    fn default() -> &'a ShardInfo {
        <ShardInfo as ::protobuf::Message>::default_instance()
    }
}

impl ShardInfo {
    pub fn new() -> ShardInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &ShardInfo| { &m.shard_id },
            |m: &mut ShardInfo| { &mut m.shard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_height",
            |m: &ShardInfo| { &m.max_height },
            |m: &mut ShardInfo| { &mut m.max_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_messages",
            |m: &ShardInfo| { &m.num_messages },
            |m: &mut ShardInfo| { &mut m.num_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_fid_registrations",
            |m: &ShardInfo| { &m.num_fid_registrations },
            |m: &mut ShardInfo| { &mut m.num_fid_registrations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "approx_size",
            |m: &ShardInfo| { &m.approx_size },
            |m: &mut ShardInfo| { &mut m.approx_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_delay",
            |m: &ShardInfo| { &m.block_delay },
            |m: &mut ShardInfo| { &mut m.block_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mempool_size",
            |m: &ShardInfo| { &m.mempool_size },
            |m: &mut ShardInfo| { &mut m.mempool_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardInfo>(
            "ShardInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardInfo {
    const NAME: &'static str = "ShardInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_id = is.read_uint32()?;
                },
                16 => {
                    self.max_height = is.read_uint64()?;
                },
                24 => {
                    self.num_messages = is.read_uint64()?;
                },
                32 => {
                    self.num_fid_registrations = is.read_uint64()?;
                },
                40 => {
                    self.approx_size = is.read_uint64()?;
                },
                48 => {
                    self.block_delay = is.read_uint64()?;
                },
                56 => {
                    self.mempool_size = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_id);
        }
        if self.max_height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.max_height);
        }
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.num_messages);
        }
        if self.num_fid_registrations != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.num_fid_registrations);
        }
        if self.approx_size != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.approx_size);
        }
        if self.block_delay != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.block_delay);
        }
        if self.mempool_size != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.mempool_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if self.max_height != 0 {
            os.write_uint64(2, self.max_height)?;
        }
        if self.num_messages != 0 {
            os.write_uint64(3, self.num_messages)?;
        }
        if self.num_fid_registrations != 0 {
            os.write_uint64(4, self.num_fid_registrations)?;
        }
        if self.approx_size != 0 {
            os.write_uint64(5, self.approx_size)?;
        }
        if self.block_delay != 0 {
            os.write_uint64(6, self.block_delay)?;
        }
        if self.mempool_size != 0 {
            os.write_uint64(7, self.mempool_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardInfo {
        ShardInfo::new()
    }

    fn clear(&mut self) {
        self.shard_id = 0;
        self.max_height = 0;
        self.num_messages = 0;
        self.num_fid_registrations = 0;
        self.approx_size = 0;
        self.block_delay = 0;
        self.mempool_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardInfo {
        static instance: ShardInfo = ShardInfo {
            shard_id: 0,
            max_height: 0,
            num_messages: 0,
            num_fid_registrations: 0,
            approx_size: 0,
            block_delay: 0,
            mempool_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShardInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInfoRequest {
    // special fields
    // @@protoc_insertion_point(special_field:GetInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInfoRequest {
    fn default() -> &'a GetInfoRequest {
        <GetInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoRequest {
    pub fn new() -> GetInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInfoRequest>(
            "GetInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInfoRequest {
    const NAME: &'static str = "GetInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInfoRequest {
        GetInfoRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInfoRequest {
        static instance: GetInfoRequest = GetInfoRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:GetInfoResponse.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:GetInfoResponse.db_stats)
    pub db_stats: ::protobuf::MessageField<DbStats>,
    // @@protoc_insertion_point(field:GetInfoResponse.peerId)
    pub peerId: ::std::string::String,
    // @@protoc_insertion_point(field:GetInfoResponse.num_shards)
    pub num_shards: u32,
    // @@protoc_insertion_point(field:GetInfoResponse.shard_infos)
    pub shard_infos: ::std::vec::Vec<ShardInfo>,
    // @@protoc_insertion_point(field:GetInfoResponse.next_engine_version_timestamp)
    pub next_engine_version_timestamp: u64,
    // special fields
    // @@protoc_insertion_point(special_field:GetInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInfoResponse {
    fn default() -> &'a GetInfoResponse {
        <GetInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoResponse {
    pub fn new() -> GetInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &GetInfoResponse| { &m.version },
            |m: &mut GetInfoResponse| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DbStats>(
            "db_stats",
            |m: &GetInfoResponse| { &m.db_stats },
            |m: &mut GetInfoResponse| { &mut m.db_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "peerId",
            |m: &GetInfoResponse| { &m.peerId },
            |m: &mut GetInfoResponse| { &mut m.peerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_shards",
            |m: &GetInfoResponse| { &m.num_shards },
            |m: &mut GetInfoResponse| { &mut m.num_shards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shard_infos",
            |m: &GetInfoResponse| { &m.shard_infos },
            |m: &mut GetInfoResponse| { &mut m.shard_infos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_engine_version_timestamp",
            |m: &GetInfoResponse| { &m.next_engine_version_timestamp },
            |m: &mut GetInfoResponse| { &mut m.next_engine_version_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInfoResponse>(
            "GetInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInfoResponse {
    const NAME: &'static str = "GetInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.db_stats)?;
                },
                50 => {
                    self.peerId = is.read_string()?;
                },
                64 => {
                    self.num_shards = is.read_uint32()?;
                },
                74 => {
                    self.shard_infos.push(is.read_message()?);
                },
                80 => {
                    self.next_engine_version_timestamp = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if let Some(v) = self.db_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.peerId.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.peerId);
        }
        if self.num_shards != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.num_shards);
        }
        for value in &self.shard_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.next_engine_version_timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.next_engine_version_timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if let Some(v) = self.db_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.peerId.is_empty() {
            os.write_string(6, &self.peerId)?;
        }
        if self.num_shards != 0 {
            os.write_uint32(8, self.num_shards)?;
        }
        for v in &self.shard_infos {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if self.next_engine_version_timestamp != 0 {
            os.write_uint64(10, self.next_engine_version_timestamp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInfoResponse {
        GetInfoResponse::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.db_stats.clear();
        self.peerId.clear();
        self.num_shards = 0;
        self.shard_infos.clear();
        self.next_engine_version_timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInfoResponse {
        static instance: GetInfoResponse = GetInfoResponse {
            version: ::std::string::String::new(),
            db_stats: ::protobuf::MessageField::none(),
            peerId: ::std::string::String::new(),
            num_shards: 0,
            shard_infos: ::std::vec::Vec::new(),
            next_engine_version_timestamp: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EventRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventRequest {
    // message fields
    // @@protoc_insertion_point(field:EventRequest.id)
    pub id: u64,
    // @@protoc_insertion_point(field:EventRequest.shard_index)
    pub shard_index: u32,
    // special fields
    // @@protoc_insertion_point(special_field:EventRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventRequest {
    fn default() -> &'a EventRequest {
        <EventRequest as ::protobuf::Message>::default_instance()
    }
}

impl EventRequest {
    pub fn new() -> EventRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &EventRequest| { &m.id },
            |m: &mut EventRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_index",
            |m: &EventRequest| { &m.shard_index },
            |m: &mut EventRequest| { &mut m.shard_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventRequest>(
            "EventRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventRequest {
    const NAME: &'static str = "EventRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                40 => {
                    self.shard_index = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.shard_index);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.shard_index != 0 {
            os.write_uint32(5, self.shard_index)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventRequest {
        EventRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.shard_index = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventRequest {
        static instance: EventRequest = EventRequest {
            id: 0,
            shard_index: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FidRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidRequest {
    // message fields
    // @@protoc_insertion_point(field:FidRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:FidRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:FidRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:FidRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:FidRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidRequest {
    fn default() -> &'a FidRequest {
        <FidRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidRequest {
    pub fn new() -> FidRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &FidRequest| { &m.fid },
            |m: &mut FidRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &FidRequest| { &m.page_size },
            |m: &mut FidRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &FidRequest| { &m.page_token },
            |m: &mut FidRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &FidRequest| { &m.reverse },
            |m: &mut FidRequest| { &mut m.reverse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FidRequest>(
            "FidRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FidRequest {
    const NAME: &'static str = "FidRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                16 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidRequest {
        FidRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidRequest {
        static instance: FidRequest = FidRequest {
            fid: 0,
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FidRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FidRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FidTimestampRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidTimestampRequest {
    // message fields
    // @@protoc_insertion_point(field:FidTimestampRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:FidTimestampRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:FidTimestampRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:FidTimestampRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:FidTimestampRequest.start_timestamp)
    pub start_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:FidTimestampRequest.stop_timestamp)
    pub stop_timestamp: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:FidTimestampRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidTimestampRequest {
    fn default() -> &'a FidTimestampRequest {
        <FidTimestampRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidTimestampRequest {
    pub fn new() -> FidTimestampRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &FidTimestampRequest| { &m.fid },
            |m: &mut FidTimestampRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &FidTimestampRequest| { &m.page_size },
            |m: &mut FidTimestampRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &FidTimestampRequest| { &m.page_token },
            |m: &mut FidTimestampRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &FidTimestampRequest| { &m.reverse },
            |m: &mut FidTimestampRequest| { &mut m.reverse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_timestamp",
            |m: &FidTimestampRequest| { &m.start_timestamp },
            |m: &mut FidTimestampRequest| { &mut m.start_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_timestamp",
            |m: &FidTimestampRequest| { &m.stop_timestamp },
            |m: &mut FidTimestampRequest| { &mut m.stop_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FidTimestampRequest>(
            "FidTimestampRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FidTimestampRequest {
    const NAME: &'static str = "FidTimestampRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                16 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.start_timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.stop_timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        if let Some(v) = self.start_timestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.stop_timestamp {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.start_timestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.stop_timestamp {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidTimestampRequest {
        FidTimestampRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.start_timestamp = ::std::option::Option::None;
        self.stop_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidTimestampRequest {
        static instance: FidTimestampRequest = FidTimestampRequest {
            fid: 0,
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            start_timestamp: ::std::option::Option::None,
            stop_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FidTimestampRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FidTimestampRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FidTimestampRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidTimestampRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FidsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidsRequest {
    // message fields
    // @@protoc_insertion_point(field:FidsRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:FidsRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:FidsRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:FidsRequest.shard_id)
    pub shard_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FidsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidsRequest {
    fn default() -> &'a FidsRequest {
        <FidsRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidsRequest {
    pub fn new() -> FidsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &FidsRequest| { &m.page_size },
            |m: &mut FidsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &FidsRequest| { &m.page_token },
            |m: &mut FidsRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &FidsRequest| { &m.reverse },
            |m: &mut FidsRequest| { &mut m.reverse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &FidsRequest| { &m.shard_id },
            |m: &mut FidsRequest| { &mut m.shard_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FidsRequest>(
            "FidsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FidsRequest {
    const NAME: &'static str = "FidsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.shard_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.shard_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.page_size {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(3, v)?;
        }
        if self.shard_id != 0 {
            os.write_uint32(4, self.shard_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidsRequest {
        FidsRequest::new()
    }

    fn clear(&mut self) {
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.shard_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidsRequest {
        static instance: FidsRequest = FidsRequest {
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            shard_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FidsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FidsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FidsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FidsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidsResponse {
    // message fields
    // @@protoc_insertion_point(field:FidsResponse.fids)
    pub fids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:FidsResponse.next_page_token)
    pub next_page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:FidsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidsResponse {
    fn default() -> &'a FidsResponse {
        <FidsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FidsResponse {
    pub fn new() -> FidsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fids",
            |m: &FidsResponse| { &m.fids },
            |m: &mut FidsResponse| { &mut m.fids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next_page_token",
            |m: &FidsResponse| { &m.next_page_token },
            |m: &mut FidsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FidsResponse>(
            "FidsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FidsResponse {
    const NAME: &'static str = "FidsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.fids)?;
                },
                8 => {
                    self.fids.push(is.read_uint64()?);
                },
                18 => {
                    self.next_page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint64_size(1, &self.fids);
        if let Some(v) = self.next_page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint64(1, &self.fids)?;
        if let Some(v) = self.next_page_token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidsResponse {
        FidsResponse::new()
    }

    fn clear(&mut self) {
        self.fids.clear();
        self.next_page_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidsResponse {
        static instance: FidsResponse = FidsResponse {
            fids: ::std::vec::Vec::new(),
            next_page_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FidsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FidsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FidsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MessagesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessagesResponse {
    // message fields
    // @@protoc_insertion_point(field:MessagesResponse.messages)
    pub messages: ::std::vec::Vec<super::message::Message>,
    // @@protoc_insertion_point(field:MessagesResponse.next_page_token)
    pub next_page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:MessagesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessagesResponse {
    fn default() -> &'a MessagesResponse {
        <MessagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessagesResponse {
    pub fn new() -> MessagesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &MessagesResponse| { &m.messages },
            |m: &mut MessagesResponse| { &mut m.messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next_page_token",
            |m: &MessagesResponse| { &m.next_page_token },
            |m: &mut MessagesResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessagesResponse>(
            "MessagesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessagesResponse {
    const NAME: &'static str = "MessagesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.next_page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.next_page_token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessagesResponse {
        MessagesResponse::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.next_page_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessagesResponse {
        static instance: MessagesResponse = MessagesResponse {
            messages: ::std::vec::Vec::new(),
            next_page_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessagesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessagesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CastsByParentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CastsByParentRequest {
    // message fields
    // @@protoc_insertion_point(field:CastsByParentRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CastsByParentRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CastsByParentRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // message oneof groups
    pub parent: ::std::option::Option<casts_by_parent_request::Parent>,
    // special fields
    // @@protoc_insertion_point(special_field:CastsByParentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CastsByParentRequest {
    fn default() -> &'a CastsByParentRequest {
        <CastsByParentRequest as ::protobuf::Message>::default_instance()
    }
}

impl CastsByParentRequest {
    pub fn new() -> CastsByParentRequest {
        ::std::default::Default::default()
    }

    // .CastId parent_cast_id = 1;

    pub fn parent_cast_id(&self) -> &super::message::CastId {
        match self.parent {
            ::std::option::Option::Some(casts_by_parent_request::Parent::ParentCastId(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_parent_cast_id(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent_cast_id(&self) -> bool {
        match self.parent {
            ::std::option::Option::Some(casts_by_parent_request::Parent::ParentCastId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_cast_id(&mut self, v: super::message::CastId) {
        self.parent = ::std::option::Option::Some(casts_by_parent_request::Parent::ParentCastId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(casts_by_parent_request::Parent::ParentCastId(_)) = self.parent {
        } else {
            self.parent = ::std::option::Option::Some(casts_by_parent_request::Parent::ParentCastId(super::message::CastId::new()));
        }
        match self.parent {
            ::std::option::Option::Some(casts_by_parent_request::Parent::ParentCastId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_cast_id(&mut self) -> super::message::CastId {
        if self.has_parent_cast_id() {
            match self.parent.take() {
                ::std::option::Option::Some(casts_by_parent_request::Parent::ParentCastId(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string parent_url = 5;

    pub fn parent_url(&self) -> &str {
        match self.parent {
            ::std::option::Option::Some(casts_by_parent_request::Parent::ParentUrl(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_parent_url(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent_url(&self) -> bool {
        match self.parent {
            ::std::option::Option::Some(casts_by_parent_request::Parent::ParentUrl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_url(&mut self, v: ::std::string::String) {
        self.parent = ::std::option::Option::Some(casts_by_parent_request::Parent::ParentUrl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(casts_by_parent_request::Parent::ParentUrl(_)) = self.parent {
        } else {
            self.parent = ::std::option::Option::Some(casts_by_parent_request::Parent::ParentUrl(::std::string::String::new()));
        }
        match self.parent {
            ::std::option::Option::Some(casts_by_parent_request::Parent::ParentUrl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_url(&mut self) -> ::std::string::String {
        if self.has_parent_url() {
            match self.parent.take() {
                ::std::option::Option::Some(casts_by_parent_request::Parent::ParentUrl(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::message::CastId>(
            "parent_cast_id",
            CastsByParentRequest::has_parent_cast_id,
            CastsByParentRequest::parent_cast_id,
            CastsByParentRequest::mut_parent_cast_id,
            CastsByParentRequest::set_parent_cast_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "parent_url",
            CastsByParentRequest::has_parent_url,
            CastsByParentRequest::parent_url,
            CastsByParentRequest::set_parent_url,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &CastsByParentRequest| { &m.page_size },
            |m: &mut CastsByParentRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &CastsByParentRequest| { &m.page_token },
            |m: &mut CastsByParentRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &CastsByParentRequest| { &m.reverse },
            |m: &mut CastsByParentRequest| { &mut m.reverse },
        ));
        oneofs.push(casts_by_parent_request::Parent::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CastsByParentRequest>(
            "CastsByParentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CastsByParentRequest {
    const NAME: &'static str = "CastsByParentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.parent = ::std::option::Option::Some(casts_by_parent_request::Parent::ParentCastId(is.read_message()?));
                },
                42 => {
                    self.parent = ::std::option::Option::Some(casts_by_parent_request::Parent::ParentUrl(is.read_string()?));
                },
                16 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.parent {
            match v {
                &casts_by_parent_request::Parent::ParentCastId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &casts_by_parent_request::Parent::ParentUrl(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.page_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.parent {
            match v {
                &casts_by_parent_request::Parent::ParentCastId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &casts_by_parent_request::Parent::ParentUrl(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CastsByParentRequest {
        CastsByParentRequest::new()
    }

    fn clear(&mut self) {
        self.parent = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CastsByParentRequest {
        static instance: CastsByParentRequest = CastsByParentRequest {
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CastsByParentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CastsByParentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CastsByParentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CastsByParentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CastsByParentRequest`
pub mod casts_by_parent_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CastsByParentRequest.parent)
    pub enum Parent {
        // @@protoc_insertion_point(oneof_field:CastsByParentRequest.parent_cast_id)
        ParentCastId(super::super::message::CastId),
        // @@protoc_insertion_point(oneof_field:CastsByParentRequest.parent_url)
        ParentUrl(::std::string::String),
    }

    impl ::protobuf::Oneof for Parent {
    }

    impl ::protobuf::OneofFull for Parent {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CastsByParentRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("parent").unwrap()).clone()
        }
    }

    impl Parent {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Parent>("parent")
        }
    }
}

// @@protoc_insertion_point(message:ReactionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReactionRequest {
    // message fields
    // @@protoc_insertion_point(field:ReactionRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:ReactionRequest.reaction_type)
    pub reaction_type: ::protobuf::EnumOrUnknown<super::message::ReactionType>,
    // message oneof groups
    pub target: ::std::option::Option<reaction_request::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:ReactionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReactionRequest {
    fn default() -> &'a ReactionRequest {
        <ReactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReactionRequest {
    pub fn new() -> ReactionRequest {
        ::std::default::Default::default()
    }

    // .CastId target_cast_id = 3;

    pub fn target_cast_id(&self) -> &super::message::CastId {
        match self.target {
            ::std::option::Option::Some(reaction_request::Target::TargetCastId(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_target_cast_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_cast_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(reaction_request::Target::TargetCastId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_cast_id(&mut self, v: super::message::CastId) {
        self.target = ::std::option::Option::Some(reaction_request::Target::TargetCastId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(reaction_request::Target::TargetCastId(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(reaction_request::Target::TargetCastId(super::message::CastId::new()));
        }
        match self.target {
            ::std::option::Option::Some(reaction_request::Target::TargetCastId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_cast_id(&mut self) -> super::message::CastId {
        if self.has_target_cast_id() {
            match self.target.take() {
                ::std::option::Option::Some(reaction_request::Target::TargetCastId(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string target_url = 4;

    pub fn target_url(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(reaction_request::Target::TargetUrl(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_target_url(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_url(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(reaction_request::Target::TargetUrl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_url(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(reaction_request::Target::TargetUrl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(reaction_request::Target::TargetUrl(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(reaction_request::Target::TargetUrl(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(reaction_request::Target::TargetUrl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_url(&mut self) -> ::std::string::String {
        if self.has_target_url() {
            match self.target.take() {
                ::std::option::Option::Some(reaction_request::Target::TargetUrl(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &ReactionRequest| { &m.fid },
            |m: &mut ReactionRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reaction_type",
            |m: &ReactionRequest| { &m.reaction_type },
            |m: &mut ReactionRequest| { &mut m.reaction_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::message::CastId>(
            "target_cast_id",
            ReactionRequest::has_target_cast_id,
            ReactionRequest::target_cast_id,
            ReactionRequest::mut_target_cast_id,
            ReactionRequest::set_target_cast_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "target_url",
            ReactionRequest::has_target_url,
            ReactionRequest::target_url,
            ReactionRequest::set_target_url,
        ));
        oneofs.push(reaction_request::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReactionRequest>(
            "ReactionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReactionRequest {
    const NAME: &'static str = "ReactionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                16 => {
                    self.reaction_type = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.target = ::std::option::Option::Some(reaction_request::Target::TargetCastId(is.read_message()?));
                },
                34 => {
                    self.target = ::std::option::Option::Some(reaction_request::Target::TargetUrl(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if self.reaction_type != ::protobuf::EnumOrUnknown::new(super::message::ReactionType::REACTION_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.reaction_type.value());
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &reaction_request::Target::TargetCastId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &reaction_request::Target::TargetUrl(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.reaction_type != ::protobuf::EnumOrUnknown::new(super::message::ReactionType::REACTION_TYPE_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.reaction_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &reaction_request::Target::TargetCastId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &reaction_request::Target::TargetUrl(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReactionRequest {
        ReactionRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.reaction_type = ::protobuf::EnumOrUnknown::new(super::message::ReactionType::REACTION_TYPE_NONE);
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReactionRequest {
        static instance: ReactionRequest = ReactionRequest {
            fid: 0,
            reaction_type: ::protobuf::EnumOrUnknown::from_i32(0),
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReactionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReactionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ReactionRequest`
pub mod reaction_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ReactionRequest.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:ReactionRequest.target_cast_id)
        TargetCastId(super::super::message::CastId),
        // @@protoc_insertion_point(oneof_field:ReactionRequest.target_url)
        TargetUrl(::std::string::String),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ReactionRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

// @@protoc_insertion_point(message:ReactionsByFidRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReactionsByFidRequest {
    // message fields
    // @@protoc_insertion_point(field:ReactionsByFidRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:ReactionsByFidRequest.reaction_type)
    pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::message::ReactionType>>,
    // @@protoc_insertion_point(field:ReactionsByFidRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ReactionsByFidRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ReactionsByFidRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ReactionsByFidRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReactionsByFidRequest {
    fn default() -> &'a ReactionsByFidRequest {
        <ReactionsByFidRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReactionsByFidRequest {
    pub fn new() -> ReactionsByFidRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &ReactionsByFidRequest| { &m.fid },
            |m: &mut ReactionsByFidRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction_type",
            |m: &ReactionsByFidRequest| { &m.reaction_type },
            |m: &mut ReactionsByFidRequest| { &mut m.reaction_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &ReactionsByFidRequest| { &m.page_size },
            |m: &mut ReactionsByFidRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &ReactionsByFidRequest| { &m.page_token },
            |m: &mut ReactionsByFidRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &ReactionsByFidRequest| { &m.reverse },
            |m: &mut ReactionsByFidRequest| { &mut m.reverse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReactionsByFidRequest>(
            "ReactionsByFidRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReactionsByFidRequest {
    const NAME: &'static str = "ReactionsByFidRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                16 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReactionsByFidRequest {
        ReactionsByFidRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.reaction_type = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReactionsByFidRequest {
        static instance: ReactionsByFidRequest = ReactionsByFidRequest {
            fid: 0,
            reaction_type: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReactionsByFidRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReactionsByFidRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReactionsByFidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionsByFidRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ReactionsByTargetRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReactionsByTargetRequest {
    // message fields
    // @@protoc_insertion_point(field:ReactionsByTargetRequest.reaction_type)
    pub reaction_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::message::ReactionType>>,
    // @@protoc_insertion_point(field:ReactionsByTargetRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ReactionsByTargetRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ReactionsByTargetRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // message oneof groups
    pub target: ::std::option::Option<reactions_by_target_request::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:ReactionsByTargetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReactionsByTargetRequest {
    fn default() -> &'a ReactionsByTargetRequest {
        <ReactionsByTargetRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReactionsByTargetRequest {
    pub fn new() -> ReactionsByTargetRequest {
        ::std::default::Default::default()
    }

    // .CastId target_cast_id = 1;

    pub fn target_cast_id(&self) -> &super::message::CastId {
        match self.target {
            ::std::option::Option::Some(reactions_by_target_request::Target::TargetCastId(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_target_cast_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_cast_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(reactions_by_target_request::Target::TargetCastId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_cast_id(&mut self, v: super::message::CastId) {
        self.target = ::std::option::Option::Some(reactions_by_target_request::Target::TargetCastId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(reactions_by_target_request::Target::TargetCastId(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(reactions_by_target_request::Target::TargetCastId(super::message::CastId::new()));
        }
        match self.target {
            ::std::option::Option::Some(reactions_by_target_request::Target::TargetCastId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_cast_id(&mut self) -> super::message::CastId {
        if self.has_target_cast_id() {
            match self.target.take() {
                ::std::option::Option::Some(reactions_by_target_request::Target::TargetCastId(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string target_url = 6;

    pub fn target_url(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(reactions_by_target_request::Target::TargetUrl(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_target_url(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_url(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(reactions_by_target_request::Target::TargetUrl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_url(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(reactions_by_target_request::Target::TargetUrl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(reactions_by_target_request::Target::TargetUrl(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(reactions_by_target_request::Target::TargetUrl(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(reactions_by_target_request::Target::TargetUrl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_url(&mut self) -> ::std::string::String {
        if self.has_target_url() {
            match self.target.take() {
                ::std::option::Option::Some(reactions_by_target_request::Target::TargetUrl(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::message::CastId>(
            "target_cast_id",
            ReactionsByTargetRequest::has_target_cast_id,
            ReactionsByTargetRequest::target_cast_id,
            ReactionsByTargetRequest::mut_target_cast_id,
            ReactionsByTargetRequest::set_target_cast_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "target_url",
            ReactionsByTargetRequest::has_target_url,
            ReactionsByTargetRequest::target_url,
            ReactionsByTargetRequest::set_target_url,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction_type",
            |m: &ReactionsByTargetRequest| { &m.reaction_type },
            |m: &mut ReactionsByTargetRequest| { &mut m.reaction_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &ReactionsByTargetRequest| { &m.page_size },
            |m: &mut ReactionsByTargetRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &ReactionsByTargetRequest| { &m.page_token },
            |m: &mut ReactionsByTargetRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &ReactionsByTargetRequest| { &m.reverse },
            |m: &mut ReactionsByTargetRequest| { &mut m.reverse },
        ));
        oneofs.push(reactions_by_target_request::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReactionsByTargetRequest>(
            "ReactionsByTargetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReactionsByTargetRequest {
    const NAME: &'static str = "ReactionsByTargetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target = ::std::option::Option::Some(reactions_by_target_request::Target::TargetCastId(is.read_message()?));
                },
                50 => {
                    self.target = ::std::option::Option::Some(reactions_by_target_request::Target::TargetUrl(is.read_string()?));
                },
                16 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &reactions_by_target_request::Target::TargetCastId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &reactions_by_target_request::Target::TargetUrl(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reaction_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(5, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &reactions_by_target_request::Target::TargetCastId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &reactions_by_target_request::Target::TargetUrl(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReactionsByTargetRequest {
        ReactionsByTargetRequest::new()
    }

    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReactionsByTargetRequest {
        static instance: ReactionsByTargetRequest = ReactionsByTargetRequest {
            reaction_type: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReactionsByTargetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReactionsByTargetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReactionsByTargetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionsByTargetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ReactionsByTargetRequest`
pub mod reactions_by_target_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ReactionsByTargetRequest.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:ReactionsByTargetRequest.target_cast_id)
        TargetCastId(super::super::message::CastId),
        // @@protoc_insertion_point(oneof_field:ReactionsByTargetRequest.target_url)
        TargetUrl(::std::string::String),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ReactionsByTargetRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

// @@protoc_insertion_point(message:UserDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserDataRequest {
    // message fields
    // @@protoc_insertion_point(field:UserDataRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:UserDataRequest.user_data_type)
    pub user_data_type: ::protobuf::EnumOrUnknown<super::message::UserDataType>,
    // special fields
    // @@protoc_insertion_point(special_field:UserDataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserDataRequest {
    fn default() -> &'a UserDataRequest {
        <UserDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserDataRequest {
    pub fn new() -> UserDataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &UserDataRequest| { &m.fid },
            |m: &mut UserDataRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_data_type",
            |m: &UserDataRequest| { &m.user_data_type },
            |m: &mut UserDataRequest| { &mut m.user_data_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserDataRequest>(
            "UserDataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserDataRequest {
    const NAME: &'static str = "UserDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                16 => {
                    self.user_data_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if self.user_data_type != ::protobuf::EnumOrUnknown::new(super::message::UserDataType::USER_DATA_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.user_data_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.user_data_type != ::protobuf::EnumOrUnknown::new(super::message::UserDataType::USER_DATA_TYPE_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.user_data_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserDataRequest {
        UserDataRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.user_data_type = ::protobuf::EnumOrUnknown::new(super::message::UserDataType::USER_DATA_TYPE_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserDataRequest {
        static instance: UserDataRequest = UserDataRequest {
            fid: 0,
            user_data_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserDataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserDataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OnChainEventRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OnChainEventRequest {
    // message fields
    // @@protoc_insertion_point(field:OnChainEventRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:OnChainEventRequest.event_type)
    pub event_type: ::protobuf::EnumOrUnknown<super::onchain_event::OnChainEventType>,
    // @@protoc_insertion_point(field:OnChainEventRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:OnChainEventRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:OnChainEventRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:OnChainEventRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnChainEventRequest {
    fn default() -> &'a OnChainEventRequest {
        <OnChainEventRequest as ::protobuf::Message>::default_instance()
    }
}

impl OnChainEventRequest {
    pub fn new() -> OnChainEventRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &OnChainEventRequest| { &m.fid },
            |m: &mut OnChainEventRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_type",
            |m: &OnChainEventRequest| { &m.event_type },
            |m: &mut OnChainEventRequest| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &OnChainEventRequest| { &m.page_size },
            |m: &mut OnChainEventRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &OnChainEventRequest| { &m.page_token },
            |m: &mut OnChainEventRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &OnChainEventRequest| { &m.reverse },
            |m: &mut OnChainEventRequest| { &mut m.reverse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnChainEventRequest>(
            "OnChainEventRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnChainEventRequest {
    const NAME: &'static str = "OnChainEventRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                16 => {
                    self.event_type = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if self.event_type != ::protobuf::EnumOrUnknown::new(super::onchain_event::OnChainEventType::EVENT_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.event_type.value());
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.event_type != ::protobuf::EnumOrUnknown::new(super::onchain_event::OnChainEventType::EVENT_TYPE_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.event_type))?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnChainEventRequest {
        OnChainEventRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.event_type = ::protobuf::EnumOrUnknown::new(super::onchain_event::OnChainEventType::EVENT_TYPE_NONE);
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnChainEventRequest {
        static instance: OnChainEventRequest = OnChainEventRequest {
            fid: 0,
            event_type: ::protobuf::EnumOrUnknown::from_i32(0),
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OnChainEventRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnChainEventRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnChainEventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnChainEventRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OnChainEventResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OnChainEventResponse {
    // message fields
    // @@protoc_insertion_point(field:OnChainEventResponse.events)
    pub events: ::std::vec::Vec<super::onchain_event::OnChainEvent>,
    // @@protoc_insertion_point(field:OnChainEventResponse.next_page_token)
    pub next_page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:OnChainEventResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnChainEventResponse {
    fn default() -> &'a OnChainEventResponse {
        <OnChainEventResponse as ::protobuf::Message>::default_instance()
    }
}

impl OnChainEventResponse {
    pub fn new() -> OnChainEventResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &OnChainEventResponse| { &m.events },
            |m: &mut OnChainEventResponse| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next_page_token",
            |m: &OnChainEventResponse| { &m.next_page_token },
            |m: &mut OnChainEventResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnChainEventResponse>(
            "OnChainEventResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnChainEventResponse {
    const NAME: &'static str = "OnChainEventResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.next_page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.next_page_token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnChainEventResponse {
        OnChainEventResponse::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.next_page_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnChainEventResponse {
        static instance: OnChainEventResponse = OnChainEventResponse {
            events: ::std::vec::Vec::new(),
            next_page_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OnChainEventResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnChainEventResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnChainEventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnChainEventResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TierDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TierDetails {
    // message fields
    // @@protoc_insertion_point(field:TierDetails.tier_type)
    pub tier_type: ::protobuf::EnumOrUnknown<super::onchain_event::TierType>,
    // @@protoc_insertion_point(field:TierDetails.expires_at)
    pub expires_at: u64,
    // special fields
    // @@protoc_insertion_point(special_field:TierDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TierDetails {
    fn default() -> &'a TierDetails {
        <TierDetails as ::protobuf::Message>::default_instance()
    }
}

impl TierDetails {
    pub fn new() -> TierDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tier_type",
            |m: &TierDetails| { &m.tier_type },
            |m: &mut TierDetails| { &mut m.tier_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expires_at",
            |m: &TierDetails| { &m.expires_at },
            |m: &mut TierDetails| { &mut m.expires_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TierDetails>(
            "TierDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TierDetails {
    const NAME: &'static str = "TierDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tier_type = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.expires_at = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.tier_type != ::protobuf::EnumOrUnknown::new(super::onchain_event::TierType::None) {
            my_size += ::protobuf::rt::int32_size(1, self.tier_type.value());
        }
        if self.expires_at != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.expires_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.tier_type != ::protobuf::EnumOrUnknown::new(super::onchain_event::TierType::None) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.tier_type))?;
        }
        if self.expires_at != 0 {
            os.write_uint64(2, self.expires_at)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TierDetails {
        TierDetails::new()
    }

    fn clear(&mut self) {
        self.tier_type = ::protobuf::EnumOrUnknown::new(super::onchain_event::TierType::None);
        self.expires_at = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TierDetails {
        static instance: TierDetails = TierDetails {
            tier_type: ::protobuf::EnumOrUnknown::from_i32(0),
            expires_at: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TierDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TierDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TierDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TierDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StorageLimitsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageLimitsResponse {
    // message fields
    // @@protoc_insertion_point(field:StorageLimitsResponse.limits)
    pub limits: ::std::vec::Vec<StorageLimit>,
    // @@protoc_insertion_point(field:StorageLimitsResponse.units)
    pub units: u32,
    // @@protoc_insertion_point(field:StorageLimitsResponse.unit_details)
    pub unit_details: ::std::vec::Vec<StorageUnitDetails>,
    // @@protoc_insertion_point(field:StorageLimitsResponse.tier_subscriptions)
    pub tier_subscriptions: ::std::vec::Vec<TierDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:StorageLimitsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageLimitsResponse {
    fn default() -> &'a StorageLimitsResponse {
        <StorageLimitsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StorageLimitsResponse {
    pub fn new() -> StorageLimitsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "limits",
            |m: &StorageLimitsResponse| { &m.limits },
            |m: &mut StorageLimitsResponse| { &mut m.limits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "units",
            |m: &StorageLimitsResponse| { &m.units },
            |m: &mut StorageLimitsResponse| { &mut m.units },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unit_details",
            |m: &StorageLimitsResponse| { &m.unit_details },
            |m: &mut StorageLimitsResponse| { &mut m.unit_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tier_subscriptions",
            |m: &StorageLimitsResponse| { &m.tier_subscriptions },
            |m: &mut StorageLimitsResponse| { &mut m.tier_subscriptions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageLimitsResponse>(
            "StorageLimitsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageLimitsResponse {
    const NAME: &'static str = "StorageLimitsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.limits.push(is.read_message()?);
                },
                16 => {
                    self.units = is.read_uint32()?;
                },
                26 => {
                    self.unit_details.push(is.read_message()?);
                },
                34 => {
                    self.tier_subscriptions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.units != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.units);
        }
        for value in &self.unit_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tier_subscriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.limits {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.units != 0 {
            os.write_uint32(2, self.units)?;
        }
        for v in &self.unit_details {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.tier_subscriptions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageLimitsResponse {
        StorageLimitsResponse::new()
    }

    fn clear(&mut self) {
        self.limits.clear();
        self.units = 0;
        self.unit_details.clear();
        self.tier_subscriptions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageLimitsResponse {
        static instance: StorageLimitsResponse = StorageLimitsResponse {
            limits: ::std::vec::Vec::new(),
            units: 0,
            unit_details: ::std::vec::Vec::new(),
            tier_subscriptions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageLimitsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageLimitsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageLimitsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageLimitsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StorageUnitDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageUnitDetails {
    // message fields
    // @@protoc_insertion_point(field:StorageUnitDetails.unit_type)
    pub unit_type: ::protobuf::EnumOrUnknown<super::message::StorageUnitType>,
    // @@protoc_insertion_point(field:StorageUnitDetails.unit_size)
    pub unit_size: u32,
    // special fields
    // @@protoc_insertion_point(special_field:StorageUnitDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageUnitDetails {
    fn default() -> &'a StorageUnitDetails {
        <StorageUnitDetails as ::protobuf::Message>::default_instance()
    }
}

impl StorageUnitDetails {
    pub fn new() -> StorageUnitDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_type",
            |m: &StorageUnitDetails| { &m.unit_type },
            |m: &mut StorageUnitDetails| { &mut m.unit_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_size",
            |m: &StorageUnitDetails| { &m.unit_size },
            |m: &mut StorageUnitDetails| { &mut m.unit_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageUnitDetails>(
            "StorageUnitDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageUnitDetails {
    const NAME: &'static str = "StorageUnitDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_type = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.unit_size = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.unit_type != ::protobuf::EnumOrUnknown::new(super::message::StorageUnitType::UNIT_TYPE_LEGACY) {
            my_size += ::protobuf::rt::int32_size(1, self.unit_type.value());
        }
        if self.unit_size != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.unit_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.unit_type != ::protobuf::EnumOrUnknown::new(super::message::StorageUnitType::UNIT_TYPE_LEGACY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.unit_type))?;
        }
        if self.unit_size != 0 {
            os.write_uint32(2, self.unit_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageUnitDetails {
        StorageUnitDetails::new()
    }

    fn clear(&mut self) {
        self.unit_type = ::protobuf::EnumOrUnknown::new(super::message::StorageUnitType::UNIT_TYPE_LEGACY);
        self.unit_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageUnitDetails {
        static instance: StorageUnitDetails = StorageUnitDetails {
            unit_type: ::protobuf::EnumOrUnknown::from_i32(0),
            unit_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageUnitDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageUnitDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageUnitDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageUnitDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StorageLimit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageLimit {
    // message fields
    // @@protoc_insertion_point(field:StorageLimit.store_type)
    pub store_type: ::protobuf::EnumOrUnknown<StoreType>,
    // @@protoc_insertion_point(field:StorageLimit.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:StorageLimit.limit)
    pub limit: u64,
    // @@protoc_insertion_point(field:StorageLimit.used)
    pub used: u64,
    // @@protoc_insertion_point(field:StorageLimit.earliestTimestamp)
    pub earliestTimestamp: u64,
    // @@protoc_insertion_point(field:StorageLimit.earliestHash)
    pub earliestHash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:StorageLimit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageLimit {
    fn default() -> &'a StorageLimit {
        <StorageLimit as ::protobuf::Message>::default_instance()
    }
}

impl StorageLimit {
    pub fn new() -> StorageLimit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "store_type",
            |m: &StorageLimit| { &m.store_type },
            |m: &mut StorageLimit| { &mut m.store_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &StorageLimit| { &m.name },
            |m: &mut StorageLimit| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &StorageLimit| { &m.limit },
            |m: &mut StorageLimit| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "used",
            |m: &StorageLimit| { &m.used },
            |m: &mut StorageLimit| { &mut m.used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "earliestTimestamp",
            |m: &StorageLimit| { &m.earliestTimestamp },
            |m: &mut StorageLimit| { &mut m.earliestTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "earliestHash",
            |m: &StorageLimit| { &m.earliestHash },
            |m: &mut StorageLimit| { &mut m.earliestHash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageLimit>(
            "StorageLimit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageLimit {
    const NAME: &'static str = "StorageLimit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.store_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.limit = is.read_uint64()?;
                },
                32 => {
                    self.used = is.read_uint64()?;
                },
                40 => {
                    self.earliestTimestamp = is.read_uint64()?;
                },
                50 => {
                    self.earliestHash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.store_type != ::protobuf::EnumOrUnknown::new(StoreType::STORE_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.store_type.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.limit);
        }
        if self.used != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.used);
        }
        if self.earliestTimestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.earliestTimestamp);
        }
        if !self.earliestHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.earliestHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.store_type != ::protobuf::EnumOrUnknown::new(StoreType::STORE_TYPE_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.store_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.limit != 0 {
            os.write_uint64(3, self.limit)?;
        }
        if self.used != 0 {
            os.write_uint64(4, self.used)?;
        }
        if self.earliestTimestamp != 0 {
            os.write_uint64(5, self.earliestTimestamp)?;
        }
        if !self.earliestHash.is_empty() {
            os.write_bytes(6, &self.earliestHash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageLimit {
        StorageLimit::new()
    }

    fn clear(&mut self) {
        self.store_type = ::protobuf::EnumOrUnknown::new(StoreType::STORE_TYPE_NONE);
        self.name.clear();
        self.limit = 0;
        self.used = 0;
        self.earliestTimestamp = 0;
        self.earliestHash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageLimit {
        static instance: StorageLimit = StorageLimit {
            store_type: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            limit: 0,
            used: 0,
            earliestTimestamp: 0,
            earliestHash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageLimit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageLimit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageLimit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UsernameProofRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UsernameProofRequest {
    // message fields
    // @@protoc_insertion_point(field:UsernameProofRequest.name)
    pub name: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:UsernameProofRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UsernameProofRequest {
    fn default() -> &'a UsernameProofRequest {
        <UsernameProofRequest as ::protobuf::Message>::default_instance()
    }
}

impl UsernameProofRequest {
    pub fn new() -> UsernameProofRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &UsernameProofRequest| { &m.name },
            |m: &mut UsernameProofRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UsernameProofRequest>(
            "UsernameProofRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UsernameProofRequest {
    const NAME: &'static str = "UsernameProofRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UsernameProofRequest {
        UsernameProofRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UsernameProofRequest {
        static instance: UsernameProofRequest = UsernameProofRequest {
            name: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UsernameProofRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UsernameProofRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UsernameProofRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsernameProofRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UsernameProofsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UsernameProofsResponse {
    // message fields
    // @@protoc_insertion_point(field:UsernameProofsResponse.proofs)
    pub proofs: ::std::vec::Vec<super::username_proof::UserNameProof>,
    // special fields
    // @@protoc_insertion_point(special_field:UsernameProofsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UsernameProofsResponse {
    fn default() -> &'a UsernameProofsResponse {
        <UsernameProofsResponse as ::protobuf::Message>::default_instance()
    }
}

impl UsernameProofsResponse {
    pub fn new() -> UsernameProofsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "proofs",
            |m: &UsernameProofsResponse| { &m.proofs },
            |m: &mut UsernameProofsResponse| { &mut m.proofs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UsernameProofsResponse>(
            "UsernameProofsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UsernameProofsResponse {
    const NAME: &'static str = "UsernameProofsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.proofs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.proofs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.proofs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UsernameProofsResponse {
        UsernameProofsResponse::new()
    }

    fn clear(&mut self) {
        self.proofs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UsernameProofsResponse {
        static instance: UsernameProofsResponse = UsernameProofsResponse {
            proofs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UsernameProofsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UsernameProofsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UsernameProofsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsernameProofsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ValidationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidationResponse {
    // message fields
    // @@protoc_insertion_point(field:ValidationResponse.valid)
    pub valid: bool,
    // @@protoc_insertion_point(field:ValidationResponse.message)
    pub message: ::protobuf::MessageField<super::message::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:ValidationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidationResponse {
    fn default() -> &'a ValidationResponse {
        <ValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl ValidationResponse {
    pub fn new() -> ValidationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "valid",
            |m: &ValidationResponse| { &m.valid },
            |m: &mut ValidationResponse| { &mut m.valid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::message::Message>(
            "message",
            |m: &ValidationResponse| { &m.message },
            |m: &mut ValidationResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidationResponse>(
            "ValidationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidationResponse {
    const NAME: &'static str = "ValidationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.valid = is.read_bool()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.valid != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.valid != false {
            os.write_bool(1, self.valid)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidationResponse {
        ValidationResponse::new()
    }

    fn clear(&mut self) {
        self.valid = false;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidationResponse {
        static instance: ValidationResponse = ValidationResponse {
            valid: false,
            message: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VerificationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VerificationRequest {
    // message fields
    // @@protoc_insertion_point(field:VerificationRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:VerificationRequest.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:VerificationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VerificationRequest {
    fn default() -> &'a VerificationRequest {
        <VerificationRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerificationRequest {
    pub fn new() -> VerificationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &VerificationRequest| { &m.fid },
            |m: &mut VerificationRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &VerificationRequest| { &m.address },
            |m: &mut VerificationRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VerificationRequest>(
            "VerificationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VerificationRequest {
    const NAME: &'static str = "VerificationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VerificationRequest {
        VerificationRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VerificationRequest {
        static instance: VerificationRequest = VerificationRequest {
            fid: 0,
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VerificationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VerificationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VerificationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SignerRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SignerRequest {
    // message fields
    // @@protoc_insertion_point(field:SignerRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:SignerRequest.signer)
    pub signer: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:SignerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignerRequest {
    fn default() -> &'a SignerRequest {
        <SignerRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignerRequest {
    pub fn new() -> SignerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &SignerRequest| { &m.fid },
            |m: &mut SignerRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &SignerRequest| { &m.signer },
            |m: &mut SignerRequest| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignerRequest>(
            "SignerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignerRequest {
    const NAME: &'static str = "SignerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.signer = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.signer.is_empty() {
            os.write_bytes(2, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignerRequest {
        SignerRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignerRequest {
        static instance: SignerRequest = SignerRequest {
            fid: 0,
            signer: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LinkRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkRequest {
    // message fields
    // @@protoc_insertion_point(field:LinkRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:LinkRequest.link_type)
    pub link_type: ::std::string::String,
    // message oneof groups
    pub target: ::std::option::Option<link_request::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:LinkRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkRequest {
    fn default() -> &'a LinkRequest {
        <LinkRequest as ::protobuf::Message>::default_instance()
    }
}

impl LinkRequest {
    pub fn new() -> LinkRequest {
        ::std::default::Default::default()
    }

    // uint64 target_fid = 3;

    pub fn target_fid(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(link_request::Target::TargetFid(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_target_fid(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_fid(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(link_request::Target::TargetFid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_fid(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(link_request::Target::TargetFid(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &LinkRequest| { &m.fid },
            |m: &mut LinkRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "link_type",
            |m: &LinkRequest| { &m.link_type },
            |m: &mut LinkRequest| { &mut m.link_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "target_fid",
            LinkRequest::has_target_fid,
            LinkRequest::target_fid,
            LinkRequest::set_target_fid,
        ));
        oneofs.push(link_request::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkRequest>(
            "LinkRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkRequest {
    const NAME: &'static str = "LinkRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.link_type = is.read_string()?;
                },
                24 => {
                    self.target = ::std::option::Option::Some(link_request::Target::TargetFid(is.read_uint64()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if !self.link_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.link_type);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &link_request::Target::TargetFid(v) => {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.link_type.is_empty() {
            os.write_string(2, &self.link_type)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &link_request::Target::TargetFid(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkRequest {
        LinkRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.link_type.clear();
        self.target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkRequest {
        static instance: LinkRequest = LinkRequest {
            fid: 0,
            link_type: ::std::string::String::new(),
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LinkRequest`
pub mod link_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:LinkRequest.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:LinkRequest.target_fid)
        TargetFid(u64),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LinkRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

// @@protoc_insertion_point(message:LinksByFidRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinksByFidRequest {
    // message fields
    // @@protoc_insertion_point(field:LinksByFidRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:LinksByFidRequest.link_type)
    pub link_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LinksByFidRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LinksByFidRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:LinksByFidRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:LinksByFidRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinksByFidRequest {
    fn default() -> &'a LinksByFidRequest {
        <LinksByFidRequest as ::protobuf::Message>::default_instance()
    }
}

impl LinksByFidRequest {
    pub fn new() -> LinksByFidRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &LinksByFidRequest| { &m.fid },
            |m: &mut LinksByFidRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "link_type",
            |m: &LinksByFidRequest| { &m.link_type },
            |m: &mut LinksByFidRequest| { &mut m.link_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &LinksByFidRequest| { &m.page_size },
            |m: &mut LinksByFidRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &LinksByFidRequest| { &m.page_token },
            |m: &mut LinksByFidRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &LinksByFidRequest| { &m.reverse },
            |m: &mut LinksByFidRequest| { &mut m.reverse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinksByFidRequest>(
            "LinksByFidRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinksByFidRequest {
    const NAME: &'static str = "LinksByFidRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.link_type = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if let Some(v) = self.link_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if let Some(v) = self.link_type.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinksByFidRequest {
        LinksByFidRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.link_type = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinksByFidRequest {
        static instance: LinksByFidRequest = LinksByFidRequest {
            fid: 0,
            link_type: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinksByFidRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinksByFidRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinksByFidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinksByFidRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LinksByTargetRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinksByTargetRequest {
    // message fields
    // @@protoc_insertion_point(field:LinksByTargetRequest.link_type)
    pub link_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LinksByTargetRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LinksByTargetRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:LinksByTargetRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // message oneof groups
    pub target: ::std::option::Option<links_by_target_request::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:LinksByTargetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinksByTargetRequest {
    fn default() -> &'a LinksByTargetRequest {
        <LinksByTargetRequest as ::protobuf::Message>::default_instance()
    }
}

impl LinksByTargetRequest {
    pub fn new() -> LinksByTargetRequest {
        ::std::default::Default::default()
    }

    // uint64 target_fid = 1;

    pub fn target_fid(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(links_by_target_request::Target::TargetFid(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_target_fid(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_fid(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(links_by_target_request::Target::TargetFid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_fid(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(links_by_target_request::Target::TargetFid(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "target_fid",
            LinksByTargetRequest::has_target_fid,
            LinksByTargetRequest::target_fid,
            LinksByTargetRequest::set_target_fid,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "link_type",
            |m: &LinksByTargetRequest| { &m.link_type },
            |m: &mut LinksByTargetRequest| { &mut m.link_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &LinksByTargetRequest| { &m.page_size },
            |m: &mut LinksByTargetRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &LinksByTargetRequest| { &m.page_token },
            |m: &mut LinksByTargetRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &LinksByTargetRequest| { &m.reverse },
            |m: &mut LinksByTargetRequest| { &mut m.reverse },
        ));
        oneofs.push(links_by_target_request::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinksByTargetRequest>(
            "LinksByTargetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinksByTargetRequest {
    const NAME: &'static str = "LinksByTargetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target = ::std::option::Option::Some(links_by_target_request::Target::TargetFid(is.read_uint64()?));
                },
                18 => {
                    self.link_type = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.link_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &links_by_target_request::Target::TargetFid(v) => {
                    my_size += ::protobuf::rt::uint64_size(1, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.link_type.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(5, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &links_by_target_request::Target::TargetFid(v) => {
                    os.write_uint64(1, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinksByTargetRequest {
        LinksByTargetRequest::new()
    }

    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.link_type = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinksByTargetRequest {
        static instance: LinksByTargetRequest = LinksByTargetRequest {
            link_type: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinksByTargetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinksByTargetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinksByTargetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinksByTargetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LinksByTargetRequest`
pub mod links_by_target_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:LinksByTargetRequest.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:LinksByTargetRequest.target_fid)
        TargetFid(u64),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LinksByTargetRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

// @@protoc_insertion_point(message:IdRegistryEventByAddressRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IdRegistryEventByAddressRequest {
    // message fields
    // @@protoc_insertion_point(field:IdRegistryEventByAddressRequest.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:IdRegistryEventByAddressRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdRegistryEventByAddressRequest {
    fn default() -> &'a IdRegistryEventByAddressRequest {
        <IdRegistryEventByAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl IdRegistryEventByAddressRequest {
    pub fn new() -> IdRegistryEventByAddressRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &IdRegistryEventByAddressRequest| { &m.address },
            |m: &mut IdRegistryEventByAddressRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdRegistryEventByAddressRequest>(
            "IdRegistryEventByAddressRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdRegistryEventByAddressRequest {
    const NAME: &'static str = "IdRegistryEventByAddressRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdRegistryEventByAddressRequest {
        IdRegistryEventByAddressRequest::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdRegistryEventByAddressRequest {
        static instance: IdRegistryEventByAddressRequest = IdRegistryEventByAddressRequest {
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdRegistryEventByAddressRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdRegistryEventByAddressRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdRegistryEventByAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdRegistryEventByAddressRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubmitBulkMessagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubmitBulkMessagesRequest {
    // message fields
    // @@protoc_insertion_point(field:SubmitBulkMessagesRequest.messages)
    pub messages: ::std::vec::Vec<super::message::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:SubmitBulkMessagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubmitBulkMessagesRequest {
    fn default() -> &'a SubmitBulkMessagesRequest {
        <SubmitBulkMessagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubmitBulkMessagesRequest {
    pub fn new() -> SubmitBulkMessagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &SubmitBulkMessagesRequest| { &m.messages },
            |m: &mut SubmitBulkMessagesRequest| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubmitBulkMessagesRequest>(
            "SubmitBulkMessagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubmitBulkMessagesRequest {
    const NAME: &'static str = "SubmitBulkMessagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubmitBulkMessagesRequest {
        SubmitBulkMessagesRequest::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubmitBulkMessagesRequest {
        static instance: SubmitBulkMessagesRequest = SubmitBulkMessagesRequest {
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubmitBulkMessagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubmitBulkMessagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubmitBulkMessagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitBulkMessagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MessageError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageError {
    // message fields
    // @@protoc_insertion_point(field:MessageError.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:MessageError.errCode)
    pub errCode: ::std::string::String,
    // @@protoc_insertion_point(field:MessageError.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:MessageError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageError {
    fn default() -> &'a MessageError {
        <MessageError as ::protobuf::Message>::default_instance()
    }
}

impl MessageError {
    pub fn new() -> MessageError {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &MessageError| { &m.hash },
            |m: &mut MessageError| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errCode",
            |m: &MessageError| { &m.errCode },
            |m: &mut MessageError| { &mut m.errCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &MessageError| { &m.message },
            |m: &mut MessageError| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageError>(
            "MessageError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageError {
    const NAME: &'static str = "MessageError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                18 => {
                    self.errCode = is.read_string()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.errCode.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errCode);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.errCode.is_empty() {
            os.write_string(2, &self.errCode)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageError {
        MessageError::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.errCode.clear();
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageError {
        static instance: MessageError = MessageError {
            hash: ::std::vec::Vec::new(),
            errCode: ::std::string::String::new(),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BulkMessageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BulkMessageResponse {
    // message oneof groups
    pub response: ::std::option::Option<bulk_message_response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:BulkMessageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BulkMessageResponse {
    fn default() -> &'a BulkMessageResponse {
        <BulkMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl BulkMessageResponse {
    pub fn new() -> BulkMessageResponse {
        ::std::default::Default::default()
    }

    // .Message message = 1;

    pub fn message(&self) -> &super::message::Message {
        match self.response {
            ::std::option::Option::Some(bulk_message_response::Response::Message(ref v)) => v,
            _ => <super::message::Message as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_message(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(bulk_message_response::Response::Message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::message::Message) {
        self.response = ::std::option::Option::Some(bulk_message_response::Response::Message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message(&mut self) -> &mut super::message::Message {
        if let ::std::option::Option::Some(bulk_message_response::Response::Message(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(bulk_message_response::Response::Message(super::message::Message::new()));
        }
        match self.response {
            ::std::option::Option::Some(bulk_message_response::Response::Message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message(&mut self) -> super::message::Message {
        if self.has_message() {
            match self.response.take() {
                ::std::option::Option::Some(bulk_message_response::Response::Message(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::Message::new()
        }
    }

    // .MessageError message_error = 2;

    pub fn message_error(&self) -> &MessageError {
        match self.response {
            ::std::option::Option::Some(bulk_message_response::Response::MessageError(ref v)) => v,
            _ => <MessageError as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_message_error(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_message_error(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(bulk_message_response::Response::MessageError(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_error(&mut self, v: MessageError) {
        self.response = ::std::option::Option::Some(bulk_message_response::Response::MessageError(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_error(&mut self) -> &mut MessageError {
        if let ::std::option::Option::Some(bulk_message_response::Response::MessageError(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(bulk_message_response::Response::MessageError(MessageError::new()));
        }
        match self.response {
            ::std::option::Option::Some(bulk_message_response::Response::MessageError(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_error(&mut self) -> MessageError {
        if self.has_message_error() {
            match self.response.take() {
                ::std::option::Option::Some(bulk_message_response::Response::MessageError(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageError::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::message::Message>(
            "message",
            BulkMessageResponse::has_message,
            BulkMessageResponse::message,
            BulkMessageResponse::mut_message,
            BulkMessageResponse::set_message,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MessageError>(
            "message_error",
            BulkMessageResponse::has_message_error,
            BulkMessageResponse::message_error,
            BulkMessageResponse::mut_message_error,
            BulkMessageResponse::set_message_error,
        ));
        oneofs.push(bulk_message_response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BulkMessageResponse>(
            "BulkMessageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BulkMessageResponse {
    const NAME: &'static str = "BulkMessageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response = ::std::option::Option::Some(bulk_message_response::Response::Message(is.read_message()?));
                },
                18 => {
                    self.response = ::std::option::Option::Some(bulk_message_response::Response::MessageError(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &bulk_message_response::Response::Message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bulk_message_response::Response::MessageError(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &bulk_message_response::Response::Message(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &bulk_message_response::Response::MessageError(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BulkMessageResponse {
        BulkMessageResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BulkMessageResponse {
        static instance: BulkMessageResponse = BulkMessageResponse {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BulkMessageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BulkMessageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BulkMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkMessageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BulkMessageResponse`
pub mod bulk_message_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:BulkMessageResponse.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:BulkMessageResponse.message)
        Message(super::super::message::Message),
        // @@protoc_insertion_point(oneof_field:BulkMessageResponse.message_error)
        MessageError(super::MessageError),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BulkMessageResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
}

// @@protoc_insertion_point(message:SubmitBulkMessagesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubmitBulkMessagesResponse {
    // message fields
    // @@protoc_insertion_point(field:SubmitBulkMessagesResponse.messages)
    pub messages: ::std::vec::Vec<BulkMessageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:SubmitBulkMessagesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubmitBulkMessagesResponse {
    fn default() -> &'a SubmitBulkMessagesResponse {
        <SubmitBulkMessagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubmitBulkMessagesResponse {
    pub fn new() -> SubmitBulkMessagesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &SubmitBulkMessagesResponse| { &m.messages },
            |m: &mut SubmitBulkMessagesResponse| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubmitBulkMessagesResponse>(
            "SubmitBulkMessagesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubmitBulkMessagesResponse {
    const NAME: &'static str = "SubmitBulkMessagesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubmitBulkMessagesResponse {
        SubmitBulkMessagesResponse::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubmitBulkMessagesResponse {
        static instance: SubmitBulkMessagesResponse = SubmitBulkMessagesResponse {
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubmitBulkMessagesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubmitBulkMessagesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubmitBulkMessagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitBulkMessagesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrieNodeMetadataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrieNodeMetadataRequest {
    // message fields
    // @@protoc_insertion_point(field:TrieNodeMetadataRequest.shard_id)
    pub shard_id: u32,
    // @@protoc_insertion_point(field:TrieNodeMetadataRequest.prefix)
    pub prefix: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:TrieNodeMetadataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrieNodeMetadataRequest {
    fn default() -> &'a TrieNodeMetadataRequest {
        <TrieNodeMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl TrieNodeMetadataRequest {
    pub fn new() -> TrieNodeMetadataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard_id",
            |m: &TrieNodeMetadataRequest| { &m.shard_id },
            |m: &mut TrieNodeMetadataRequest| { &mut m.shard_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &TrieNodeMetadataRequest| { &m.prefix },
            |m: &mut TrieNodeMetadataRequest| { &mut m.prefix },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrieNodeMetadataRequest>(
            "TrieNodeMetadataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrieNodeMetadataRequest {
    const NAME: &'static str = "TrieNodeMetadataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard_id = is.read_uint32()?;
                },
                18 => {
                    self.prefix = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard_id);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard_id != 0 {
            os.write_uint32(1, self.shard_id)?;
        }
        if !self.prefix.is_empty() {
            os.write_bytes(2, &self.prefix)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrieNodeMetadataRequest {
        TrieNodeMetadataRequest::new()
    }

    fn clear(&mut self) {
        self.shard_id = 0;
        self.prefix.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrieNodeMetadataRequest {
        static instance: TrieNodeMetadataRequest = TrieNodeMetadataRequest {
            shard_id: 0,
            prefix: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrieNodeMetadataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrieNodeMetadataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrieNodeMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrieNodeMetadataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrieNodeMetadataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrieNodeMetadataResponse {
    // message fields
    // @@protoc_insertion_point(field:TrieNodeMetadataResponse.prefix)
    pub prefix: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:TrieNodeMetadataResponse.num_messages)
    pub num_messages: u64,
    // @@protoc_insertion_point(field:TrieNodeMetadataResponse.hash)
    pub hash: ::std::string::String,
    // @@protoc_insertion_point(field:TrieNodeMetadataResponse.children)
    pub children: ::std::vec::Vec<TrieNodeMetadataResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:TrieNodeMetadataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrieNodeMetadataResponse {
    fn default() -> &'a TrieNodeMetadataResponse {
        <TrieNodeMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl TrieNodeMetadataResponse {
    pub fn new() -> TrieNodeMetadataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &TrieNodeMetadataResponse| { &m.prefix },
            |m: &mut TrieNodeMetadataResponse| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_messages",
            |m: &TrieNodeMetadataResponse| { &m.num_messages },
            |m: &mut TrieNodeMetadataResponse| { &mut m.num_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &TrieNodeMetadataResponse| { &m.hash },
            |m: &mut TrieNodeMetadataResponse| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "children",
            |m: &TrieNodeMetadataResponse| { &m.children },
            |m: &mut TrieNodeMetadataResponse| { &mut m.children },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrieNodeMetadataResponse>(
            "TrieNodeMetadataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrieNodeMetadataResponse {
    const NAME: &'static str = "TrieNodeMetadataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.prefix = is.read_bytes()?;
                },
                16 => {
                    self.num_messages = is.read_uint64()?;
                },
                26 => {
                    self.hash = is.read_string()?;
                },
                34 => {
                    self.children.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prefix);
        }
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.num_messages);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hash);
        }
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.prefix.is_empty() {
            os.write_bytes(1, &self.prefix)?;
        }
        if self.num_messages != 0 {
            os.write_uint64(2, self.num_messages)?;
        }
        if !self.hash.is_empty() {
            os.write_string(3, &self.hash)?;
        }
        for v in &self.children {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrieNodeMetadataResponse {
        TrieNodeMetadataResponse::new()
    }

    fn clear(&mut self) {
        self.prefix.clear();
        self.num_messages = 0;
        self.hash.clear();
        self.children.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrieNodeMetadataResponse {
        static instance: TrieNodeMetadataResponse = TrieNodeMetadataResponse {
            prefix: ::std::vec::Vec::new(),
            num_messages: 0,
            hash: ::std::string::String::new(),
            children: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrieNodeMetadataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrieNodeMetadataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrieNodeMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrieNodeMetadataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EventsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventsRequest {
    // message fields
    // @@protoc_insertion_point(field:EventsRequest.start_id)
    pub start_id: u64,
    // @@protoc_insertion_point(field:EventsRequest.shard_index)
    pub shard_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:EventsRequest.stop_id)
    pub stop_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:EventsRequest.page_size)
    pub page_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:EventsRequest.page_token)
    pub page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:EventsRequest.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:EventsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventsRequest {
    fn default() -> &'a EventsRequest {
        <EventsRequest as ::protobuf::Message>::default_instance()
    }
}

impl EventsRequest {
    pub fn new() -> EventsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_id",
            |m: &EventsRequest| { &m.start_id },
            |m: &mut EventsRequest| { &mut m.start_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shard_index",
            |m: &EventsRequest| { &m.shard_index },
            |m: &mut EventsRequest| { &mut m.shard_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_id",
            |m: &EventsRequest| { &m.stop_id },
            |m: &mut EventsRequest| { &mut m.stop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &EventsRequest| { &m.page_size },
            |m: &mut EventsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_token",
            |m: &EventsRequest| { &m.page_token },
            |m: &mut EventsRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse",
            |m: &EventsRequest| { &m.reverse },
            |m: &mut EventsRequest| { &mut m.reverse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventsRequest>(
            "EventsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventsRequest {
    const NAME: &'static str = "EventsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_id = is.read_uint64()?;
                },
                16 => {
                    self.shard_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.stop_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.start_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.start_id);
        }
        if let Some(v) = self.shard_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.stop_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.start_id != 0 {
            os.write_uint64(1, self.start_id)?;
        }
        if let Some(v) = self.shard_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.stop_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventsRequest {
        EventsRequest::new()
    }

    fn clear(&mut self) {
        self.start_id = 0;
        self.shard_index = ::std::option::Option::None;
        self.stop_id = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.page_token = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventsRequest {
        static instance: EventsRequest = EventsRequest {
            start_id: 0,
            shard_index: ::std::option::Option::None,
            stop_id: ::std::option::Option::None,
            page_size: ::std::option::Option::None,
            page_token: ::std::option::Option::None,
            reverse: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EventsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventsResponse {
    // message fields
    // @@protoc_insertion_point(field:EventsResponse.events)
    pub events: ::std::vec::Vec<super::hub_event::HubEvent>,
    // @@protoc_insertion_point(field:EventsResponse.next_page_token)
    pub next_page_token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:EventsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventsResponse {
    fn default() -> &'a EventsResponse {
        <EventsResponse as ::protobuf::Message>::default_instance()
    }
}

impl EventsResponse {
    pub fn new() -> EventsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &EventsResponse| { &m.events },
            |m: &mut EventsResponse| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next_page_token",
            |m: &EventsResponse| { &m.next_page_token },
            |m: &mut EventsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventsResponse>(
            "EventsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventsResponse {
    const NAME: &'static str = "EventsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.next_page_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.next_page_token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventsResponse {
        EventsResponse::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.next_page_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventsResponse {
        static instance: EventsResponse = EventsResponse {
            events: ::std::vec::Vec::new(),
            next_page_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FidAddressTypeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidAddressTypeRequest {
    // message fields
    // @@protoc_insertion_point(field:FidAddressTypeRequest.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:FidAddressTypeRequest.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:FidAddressTypeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidAddressTypeRequest {
    fn default() -> &'a FidAddressTypeRequest {
        <FidAddressTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidAddressTypeRequest {
    pub fn new() -> FidAddressTypeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &FidAddressTypeRequest| { &m.fid },
            |m: &mut FidAddressTypeRequest| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &FidAddressTypeRequest| { &m.address },
            |m: &mut FidAddressTypeRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FidAddressTypeRequest>(
            "FidAddressTypeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FidAddressTypeRequest {
    const NAME: &'static str = "FidAddressTypeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidAddressTypeRequest {
        FidAddressTypeRequest::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidAddressTypeRequest {
        static instance: FidAddressTypeRequest = FidAddressTypeRequest {
            fid: 0,
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FidAddressTypeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FidAddressTypeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FidAddressTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidAddressTypeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FidAddressTypeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidAddressTypeResponse {
    // message fields
    // @@protoc_insertion_point(field:FidAddressTypeResponse.is_custody)
    pub is_custody: bool,
    // @@protoc_insertion_point(field:FidAddressTypeResponse.is_auth)
    pub is_auth: bool,
    // @@protoc_insertion_point(field:FidAddressTypeResponse.is_verified)
    pub is_verified: bool,
    // special fields
    // @@protoc_insertion_point(special_field:FidAddressTypeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidAddressTypeResponse {
    fn default() -> &'a FidAddressTypeResponse {
        <FidAddressTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl FidAddressTypeResponse {
    pub fn new() -> FidAddressTypeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_custody",
            |m: &FidAddressTypeResponse| { &m.is_custody },
            |m: &mut FidAddressTypeResponse| { &mut m.is_custody },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_auth",
            |m: &FidAddressTypeResponse| { &m.is_auth },
            |m: &mut FidAddressTypeResponse| { &mut m.is_auth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_verified",
            |m: &FidAddressTypeResponse| { &m.is_verified },
            |m: &mut FidAddressTypeResponse| { &mut m.is_verified },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FidAddressTypeResponse>(
            "FidAddressTypeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FidAddressTypeResponse {
    const NAME: &'static str = "FidAddressTypeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_custody = is.read_bool()?;
                },
                16 => {
                    self.is_auth = is.read_bool()?;
                },
                24 => {
                    self.is_verified = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_custody != false {
            my_size += 1 + 1;
        }
        if self.is_auth != false {
            my_size += 1 + 1;
        }
        if self.is_verified != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_custody != false {
            os.write_bool(1, self.is_custody)?;
        }
        if self.is_auth != false {
            os.write_bool(2, self.is_auth)?;
        }
        if self.is_verified != false {
            os.write_bool(3, self.is_verified)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidAddressTypeResponse {
        FidAddressTypeResponse::new()
    }

    fn clear(&mut self) {
        self.is_custody = false;
        self.is_auth = false;
        self.is_verified = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidAddressTypeResponse {
        static instance: FidAddressTypeResponse = FidAddressTypeResponse {
            is_custody: false,
            is_auth: false,
            is_verified: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FidAddressTypeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FidAddressTypeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FidAddressTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidAddressTypeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetConnectedPeersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetConnectedPeersRequest {
    // special fields
    // @@protoc_insertion_point(special_field:GetConnectedPeersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConnectedPeersRequest {
    fn default() -> &'a GetConnectedPeersRequest {
        <GetConnectedPeersRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectedPeersRequest {
    pub fn new() -> GetConnectedPeersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConnectedPeersRequest>(
            "GetConnectedPeersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConnectedPeersRequest {
    const NAME: &'static str = "GetConnectedPeersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConnectedPeersRequest {
        GetConnectedPeersRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConnectedPeersRequest {
        static instance: GetConnectedPeersRequest = GetConnectedPeersRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConnectedPeersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConnectedPeersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConnectedPeersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectedPeersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetConnectedPeersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetConnectedPeersResponse {
    // message fields
    // @@protoc_insertion_point(field:GetConnectedPeersResponse.contacts)
    pub contacts: ::std::vec::Vec<super::gossip::ContactInfoBody>,
    // special fields
    // @@protoc_insertion_point(special_field:GetConnectedPeersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConnectedPeersResponse {
    fn default() -> &'a GetConnectedPeersResponse {
        <GetConnectedPeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectedPeersResponse {
    pub fn new() -> GetConnectedPeersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contacts",
            |m: &GetConnectedPeersResponse| { &m.contacts },
            |m: &mut GetConnectedPeersResponse| { &mut m.contacts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConnectedPeersResponse>(
            "GetConnectedPeersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConnectedPeersResponse {
    const NAME: &'static str = "GetConnectedPeersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.contacts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.contacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.contacts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConnectedPeersResponse {
        GetConnectedPeersResponse::new()
    }

    fn clear(&mut self) {
        self.contacts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConnectedPeersResponse {
        static instance: GetConnectedPeersResponse = GetConnectedPeersResponse {
            contacts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConnectedPeersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConnectedPeersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConnectedPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectedPeersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:StoreType)
pub enum StoreType {
    // @@protoc_insertion_point(enum_value:StoreType.STORE_TYPE_NONE)
    STORE_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:StoreType.STORE_TYPE_CASTS)
    STORE_TYPE_CASTS = 1,
    // @@protoc_insertion_point(enum_value:StoreType.STORE_TYPE_LINKS)
    STORE_TYPE_LINKS = 2,
    // @@protoc_insertion_point(enum_value:StoreType.STORE_TYPE_REACTIONS)
    STORE_TYPE_REACTIONS = 3,
    // @@protoc_insertion_point(enum_value:StoreType.STORE_TYPE_USER_DATA)
    STORE_TYPE_USER_DATA = 4,
    // @@protoc_insertion_point(enum_value:StoreType.STORE_TYPE_VERIFICATIONS)
    STORE_TYPE_VERIFICATIONS = 5,
    // @@protoc_insertion_point(enum_value:StoreType.STORE_TYPE_USERNAME_PROOFS)
    STORE_TYPE_USERNAME_PROOFS = 6,
    // @@protoc_insertion_point(enum_value:StoreType.STORE_TYPE_STORAGE_LENDS)
    STORE_TYPE_STORAGE_LENDS = 7,
}

impl ::protobuf::Enum for StoreType {
    const NAME: &'static str = "StoreType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StoreType> {
        match value {
            0 => ::std::option::Option::Some(StoreType::STORE_TYPE_NONE),
            1 => ::std::option::Option::Some(StoreType::STORE_TYPE_CASTS),
            2 => ::std::option::Option::Some(StoreType::STORE_TYPE_LINKS),
            3 => ::std::option::Option::Some(StoreType::STORE_TYPE_REACTIONS),
            4 => ::std::option::Option::Some(StoreType::STORE_TYPE_USER_DATA),
            5 => ::std::option::Option::Some(StoreType::STORE_TYPE_VERIFICATIONS),
            6 => ::std::option::Option::Some(StoreType::STORE_TYPE_USERNAME_PROOFS),
            7 => ::std::option::Option::Some(StoreType::STORE_TYPE_STORAGE_LENDS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<StoreType> {
        match str {
            "STORE_TYPE_NONE" => ::std::option::Option::Some(StoreType::STORE_TYPE_NONE),
            "STORE_TYPE_CASTS" => ::std::option::Option::Some(StoreType::STORE_TYPE_CASTS),
            "STORE_TYPE_LINKS" => ::std::option::Option::Some(StoreType::STORE_TYPE_LINKS),
            "STORE_TYPE_REACTIONS" => ::std::option::Option::Some(StoreType::STORE_TYPE_REACTIONS),
            "STORE_TYPE_USER_DATA" => ::std::option::Option::Some(StoreType::STORE_TYPE_USER_DATA),
            "STORE_TYPE_VERIFICATIONS" => ::std::option::Option::Some(StoreType::STORE_TYPE_VERIFICATIONS),
            "STORE_TYPE_USERNAME_PROOFS" => ::std::option::Option::Some(StoreType::STORE_TYPE_USERNAME_PROOFS),
            "STORE_TYPE_STORAGE_LENDS" => ::std::option::Option::Some(StoreType::STORE_TYPE_STORAGE_LENDS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [StoreType] = &[
        StoreType::STORE_TYPE_NONE,
        StoreType::STORE_TYPE_CASTS,
        StoreType::STORE_TYPE_LINKS,
        StoreType::STORE_TYPE_REACTIONS,
        StoreType::STORE_TYPE_USER_DATA,
        StoreType::STORE_TYPE_VERIFICATIONS,
        StoreType::STORE_TYPE_USERNAME_PROOFS,
        StoreType::STORE_TYPE_STORAGE_LENDS,
    ];
}

impl ::protobuf::EnumFull for StoreType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("StoreType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for StoreType {
    fn default() -> Self {
        StoreType::STORE_TYPE_NONE
    }
}

impl StoreType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StoreType>("StoreType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16request_response.proto\x1a\rmessage.proto\x1a\x0cblocks.proto\x1a\
    \x0fhub_event.proto\x1a\x14username_proof.proto\x1a\x13onchain_event.pro\
    to\x1a\x0cgossip.proto\"\x9f\x01\n\rBlocksRequest\x12\x19\n\x08shard_id\
    \x18\x01\x20\x01(\rR\x07shardId\x12,\n\x12start_block_number\x18\x02\x20\
    \x01(\x04R\x10startBlockNumber\x12/\n\x11stop_block_number\x18\x03\x20\
    \x01(\x04H\0R\x0fstopBlockNumber\x88\x01\x01B\x14\n\x12_stop_block_numbe\
    r\"\xa4\x01\n\x12ShardChunksRequest\x12\x19\n\x08shard_id\x18\x01\x20\
    \x01(\rR\x07shardId\x12,\n\x12start_block_number\x18\x02\x20\x01(\x04R\
    \x10startBlockNumber\x12/\n\x11stop_block_number\x18\x03\x20\x01(\x04H\0\
    R\x0fstopBlockNumber\x88\x01\x01B\x14\n\x12_stop_block_number\"E\n\x13Sh\
    ardChunksResponse\x12.\n\x0cshard_chunks\x18\x01\x20\x03(\x0b2\x0b.Shard\
    ChunkR\x0bshardChunks\"\xa2\x01\n\x10SubscribeRequest\x12.\n\x0bevent_ty\
    pes\x18\x01\x20\x03(\x0e2\r.HubEventTypeR\neventTypes\x12\x1c\n\x07from_\
    id\x18\x02\x20\x01(\x04H\0R\x06fromId\x88\x01\x01\x12$\n\x0bshard_index\
    \x18\x04\x20\x01(\rH\x01R\nshardIndex\x88\x01\x01B\n\n\x08_from_idB\x0e\
    \n\x0c_shard_index\"\x81\x01\n\x07DbStats\x12!\n\x0cnum_messages\x18\x01\
    \x20\x01(\x04R\x0bnumMessages\x122\n\x15num_fid_registrations\x18\x02\
    \x20\x01(\x04R\x13numFidRegistrations\x12\x1f\n\x0bapprox_size\x18\x04\
    \x20\x01(\x04R\napproxSize\"\x81\x02\n\tShardInfo\x12\x19\n\x08shard_id\
    \x18\x01\x20\x01(\rR\x07shardId\x12\x1d\n\nmax_height\x18\x02\x20\x01(\
    \x04R\tmaxHeight\x12!\n\x0cnum_messages\x18\x03\x20\x01(\x04R\x0bnumMess\
    ages\x122\n\x15num_fid_registrations\x18\x04\x20\x01(\x04R\x13numFidRegi\
    strations\x12\x1f\n\x0bapprox_size\x18\x05\x20\x01(\x04R\napproxSize\x12\
    \x1f\n\x0bblock_delay\x18\x06\x20\x01(\x04R\nblockDelay\x12!\n\x0cmempoo\
    l_size\x18\x07\x20\x01(\x04R\x0bmempoolSize\"\x10\n\x0eGetInfoRequest\"\
    \xf7\x01\n\x0fGetInfoResponse\x12\x18\n\x07version\x18\x01\x20\x01(\tR\
    \x07version\x12#\n\x08db_stats\x18\x05\x20\x01(\x0b2\x08.DbStatsR\x07dbS\
    tats\x12\x16\n\x06peerId\x18\x06\x20\x01(\tR\x06peerId\x12\x1d\n\nnum_sh\
    ards\x18\x08\x20\x01(\rR\tnumShards\x12+\n\x0bshard_infos\x18\t\x20\x03(\
    \x0b2\n.ShardInfoR\nshardInfos\x12A\n\x1dnext_engine_version_timestamp\
    \x18\n\x20\x01(\x04R\x1anextEngineVersionTimestamp\"?\n\x0cEventRequest\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12\x1f\n\x0bshard_index\
    \x18\x05\x20\x01(\rR\nshardIndex\"\xac\x01\n\nFidRequest\x12\x10\n\x03fi\
    d\x18\x01\x20\x01(\x04R\x03fid\x12\x20\n\tpage_size\x18\x02\x20\x01(\rH\
    \0R\x08pageSize\x88\x01\x01\x12\"\n\npage_token\x18\x03\x20\x01(\x0cH\
    \x01R\tpageToken\x88\x01\x01\x12\x1d\n\x07reverse\x18\x04\x20\x01(\x08H\
    \x02R\x07reverse\x88\x01\x01B\x0c\n\n_page_sizeB\r\n\x0b_page_tokenB\n\n\
    \x08_reverse\"\xb6\x02\n\x13FidTimestampRequest\x12\x10\n\x03fid\x18\x01\
    \x20\x01(\x04R\x03fid\x12\x20\n\tpage_size\x18\x02\x20\x01(\rH\0R\x08pag\
    eSize\x88\x01\x01\x12\"\n\npage_token\x18\x03\x20\x01(\x0cH\x01R\tpageTo\
    ken\x88\x01\x01\x12\x1d\n\x07reverse\x18\x04\x20\x01(\x08H\x02R\x07rever\
    se\x88\x01\x01\x12,\n\x0fstart_timestamp\x18\x05\x20\x01(\x04H\x03R\x0es\
    tartTimestamp\x88\x01\x01\x12*\n\x0estop_timestamp\x18\x06\x20\x01(\x04H\
    \x04R\rstopTimestamp\x88\x01\x01B\x0c\n\n_page_sizeB\r\n\x0b_page_tokenB\
    \n\n\x08_reverseB\x12\n\x10_start_timestampB\x11\n\x0f_stop_timestamp\"\
    \xb6\x01\n\x0bFidsRequest\x12\x20\n\tpage_size\x18\x01\x20\x01(\rH\0R\
    \x08pageSize\x88\x01\x01\x12\"\n\npage_token\x18\x02\x20\x01(\x0cH\x01R\
    \tpageToken\x88\x01\x01\x12\x1d\n\x07reverse\x18\x03\x20\x01(\x08H\x02R\
    \x07reverse\x88\x01\x01\x12\x19\n\x08shard_id\x18\x04\x20\x01(\rR\x07sha\
    rdIdB\x0c\n\n_page_sizeB\r\n\x0b_page_tokenB\n\n\x08_reverse\"c\n\x0cFid\
    sResponse\x12\x12\n\x04fids\x18\x01\x20\x03(\x04R\x04fids\x12+\n\x0fnext\
    _page_token\x18\x02\x20\x01(\x0cH\0R\rnextPageToken\x88\x01\x01B\x12\n\
    \x10_next_page_token\"y\n\x10MessagesResponse\x12$\n\x08messages\x18\x01\
    \x20\x03(\x0b2\x08.MessageR\x08messages\x12+\n\x0fnext_page_token\x18\
    \x02\x20\x01(\x0cH\0R\rnextPageToken\x88\x01\x01B\x12\n\x10_next_page_to\
    ken\"\x80\x02\n\x14CastsByParentRequest\x12/\n\x0eparent_cast_id\x18\x01\
    \x20\x01(\x0b2\x07.CastIdH\0R\x0cparentCastId\x12\x1f\n\nparent_url\x18\
    \x05\x20\x01(\tH\0R\tparentUrl\x12\x20\n\tpage_size\x18\x02\x20\x01(\rH\
    \x01R\x08pageSize\x88\x01\x01\x12\"\n\npage_token\x18\x03\x20\x01(\x0cH\
    \x02R\tpageToken\x88\x01\x01\x12\x1d\n\x07reverse\x18\x04\x20\x01(\x08H\
    \x03R\x07reverse\x88\x01\x01B\x08\n\x06parentB\x0c\n\n_page_sizeB\r\n\
    \x0b_page_tokenB\n\n\x08_reverse\"\xb3\x01\n\x0fReactionRequest\x12\x10\
    \n\x03fid\x18\x01\x20\x01(\x04R\x03fid\x122\n\rreaction_type\x18\x02\x20\
    \x01(\x0e2\r.ReactionTypeR\x0creactionType\x12/\n\x0etarget_cast_id\x18\
    \x03\x20\x01(\x0b2\x07.CastIdH\0R\x0ctargetCastId\x12\x1f\n\ntarget_url\
    \x18\x04\x20\x01(\tH\0R\ttargetUrlB\x08\n\x06target\"\x82\x02\n\x15React\
    ionsByFidRequest\x12\x10\n\x03fid\x18\x01\x20\x01(\x04R\x03fid\x127\n\rr\
    eaction_type\x18\x02\x20\x01(\x0e2\r.ReactionTypeH\0R\x0creactionType\
    \x88\x01\x01\x12\x20\n\tpage_size\x18\x03\x20\x01(\rH\x01R\x08pageSize\
    \x88\x01\x01\x12\"\n\npage_token\x18\x04\x20\x01(\x0cH\x02R\tpageToken\
    \x88\x01\x01\x12\x1d\n\x07reverse\x18\x05\x20\x01(\x08H\x03R\x07reverse\
    \x88\x01\x01B\x10\n\x0e_reaction_typeB\x0c\n\n_page_sizeB\r\n\x0b_page_t\
    okenB\n\n\x08_reverse\"\xcf\x02\n\x18ReactionsByTargetRequest\x12/\n\x0e\
    target_cast_id\x18\x01\x20\x01(\x0b2\x07.CastIdH\0R\x0ctargetCastId\x12\
    \x1f\n\ntarget_url\x18\x06\x20\x01(\tH\0R\ttargetUrl\x127\n\rreaction_ty\
    pe\x18\x02\x20\x01(\x0e2\r.ReactionTypeH\x01R\x0creactionType\x88\x01\
    \x01\x12\x20\n\tpage_size\x18\x03\x20\x01(\rH\x02R\x08pageSize\x88\x01\
    \x01\x12\"\n\npage_token\x18\x04\x20\x01(\x0cH\x03R\tpageToken\x88\x01\
    \x01\x12\x1d\n\x07reverse\x18\x05\x20\x01(\x08H\x04R\x07reverse\x88\x01\
    \x01B\x08\n\x06targetB\x10\n\x0e_reaction_typeB\x0c\n\n_page_sizeB\r\n\
    \x0b_page_tokenB\n\n\x08_reverse\"X\n\x0fUserDataRequest\x12\x10\n\x03fi\
    d\x18\x01\x20\x01(\x04R\x03fid\x123\n\x0euser_data_type\x18\x02\x20\x01(\
    \x0e2\r.UserDataTypeR\x0cuserDataType\"\xe7\x01\n\x13OnChainEventRequest\
    \x12\x10\n\x03fid\x18\x01\x20\x01(\x04R\x03fid\x120\n\nevent_type\x18\
    \x02\x20\x01(\x0e2\x11.OnChainEventTypeR\teventType\x12\x20\n\tpage_size\
    \x18\x03\x20\x01(\rH\0R\x08pageSize\x88\x01\x01\x12\"\n\npage_token\x18\
    \x04\x20\x01(\x0cH\x01R\tpageToken\x88\x01\x01\x12\x1d\n\x07reverse\x18\
    \x05\x20\x01(\x08H\x02R\x07reverse\x88\x01\x01B\x0c\n\n_page_sizeB\r\n\
    \x0b_page_tokenB\n\n\x08_reverse\"~\n\x14OnChainEventResponse\x12%\n\x06\
    events\x18\x01\x20\x03(\x0b2\r.OnChainEventR\x06events\x12+\n\x0fnext_pa\
    ge_token\x18\x02\x20\x01(\x0cH\0R\rnextPageToken\x88\x01\x01B\x12\n\x10_\
    next_page_token\"T\n\x0bTierDetails\x12&\n\ttier_type\x18\x01\x20\x01(\
    \x0e2\t.TierTypeR\x08tierType\x12\x1d\n\nexpires_at\x18\x02\x20\x01(\x04\
    R\texpiresAt\"\xc9\x01\n\x15StorageLimitsResponse\x12%\n\x06limits\x18\
    \x01\x20\x03(\x0b2\r.StorageLimitR\x06limits\x12\x14\n\x05units\x18\x02\
    \x20\x01(\rR\x05units\x126\n\x0cunit_details\x18\x03\x20\x03(\x0b2\x13.S\
    torageUnitDetailsR\x0bunitDetails\x12;\n\x12tier_subscriptions\x18\x04\
    \x20\x03(\x0b2\x0c.TierDetailsR\x11tierSubscriptions\"`\n\x12StorageUnit\
    Details\x12-\n\tunit_type\x18\x01\x20\x01(\x0e2\x10.StorageUnitTypeR\x08\
    unitType\x12\x1b\n\tunit_size\x18\x02\x20\x01(\rR\x08unitSize\"\xc9\x01\
    \n\x0cStorageLimit\x12)\n\nstore_type\x18\x01\x20\x01(\x0e2\n.StoreTypeR\
    \tstoreType\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x14\n\x05l\
    imit\x18\x03\x20\x01(\x04R\x05limit\x12\x12\n\x04used\x18\x04\x20\x01(\
    \x04R\x04used\x12,\n\x11earliestTimestamp\x18\x05\x20\x01(\x04R\x11earli\
    estTimestamp\x12\"\n\x0cearliestHash\x18\x06\x20\x01(\x0cR\x0cearliestHa\
    sh\"*\n\x14UsernameProofRequest\x12\x12\n\x04name\x18\x01\x20\x01(\x0cR\
    \x04name\"@\n\x16UsernameProofsResponse\x12&\n\x06proofs\x18\x01\x20\x03\
    (\x0b2\x0e.UserNameProofR\x06proofs\"N\n\x12ValidationResponse\x12\x14\n\
    \x05valid\x18\x01\x20\x01(\x08R\x05valid\x12\"\n\x07message\x18\x02\x20\
    \x01(\x0b2\x08.MessageR\x07message\"A\n\x13VerificationRequest\x12\x10\n\
    \x03fid\x18\x01\x20\x01(\x04R\x03fid\x12\x18\n\x07address\x18\x02\x20\
    \x01(\x0cR\x07address\"9\n\rSignerRequest\x12\x10\n\x03fid\x18\x01\x20\
    \x01(\x04R\x03fid\x12\x16\n\x06signer\x18\x02\x20\x01(\x0cR\x06signer\"g\
    \n\x0bLinkRequest\x12\x10\n\x03fid\x18\x01\x20\x01(\x04R\x03fid\x12\x1b\
    \n\tlink_type\x18\x02\x20\x01(\tR\x08linkType\x12\x1f\n\ntarget_fid\x18\
    \x03\x20\x01(\x04H\0R\ttargetFidB\x08\n\x06target\"\xe3\x01\n\x11LinksBy\
    FidRequest\x12\x10\n\x03fid\x18\x01\x20\x01(\x04R\x03fid\x12\x20\n\tlink\
    _type\x18\x02\x20\x01(\tH\0R\x08linkType\x88\x01\x01\x12\x20\n\tpage_siz\
    e\x18\x03\x20\x01(\rH\x01R\x08pageSize\x88\x01\x01\x12\"\n\npage_token\
    \x18\x04\x20\x01(\x0cH\x02R\tpageToken\x88\x01\x01\x12\x1d\n\x07reverse\
    \x18\x05\x20\x01(\x08H\x03R\x07reverse\x88\x01\x01B\x0c\n\n_link_typeB\
    \x0c\n\n_page_sizeB\r\n\x0b_page_tokenB\n\n\x08_reverse\"\xff\x01\n\x14L\
    inksByTargetRequest\x12\x1f\n\ntarget_fid\x18\x01\x20\x01(\x04H\0R\ttarg\
    etFid\x12\x20\n\tlink_type\x18\x02\x20\x01(\tH\x01R\x08linkType\x88\x01\
    \x01\x12\x20\n\tpage_size\x18\x03\x20\x01(\rH\x02R\x08pageSize\x88\x01\
    \x01\x12\"\n\npage_token\x18\x04\x20\x01(\x0cH\x03R\tpageToken\x88\x01\
    \x01\x12\x1d\n\x07reverse\x18\x05\x20\x01(\x08H\x04R\x07reverse\x88\x01\
    \x01B\x08\n\x06targetB\x0c\n\n_link_typeB\x0c\n\n_page_sizeB\r\n\x0b_pag\
    e_tokenB\n\n\x08_reverse\";\n\x1fIdRegistryEventByAddressRequest\x12\x18\
    \n\x07address\x18\x01\x20\x01(\x0cR\x07address\"A\n\x19SubmitBulkMessage\
    sRequest\x12$\n\x08messages\x18\x01\x20\x03(\x0b2\x08.MessageR\x08messag\
    es\"V\n\x0cMessageError\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\
    \x12\x18\n\x07errCode\x18\x02\x20\x01(\tR\x07errCode\x12\x18\n\x07messag\
    e\x18\x03\x20\x01(\tR\x07message\"}\n\x13BulkMessageResponse\x12$\n\x07m\
    essage\x18\x01\x20\x01(\x0b2\x08.MessageH\0R\x07message\x124\n\rmessage_\
    error\x18\x02\x20\x01(\x0b2\r.MessageErrorH\0R\x0cmessageErrorB\n\n\x08r\
    esponse\"N\n\x1aSubmitBulkMessagesResponse\x120\n\x08messages\x18\x01\
    \x20\x03(\x0b2\x14.BulkMessageResponseR\x08messages\"L\n\x17TrieNodeMeta\
    dataRequest\x12\x19\n\x08shard_id\x18\x01\x20\x01(\rR\x07shardId\x12\x16\
    \n\x06prefix\x18\x02\x20\x01(\x0cR\x06prefix\"\xa0\x01\n\x18TrieNodeMeta\
    dataResponse\x12\x16\n\x06prefix\x18\x01\x20\x01(\x0cR\x06prefix\x12!\n\
    \x0cnum_messages\x18\x02\x20\x01(\x04R\x0bnumMessages\x12\x12\n\x04hash\
    \x18\x03\x20\x01(\tR\x04hash\x125\n\x08children\x18\x04\x20\x03(\x0b2\
    \x19.TrieNodeMetadataResponseR\x08children\"\x98\x02\n\rEventsRequest\
    \x12\x19\n\x08start_id\x18\x01\x20\x01(\x04R\x07startId\x12$\n\x0bshard_\
    index\x18\x02\x20\x01(\rH\0R\nshardIndex\x88\x01\x01\x12\x1c\n\x07stop_i\
    d\x18\x03\x20\x01(\x04H\x01R\x06stopId\x88\x01\x01\x12\x20\n\tpage_size\
    \x18\x04\x20\x01(\rH\x02R\x08pageSize\x88\x01\x01\x12\"\n\npage_token\
    \x18\x05\x20\x01(\x0cH\x03R\tpageToken\x88\x01\x01\x12\x1d\n\x07reverse\
    \x18\x06\x20\x01(\x08H\x04R\x07reverse\x88\x01\x01B\x0e\n\x0c_shard_inde\
    xB\n\n\x08_stop_idB\x0c\n\n_page_sizeB\r\n\x0b_page_tokenB\n\n\x08_rever\
    se\"t\n\x0eEventsResponse\x12!\n\x06events\x18\x01\x20\x03(\x0b2\t.HubEv\
    entR\x06events\x12+\n\x0fnext_page_token\x18\x02\x20\x01(\x0cH\0R\rnextP\
    ageToken\x88\x01\x01B\x12\n\x10_next_page_token\"C\n\x15FidAddressTypeRe\
    quest\x12\x10\n\x03fid\x18\x01\x20\x01(\x04R\x03fid\x12\x18\n\x07address\
    \x18\x02\x20\x01(\x0cR\x07address\"q\n\x16FidAddressTypeResponse\x12\x1d\
    \n\nis_custody\x18\x01\x20\x01(\x08R\tisCustody\x12\x17\n\x07is_auth\x18\
    \x02\x20\x01(\x08R\x06isAuth\x12\x1f\n\x0bis_verified\x18\x03\x20\x01(\
    \x08R\nisVerified\"\x1a\n\x18GetConnectedPeersRequest\"I\n\x19GetConnect\
    edPeersResponse\x12,\n\x08contacts\x18\x01\x20\x03(\x0b2\x10.ContactInfo\
    BodyR\x08contacts*\xdc\x01\n\tStoreType\x12\x13\n\x0fSTORE_TYPE_NONE\x10\
    \0\x12\x14\n\x10STORE_TYPE_CASTS\x10\x01\x12\x14\n\x10STORE_TYPE_LINKS\
    \x10\x02\x12\x18\n\x14STORE_TYPE_REACTIONS\x10\x03\x12\x18\n\x14STORE_TY\
    PE_USER_DATA\x10\x04\x12\x1c\n\x18STORE_TYPE_VERIFICATIONS\x10\x05\x12\
    \x1e\n\x1aSTORE_TYPE_USERNAME_PROOFS\x10\x06\x12\x1c\n\x18STORE_TYPE_STO\
    RAGE_LENDS\x10\x07b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(super::message::file_descriptor().clone());
            deps.push(super::blocks::file_descriptor().clone());
            deps.push(super::hub_event::file_descriptor().clone());
            deps.push(super::username_proof::file_descriptor().clone());
            deps.push(super::onchain_event::file_descriptor().clone());
            deps.push(super::gossip::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(46);
            messages.push(BlocksRequest::generated_message_descriptor_data());
            messages.push(ShardChunksRequest::generated_message_descriptor_data());
            messages.push(ShardChunksResponse::generated_message_descriptor_data());
            messages.push(SubscribeRequest::generated_message_descriptor_data());
            messages.push(DbStats::generated_message_descriptor_data());
            messages.push(ShardInfo::generated_message_descriptor_data());
            messages.push(GetInfoRequest::generated_message_descriptor_data());
            messages.push(GetInfoResponse::generated_message_descriptor_data());
            messages.push(EventRequest::generated_message_descriptor_data());
            messages.push(FidRequest::generated_message_descriptor_data());
            messages.push(FidTimestampRequest::generated_message_descriptor_data());
            messages.push(FidsRequest::generated_message_descriptor_data());
            messages.push(FidsResponse::generated_message_descriptor_data());
            messages.push(MessagesResponse::generated_message_descriptor_data());
            messages.push(CastsByParentRequest::generated_message_descriptor_data());
            messages.push(ReactionRequest::generated_message_descriptor_data());
            messages.push(ReactionsByFidRequest::generated_message_descriptor_data());
            messages.push(ReactionsByTargetRequest::generated_message_descriptor_data());
            messages.push(UserDataRequest::generated_message_descriptor_data());
            messages.push(OnChainEventRequest::generated_message_descriptor_data());
            messages.push(OnChainEventResponse::generated_message_descriptor_data());
            messages.push(TierDetails::generated_message_descriptor_data());
            messages.push(StorageLimitsResponse::generated_message_descriptor_data());
            messages.push(StorageUnitDetails::generated_message_descriptor_data());
            messages.push(StorageLimit::generated_message_descriptor_data());
            messages.push(UsernameProofRequest::generated_message_descriptor_data());
            messages.push(UsernameProofsResponse::generated_message_descriptor_data());
            messages.push(ValidationResponse::generated_message_descriptor_data());
            messages.push(VerificationRequest::generated_message_descriptor_data());
            messages.push(SignerRequest::generated_message_descriptor_data());
            messages.push(LinkRequest::generated_message_descriptor_data());
            messages.push(LinksByFidRequest::generated_message_descriptor_data());
            messages.push(LinksByTargetRequest::generated_message_descriptor_data());
            messages.push(IdRegistryEventByAddressRequest::generated_message_descriptor_data());
            messages.push(SubmitBulkMessagesRequest::generated_message_descriptor_data());
            messages.push(MessageError::generated_message_descriptor_data());
            messages.push(BulkMessageResponse::generated_message_descriptor_data());
            messages.push(SubmitBulkMessagesResponse::generated_message_descriptor_data());
            messages.push(TrieNodeMetadataRequest::generated_message_descriptor_data());
            messages.push(TrieNodeMetadataResponse::generated_message_descriptor_data());
            messages.push(EventsRequest::generated_message_descriptor_data());
            messages.push(EventsResponse::generated_message_descriptor_data());
            messages.push(FidAddressTypeRequest::generated_message_descriptor_data());
            messages.push(FidAddressTypeResponse::generated_message_descriptor_data());
            messages.push(GetConnectedPeersRequest::generated_message_descriptor_data());
            messages.push(GetConnectedPeersResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(StoreType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
